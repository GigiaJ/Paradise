After having explored setting up and interfacing with the Rust sdk I believe we're in a good state to actually
start building out the *actual* UI.
Now re-frame more or less trivializes this and enables us to write a UI and then wire it up later.

For base functionality I would define the minimum usable product as:
- Spaces navigation (and DMs)
- Room navigation
- Timeline
- Message box
- Login

So these would be the first things to build on.
We'll continue to keep our minimalist login page, but we'll start trying to do a bit more polish on the
actual UI components themselves.

#+begin_src clojurescript :tangle ../src/app.cljs
(ns app
  (:require
   [re-frame.core :as re-frame]
   [taoensso.timbre :as log]
   [promesa.core :as p]
   [reagent.core :as r]
   [reagent.dom.client :as rdom]
   [spaces.bar :refer [spaces-sidebar]]
   [timeline.base :refer [timeline]]
   [auth.events :refer [login-screen]]
   [client.login :refer [bootstrap!]]
   [room.room-list :refer [room-list]]
   ))
#+end_src


For testing purposes we'd want to stage a general UI to template against.
This also serves as a good example of where to start with modifying the UI
#+begin_src clojurescript :tangle ../src/app.cljs
#_(def default-db
  {:spaces {"!space1:example.com" {:id "!space1:example.com" :name "Main Space" :parent-id nil}
            "!space2:example.com" {:id "!space2:example.com" :name "Sub Space" :parent-id "!space1:example.com"}
            "!space3:example.com" {:id "!space3:example.com" :name "Other Space" :parent-id nil}}
   :rooms {"!room1:example.com" {:id "!room1:example.com" :name "general" :parent-id "!space1:example.com"}
           "!room2:example.com" {:id "!room2:example.com" :name "random" :parent-id "!space1:example.com"}
           "!room3:example.com" {:id "!room3:example.com" :name "cljs-dev" :parent-id "!space2:example.com"}}
   :active-space-id "!space1:example.com"
   :active-room-id "!room1:example.com"})

(def default-db
  {:spaces {}
   :rooms  {}
   :active-space-id nil
   :active-room-id  nil
   :auth-status :checking
   :login-error nil
   :client nil
   })
#+end_src


This is the initializer for the global reframe object
For some more info you can look here:
https://day8.github.io/re-frame/application-state/
#+begin_src clojurescript :tangle ../src/app.cljs
(re-frame/reg-event-db
 :initialize-db
 (fn [_ _]
   default-db))
#+end_src

#+begin_src clojurescript :tangle ../src/app.cljs
(re-frame/reg-sub
 :auth/status
 (fn [db _] (:auth-status db)))

(re-frame/reg-sub
 :auth/error
 (fn [db _] (:login-error db)))

(re-frame/reg-event-fx
 :app/bootstrap
 (fn [{:keys [db]} _]
   (do
     (log/debug "Bootstrapping")
     (bootstrap!
    (fn [client session-data]
      (if client
             (re-frame/dispatch [:auth/login-success client session-data])
        #_(p/let [_ (re-frame/dispatch-sync [:sdk/set-client raw-client])
                _ (login/start-sync! raw-client)
                _ (register-sw! (.-accessToken (.-session session-json)))

                ]
          nil)
        (re-frame/dispatch [:auth/login-failure nil])
        ))))
   {:db (assoc db :auth-status :checking)}))

#+end_src

Now this is the actual code that handles rendering. Short, yeah?
It doesn't actually need to be overtly verbose. Reframe let's us
just focus on the part we actually care about. The benefits of Clojure
providing the encapsulation and parsing for us.
#+begin_src clojurescript :tangle ../src/app.cljs
(defn main-layout []
  (let [auth-status @(re-frame/subscribe [:auth/status])
        _ (log/debug auth-status)]
    (case auth-status
      :checking
      [:div.flex.h-screen.items-center.justify-center.bg-gray-900.text-white
       "Booting Matrix SDK..."]
      (:logged-out :authenticating)
      [login-screen]
      :logged-in
      [:div.app-root
       [spaces-sidebar]
       [room-list]
       [timeline]]
      [:div "Unknown State"])))
#+end_src


This is to mount our application at the element with the ID "root" inside
our index.html. It's effectively just an attachment point for us to latch
onto.
Also inside is th init function which informs reframe to start up
as well as a method that instructs shadow-cljs how to handle the re-render
when we detatch and reload (basically when you hit control + s to save).
#+begin_src clojurescript :tangle ../src/app.cljs
(defonce root (atom nil))

(defn mount-root []
  (re-frame/clear-subscription-cache!)
  (let [container (.getElementById js/document "root")]
    (when-not @root
      (reset! root (rdom/create-root container)))
    (.render @root (r/as-element [main-layout]))))

(defn ^:export init []
  (re-frame/dispatch-sync [:initialize-db])
  (re-frame/dispatch [:app/bootstrap])
  (mount-root))

(defn ^:after-load re-render []
  (mount-root))
#+end_src
