
*** The Service Worker

So a web-based matrix client usually follows the pattern of using service workers
to provide long-lived functionality. This includes background behavior when we
say use it even as a native app or a PWA on phones. It is through the service
worker that we can asynchronously fetch images from the server or deliver push notifications.
It is safe to say that the service worker is a very important component to
most web applications, not just web-based Matrix clients.
#+begin_src clojurescript :tangle ../src/service_worker.cljs
(ns service-worker
  (:require [clojure.string :as str]
            [promesa.core :as p]))
#+end_src

#+begin_src clojurescript :tangle ../src/service_worker.cljs
(defonce auth-token (atom nil))
#+end_src

The message event is how the client communicates with the service worker.
It passes 'messages' to the service worker and the service worker passes
'messages' to the client. It is not too dissimilar to postMessage for
communicating with iframes.

https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage


Now we go a bit further and store the client-id of the session in-case
later we wish to provide multi-session functionality more implicitly.
This also provides a level of security ensuring we don't accidentally
send data to the wrong client instance. By having the full session on
hand we have the home-server and the token used too.
#+begin_src clojurescript :tangle ../src/service_worker.cljs
(defonce active-sessions (atom {}))
(defonce session-resolver (atom nil))
(defonce session-promise
  (js/Promise. (fn [resolve]
                 (reset! session-resolver resolve))))

(.addEventListener js/self "message"
  (fn [event]
    (let [data (.-data event)
          source-id (.. event -source -id)]
      (when (= (.-type data) "SET_SESSION")
        (let [session-data (:session (js->clj data :keywordize-keys true))
              full-session (assoc session-data :client-id source-id)]
          (swap! active-sessions assoc source-id full-session)
          (when @session-resolver (@session-resolver full-session))
          (js/console.log "SW: Session updated for client:" source-id))))))
#+end_src

If possible we want to manage the cache and we want to also make sure we don't
cache items that are too old. By caching we provide a level of offline access.

One might wonder about the cache security. It is true that on desktop
the cache is not encrypted by default, but it is however isolated and secure.

The browser ensures this much at least. It would be the expectation of the
user to encrypt their device. The performance impact of encrypting and
decrypting the cache would be noticeable to the performance of the application.
Not to mention entirely impractical as if an attacker has access to the cache then
they also have access to the key to decrypt it.

For mobile users can take solace we can rely on the fact their operating system
encrypt the disk at rest (Full Disk Encryption).

#+begin_src clojurescript :tangle ../src/service_worker.cljs
(defn prune-cache! [cache-name max-items]
  (p/let [cache (js/caches.open cache-name)
          keys  (.keys cache)]
    (when (> (.-length keys) max-items)
      (.delete cache (first keys)))))
#+end_src


The fetch event is vital for the client to asynchronously 'fetch' images from a
server so that we may allow the client to worry simply on the elements it can
render immediately.

We only want to bother fetching authenticated media with the expected
media endpoints. We validate the URL to ensure we don't leak info unexpectedly.

Some important readings for this:
https://spec.matrix.org/latest/client-server-api/#matrix-content-mxc-uris

https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/fetch_event

We also want to define a cache so that users don't bother endlessly re-fetching assets on reloads
#+begin_src clojurescript :tangle ../src/service_worker.cljs
(def cache-name "matrix-media-v1")


(js/self.addEventListener "fetch"
  (fn [event]
    (let [request   (.-request event)
          method    (.-method request)
          client-id (.-clientId event)
          url       (js/URL. (.-url request))
          path      (.-pathname url)
          is-auth   (str/includes? path "/_matrix/client/v1/media/")]
      (cond
        (and (= method "GET")
             (or is-auth (str/includes? path "/_matrix/media/v3/")))
        (.respondWith event
          (p/let [cache  (js/caches.open cache-name)
                  cached (.match cache request)]
            (if cached
              cached
              (p/let [session (some #(when (= client-id (:client-id %)) %)
                                    (vals @active-sessions))
                      token   (:accessToken session)
                      headers (js/Headers. (.-headers request))]
                (when (and is-auth token)
                  (.set headers "Authorization" (str "Bearer " token)))
                (p/let [resp (js/fetch (.-url request) #js {:headers headers :mode "cors"})]
                  (when (and (.-ok resp)
                             (< (js/parseInt (.get (.-headers resp) "content-length") 10) 10485760))
                    (.put cache request (.clone resp)))
                  resp)))))
        :else nil))))
#+end_src

The install event is the first event in the lifecycle of a service worker.
Once this goes off the service worker starts to come alive.
#+begin_src clojurescript :tangle ../src/service_worker.cljs
(js/self.addEventListener "install"
  (fn [event]
    (.skipWaiting js/self)))
#+end_src

So the service worker needs to be 'activated' and then once activated we want to
immediately claim all clients so we can start fetching for them.
#+begin_src clojurescript :tangle ../src/service_worker.cljs
(js/self.addEventListener "activate"
  (fn [event]
    (.waitUntil event (.clients.claim js/self))))
#+end_src

Shadow-cljs seems to be a bit opinionated in how it generates the service worker file.
That and the documentation for web-workers isn't amazingly clear, nonetheless it does
provide enough info continue anyway.
https://shadow-cljs.github.io/docs/UsersGuide.html#_web_workers
/In fact the documentation here states it'd generate a file named worker.js yet, we're getting a
sw.js/

Not a large issue, but one I felt needed to be clarified to avoid potential confusion.

Now below we have our actual service worker handler. This is where we'll define any service worker
logic that is to be used from the main application itself.
#+begin_src clojurescript :tangle ../src/service_worker_handler.cljs
(ns service-worker-handler
  (:require
            [taoensso.timbre :as log]
            [re-frame.db :as db]
            [re-frame.core :as re-frame]))
#+end_src

The major functionality we need is to register the service worker itself.
We do so while passing off the session token so that the service worker
may immediately begin to render our images.
#+begin_src clojurescript :tangle ../src/service_worker_handler.cljs
(defn register-sw! [session]
  (when (exists? js/navigator.serviceWorker)
    (-> (js/navigator.serviceWorker.register "/sw.js" #js {:type "module"})
        (.then (fn [reg]
                 (when (.-waiting reg)
                   (.postMessage (.-waiting reg) #js {:type "SKIP_WAITING"}))
                 (when (and (.-controller js/navigator.serviceWorker) session)
                   (re-frame/dispatch [:auth/sync-sw-only session])))))))
#+end_src


Now, since we're using reframe we want to ensure we're providing our rendering
implementation an easy way to inform updates to the service worker.
We may wish to break this apart a bit for re-usability, but for now this will do.
#+begin_src clojurescript :tangle ../src/service_worker_handler.cljs
(re-frame/reg-event-fx
 :auth/sync-sw-only
 (fn [_ [_ session]]
   {:sync-sw-auth session}))

(re-frame/reg-event-fx
 :auth/save-session
 (fn [{:keys [db]} [_ {:keys [access-token user-id homeserver]}]]
   {:db (assoc db :access-token access-token :user-id user-id :homeserver homeserver)
    :sync-sw-auth {:token access-token :homeserver homeserver}}))

(re-frame/reg-fx
 :sync-sw-auth
 (fn [session]
   (if-let [sw-controller (.-controller js/navigator.serviceWorker)]
     (try
       (let [origin (.-origin (js/URL. (:homeserverUrl session)))
             payload (assoc session :origin origin)]
         (.postMessage sw-controller #js {:type "SET_SESSION"
                                          :session (clj->js payload)})
         (js/console.log "re-frame: Session synced for" (:userId session) "at" origin))
       (catch js/Error e
         (js/console.error "re-frame: Failed to parse homeserver URL" e)))
     (js/console.warn "re-frame: SW controller not found"))))
#+end_src
