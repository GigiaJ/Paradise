#+begin_src clojurescript :tangle ../../src/client/session_store.cljs
(ns client.session-store
(:require [promesa.core :as p]
          [taoensso.timbre :as log]
          ["generated-compat" :as sdk]))
#+end_src

*** Constants and Utilities

First, we define the key used in localStorage.
This is the "root" key under which all user sessions will be serialized.
#+begin_src clojurescript :tangle ../../src/client/session_store.cljs
(def ^:private storage-key "mx_session_v3")
#+end_src


We need a helper to verify we can actually find the Rust classes.
This grabs the Session constructor from the matrix_sdk namespace within our bundle.
#+begin_src clojurescript :tangle ../../src/client/session_store.cljs
(defn- get-session-class []
  ;; Use the exact same root-finding logic that worked in login.cljs!
  (let [sdk-root (if (.-Session sdk) sdk (.-default sdk))]
    (if sdk-root
      (.-Session sdk-root)
      (log/error "FATAL: Could not find Session class on root SDK object."))))
#+end_src


*** Persistence Helpers

We need standard low-level helpers to read and write raw JSON to the browser's local storage.
We keep these as simple JavaScript object operations to avoid unnecessary overhead from
converting back and forth to Clojure maps constantly.
#+begin_src clojurescript :tangle ../../src/client/session_store.cljs
(defn- load-raw-sessions-js []
(let [stored (.getItem js/localStorage storage-key)]
(if stored
(.parse js/JSON stored)
#js {})))

(defn- save-raw-sessions-js! [sessions-obj]
(.setItem js/localStorage storage-key (.stringify js/JSON sessions-obj)))
#+end_src

We also need a cryptographic implementation for generating passphrases.
The Rust SDK uses this passphrase to encrypt the IndexedDB where the actual keys and messages live.
#+begin_src clojurescript :tangle ../../src/client/session_store.cljs
(defn generate-passphrase []
(let [array (js/Uint8Array. 32)]
(.getRandomValues js/crypto array)
(js/btoa (.apply js/String.fromCharCode nil array))))
#+end_src


#+begin_src clojurescript :tangle ../../src/client/session_store.cljs
(defn- generate-uuid []
  (if (and (exists? js/crypto) (exists? (.-randomUUID js/crypto)))
    (.randomUUID js/crypto)
    (let [template "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx"]
      (.replace template 
                (js/RegExp. "[xy]" "g") 
                (fn [c]
                  (let [r (bit-or (* (js/Math.random) 16) 0)
                        v (if (= c "x") r (bit-or (bit-and r 0x3) 0x8))]
                    (.toString v 16)))))))
#+end_src



*** IndexedDB Management

This function handles the deletion of the encrypted database.
It wraps the raw IDBRequest in a Promise so we can await its
completion before clearing the session metadata.
We standardize on the name prefix closura-store-.
#+begin_src clojurescript :tangle ../../src/client/session_store.cljs
(defn- delete-store-impl! [store-id]
(let [store-name (str "closura-store-" store-id)]
(js/Promise. (fn [resolve _]
(let [request (.deleteDatabase js/indexedDB store-name)]
(set! (.-onsuccess request) #(resolve))
(set! (.-onerror request) #(resolve))
(set! (.-onblocked request) #(resolve)))))))
#+end_src


*** Implementation Logic

These functions form the "brain" of the store.
They are defined outside the deftype for easier testing and cleaner syntax.



This re-hydrates the Rust Session objects. The data in localStorage is just JSON;
we must pass it into Session.new() so the SDK can use it.

#+begin_src clojurescript :tangle ../../src/client/session_store.cljs
(defn- load-sessions-sync-impl []
(let [sessions (load-raw-sessions-js)
      Session (get-session-class)]
(when Session
(doseq [user-id (js/Object.keys sessions)]
(let [data (aget sessions user-id)]
(aset sessions user-id
#js {:session (.new Session (aget data "session"))
:passphrase (aget data "passphrase")
:storeId (aget data "storeId")}))))
sessions))
#+end_src

Updates a specific user's session while preserving others.
#+begin_src clojurescript :tangle ../../src/client/session_store.cljs
(defn- save-session-impl! [session passphrase store-id]
(let [user-id (.-userId session)
sessions (load-raw-sessions-js)
existing (aget sessions user-id)
final-pass (or passphrase (when existing (aget existing "passphrase")))
final-id   (or store-id   (when existing (aget existing "storeId")))]

(when (and final-pass final-id)
  (aset sessions user-id #js {:session session
                              :passphrase final-pass
                              :storeId final-id})
  (save-raw-sessions-js! sessions))))
#+end_src

Removes the specific user's database and metadata.
#+begin_src clojurescript :tangle ../../src/client/session_store.cljs
(defn- clear-session-impl! [user-id]
(let [sessions (load-raw-sessions-js)
data (aget sessions user-id)]
(p/do
(when-let [sid (and data (aget data "storeId"))]
(delete-store-impl! sid))
  (js-delete sessions user-id)
  (save-raw-sessions-js! sessions))))
#+end_src


*** The SessionStore Class

Finally, we wrap everything in a deftype. This compiles to a JavaScript class,
making it compatible with the patterns expected by the Matrix SDK and UI layers.
We use Object to implement the methods directly on the prototype.
#+begin_src clojurescript :tangle ../../src/client/session_store.cljs
(deftype SessionStore []
Object
(loadSessions [this]
(load-sessions-sync-impl))

(save [this session passphrase store-id]
(save-session-impl! session passphrase store-id))

(generatePassphrase [this]
(generate-passphrase))

(generateStoreId [this]
    (generate-uuid))

(getStoreName [this store-id]
(str "closura-store-" store-id))

(clear [this user-id]
;; Return a promise to the caller so they can await the cleanup
(clear-session-impl! user-id)))
#+end_src
