#+TITLE: Matrix Client Login

#+begin_src clojurescript :tangle ../../src/client/login.cljs
(ns client.login
  (:require
   [taoensso.timbre :as log]
   [client.view-models :refer [create-room-list-vm]]
   [reagent.core :as r]
   [promesa.core :as p]
   [re-frame.core :as re-frame]
   [client.state :refer [sdk-world mount-vm! unmount-vm!]]
   [client.session-store :refer [SessionStore]]
   [client.sdk-ctrl :as sdk-ctrl]
   [spaces.bar :refer [init-space-service!]]
   [room.room-list :as rl];;:refer [parse-room apply-diffs! create-room-update-listener setup-room-list-adapter!]]
   ["generated-compat" :as sdk :refer [RoomListEntriesDynamicFilterKind]]
   ["@element-hq/web-shared-components" :refer [RoomListView BaseViewModel]])
  (:require-macros [utils.macros :refer [ocall oget]]))
#+end_src

This serves as a ready check for the WASM (and our global sdk-world).
We can not start the application until the WASM has loaded.
In theory we could optimize around this by loading up components
in the background so it feels snappy though. No client behavior can be ran
though.
#+begin_src clojurescript :tangle ../../src/client/login.cljs
(defonce sdk-ready? (r/atom false))

(defn init-sdk! []
    (-> (p/let [_ (sdk/uniffiInitAsync)]
          (log/debug "WASM loaded")
          (reset! sdk-ready? true)
          (swap! sdk-world assoc :loading? false))
        (p/catch (fn [e]
                   (log/error "WASM Load Failed:" e)
                   (swap! sdk-world assoc :loading? false)))))
#+end_src


*** Starting the Client

This is more or less where we start our journey of actually interfacing with the
matrix-rust-sdk WASM bindings. Since the client initialization is relatively 'easy'
compared to actually making use of the information and state internally.
Obviously, looking to Aurora is a boon, but it will be a tad bit different as we
write this with ClojureScript in mind.


It seems that WASM needs camelCase after it is converted from Rust.
So entries_handle becomes entriesStream

We're currently just testing out the update triggering. We may wish to pull this logic out.
I would think writing mock systems from the start might allow for complex mocking later.


We started with view models but eventually moved towards more Clojure native
implementations that align better with reframe to make writing more idiomatic.
As such it becomes much simpler to initialize and manage the state.
Though this does mean we'll retroactively need to add methods to do certain
behaviors against the Rust sdk.

This generates a room-list-vm that utilizes the element-web-component as we intend.
This is a good spot to explore what the Rust FFI exposes to use in the client as well.
Such as the space_service is useful to avoid manaul calculation of the spaces vs rooms.
We can actually use it to get the rooms in a space for effortless filtering.
#+begin_src clojurescript :tangle ../../src/client/login.cljs
(defn start-sync! [client]
  (p/let [sync-service (-> (.syncService client) (.withOfflineMode) (.finish))
          rls-instance (.roomListService sync-service)
          room-list (.allRooms rls-instance)
          _ (rl/start-room-list-sync! room-list)
          _ (.start sync-service)
          _ (init-space-service! client)
          ]
      (log/debug "Sync started.")))
#+end_src



This actually was relatively quick to figure out, but the client builder merely takes
a few options. It is fairly dynamically configurable as is. Still, more time was spent
ensuring this could be used for both login and restore session.
So we allow nullish options in passphrase and store-id and if they're null
we generate them. If they are not null then we read from the value passed.
At the end of the process once the client object is 'built' we try to run the
login or restoreSession method depending on what is passed through to restore-or-login!
#+begin_src clojurescript :tangle ../../src/client/login.cljs
(defn build-client [hs passphrase? store-id? restore-or-login!]
  (-> (p/let [
              ;; Rust internal components
              sdk-root (if (.-ClientBuilder sdk) sdk (.-default sdk))
              ClientBuilder (.-ClientBuilder sdk-root)
              SSVBuilder    (.-SlidingSyncVersionBuilder sdk-root)
              IDBBuilder    (.-IndexedDbStoreBuilder sdk-root)
              ;;
              store (SessionStore.)
              store-id   (or store-id? (.generateStoreId store))
              passphrase (or passphrase? (.generatePassphrase store))
              store-name (.getStoreName store store-id)
              store-config (-> (new IDBBuilder store-name)
                              (.passphrase passphrase))
              builder (-> (new ClientBuilder)
                        (.serverNameOrHomeserverUrl hs)
                        (.indexeddbStore store-config)
                        (.autoEnableCrossSigning true)
                        (cond-> (nil? passphrase?)
                          (.slidingSyncVersionBuilder (.-DiscoverNative SSVBuilder))))
              client  (.build builder)
              _ (restore-or-login! client)
              session (.session client)
              _ (or passphrase? (.save store session passphrase store-id))
              ]
        client)
      (p/catch (fn [e]
                 (log/error  e)
                 (log/warn "Login failed, returning nil")
                 nil))))
#+end_src


The login just passes on the home-server and an anonymous function
that expects the client object to run .login with the user and pass.
Features like this will ensure we can keep the codebase small and efficient.
#+begin_src clojurescript :tangle ../../src/client/login.cljs
(defn login! [hs user pass]
   (p/let [client (build-client hs nil nil #(.login % user pass))]
           client))
#+end_src

This is mostly the same deal as login, but we check the store for
an existing session. The actual session object is rehydrated when grabbed from the store
into the expected Rust object. The stored JSON doesn't actually have homeserverUrl in it after all.
We then also pass an anonymous function here where we expect the built client to be the object which
will have the function ran against it with our session variable. It's a very fancy callback.
#+begin_src clojurescript :tangle ../../src/client/login.cljs
(defn restore-client! [session passphrase store-id]
  (p/let [client (build-client (.-homeserverUrl session) passphrase store-id #(.restoreSession % session))]
    client))
#+end_src


This did make me think on an elegant logging implementation. I wouldn't be surprised if there are some
very fancy logging macro libraries that require little code change.
This is a helper function that checks for and returns the local session if it exists.
The local session exists as a JS Object once retrieved that represents the Rust object.
#+begin_src clojurescript :tangle ../../src/client/login.cljs
(defn maybe-local-session []
  (p/let [store (SessionStore.)
          sessions (.loadSessions store)
          user-id (first (js/Object.keys sessions))]
    (or (aget sessions user-id) nil)))
#+end_src

Now we can provide our application initialization and attempt to restore the previous login session.
If the previous login session is found, then we start-syncing and kick off the client's run.
#+begin_src clojurescript :tangle ../../src/client/login.cljs
(defn bootstrap! [on-complete]
  (-> (p/let [_      (init-sdk!)
              data?  (maybe-local-session)
              client (when data?
                       (restore-client! (.-session data?)
                                        (.-passphrase data?)
                                        (.-storeId data?)))
              _ (log/debug data?)
              ]
        (on-complete client data?))
      (p/catch (fn [e]
                 (log/error "Bootstrap/Restore failed:" e)
                 (on-complete nil)))))
#+end_src

There is a bit to be desired in the actual interop. It is, of course, functional enough. We may wish
to search for a better solution for it though. I feel it could be more succinct.
