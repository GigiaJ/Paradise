#+begin_src clojurescript :tangle ../../src/client/ui.cljs
(ns client.ui
  (:require [reagent.core :as r]
            [client.timeline :as timeline]
            [taoensso.timbre :as log]
            [clojure.string :as str]
            [client.state :as state :refer [sdk-world]]
            ["@element-hq/web-shared-components" :refer [RoomListView]])
  (:require-macros [utils.macros :refer [ocall oget]]))
#+end_src

;; We let Vite replace the process.env later for the home server
On initial testing before we store the actual login session, this is more or less
required to move forward. Of course, it'll prove useful later too with a full client
implementation.
#+begin_src clojurescript :tangle ../../src/client/ui.cljs
(defn login-screen [on-login-trigger]
  (let [fields (r/atom {:hs (or js/process.env.MATRIX_HOMESERVER "") :user "" :pass ""})]
    (fn [on-login-trigger]
      [:div.login-container.flex.flex-col.items-center.justify-center.h-screen.bg-gray-900
       [:h2.text-white.mb-4 "Paradise Login"]
       [:input.mb-2.p-2.rounded.bg-gray-700.text-white
        {:type "text" :placeholder "Homeserver" :value (:hs @fields)
         :on-change #(swap! fields assoc :hs (.. % -target -value))}]
       [:input.mb-2.p-2.rounded.bg-gray-700.text-white
        {:type "text" :placeholder "Username"
         :on-change #(swap! fields assoc :user (.. % -target -value))}]
       [:input.mb-2.p-2.rounded.bg-gray-700.text-white
        {:type "password" :placeholder "Password"
         :on-change #(swap! fields assoc :pass (.. % -target -value))}]
       [:button.p-2.rounded.bg-blue-600.text-white.hover:bg-blue-500
        {:on-click (fn [e]
                     (.preventDefault e)
                     (on-login-trigger (:hs @fields) (:user @fields) (:pass @fields)))}
        "Login"]])))
#+end_src

;; Currently a filler block until we finish handling the room view model.
#+begin_src clojurescript
(defn room-list-view [rooms selected-room-atom on-room-click]
  [:div.w-64.bg-gray-800.border-r.border-gray-700.overflow-y-auto
   [:h2.p-4.font-bold.border-b.border-gray-700 "Rooms"]
   (doall
    (for [room rooms]
      (let [rid (.-roomId ^js room)
            rname (.-name ^js room)]
        [:div.p-3.cursor-pointer.hover:bg-gray-700
         {:key rid
          :class (when (= @selected-room-atom room) "bg-gray-700")
          :on-click #(on-room-click room)}
         (or rname rid "Unnamed Room")])))])
#+end_src

So we need a stub component for BaseAvatar.
The top method is just to generate colors
The stub is just a quick little React component
and then the third is for rendering said Avatar stub (tsx)
#+begin_src clojurescript :tangle ../../src/client/ui.cljs
(defn string->color [s]
  (let [hash (reduce (fn [h c] (+ (int c) (bit-shift-left h 5) (- h))) 0 s)
        hue  (mod (Math/abs hash) 360)]
    (str "hsl(" hue ", 60%, 40%)")))


(defn base-avatar-stub
  [{:keys [idName name url size] :or {size "24px"}}]
  (let [initial (if (not-empty name) (str/upper-case (subs name 0 1)) "?")
        bg-color (string->color (or idName name "default"))]
    [:div {:className "avatar-frame"
           :style {:width size :height size :min-width size
                   :border-radius "50%" :background-color bg-color
                   :color "white" :display "flex"
                   :align-items "center" :justify-content "center"
                   :font-size "12px" :overflow "hidden"
                   :pointer-events "none"}}
     (if url
       [:img {:src url :style {:width "100%" :height "100%" :object-fit "cover"}}]
       initial)]))

(defn render-avatar [room-info]
  (r/as-element
   [base-avatar-stub {:idName (.-id room-info)
                      :name   (.-name room-info)
                      :url    (.-avatar room-info)
                      :size   "24px"}]))
#+end_src


#+begin_src clojurescript :tangle ../../src/client/ui.cljs
(defn element-room-list-view [vm]
  (if vm
    [:> RoomListView {:vm vm
                      :renderAvatar render-avatar}]
    [:div "Room list initializing..."]))
#+end_src


#+begin_src clojurescript
(defn room-list-view-man []
  (let [rooms (get-in @sdk-world [:vms :room-list :rooms] [])]
    [:div.room-list {:style {:display "flex"
                             :flex-direction "column"
                             :gap "8px"
                             :padding "16px"
                             :max-width "400px"
                             :background "#f4f4f5"}}
     [:h3 {:style {:margin "0 0 16px 0"}} (str "Rooms (" (count rooms) ")")]
     (for [room rooms]
       ^{:key (:id room)}
       [:div.room-row {:style {:display "flex"
                               :align-items "center"
                               :gap "12px"
                               :padding "8px"
                               :background "white"
                               :border-radius "8px"
                               :cursor "pointer"
                               :box-shadow "0 1px 3px rgba(0,0,0,0.1)"}
                       :on-click #(log/debug "Clicked room:" (:id room))}
        [base-avatar-stub {:idName (:id room)
                           :name (:name room)
                           :url (:avatar room)
                           :size "40px"}]
        [:div {:style {:display "flex" :flex-direction "column"}}
         [:span {:style {:font-weight "600" :font-size "14px" :color "#1a1a1a"}}
          (:name room)]
         [:span {:style {:font-size "12px" :color "#666"}}
          (subs (:id room) 0 (min 15 (count (:id room))))]]])]))
#+end_src

Currently just a filler block to render rooms. Not entirely functional yet.
#+begin_src clojurescript :tangle ../../src/client/ui.cljs
(defn room-view [selected-room]
  [:div.flex-1.flex.flex-col.bg-gray-900
   (if-let [room selected-room]
     [:<>
      [:div.p-4.bg-gray-800.border-b.border-gray-700
       [:h2.text-xl.font-bold (or (.-name ^js room) "Room")]]
      [timeline/timeline-view]]
     [:div.flex-1.flex.items-center.justify-center.text-gray-500
      "Select a room to start chatting"])])
#+end_src







