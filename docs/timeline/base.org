
Obviously a Matrix client needs a timeline. For now we'll scaffold out a design similar to the other components
we've made interop with the WASM bindings.

#+begin_src clojurescript :tangle ../../src/timeline/base.cljs
(ns timeline.base
  (:require [promesa.core :as p]
            [re-frame.core :as re-frame]
            [taoensso.timbre :as log]
            [re-frame.db :as db]
            ["react-virtuoso" :refer [Virtuoso]]
            [reagent.core :as r]
            [reagent.dom.client :as rdom]
            [utils.helpers :refer [mxc->url]]
            [input.base :refer [message-input]]
            [room.room-summary :refer [build-room-summary]]
            [client.diff-handler :refer [apply-matrix-diffs]]))
#+end_src

So this isn't dissimilar to room-summary... Effectively we're pulling
the Rust object a part and creating a Clojure map from it.
I did this mainly to make it easier to debug, but it'll also
help anyone later who wants to make changes to aspects of the timeline.
#+begin_src clojurescript :tangle ../../src/timeline/base.cljs
(defn reify-item [ffi-item]
  (let [raw-id (.uniqueId ffi-item)
        id-str (if raw-id (or (.-id raw-id) raw-id) (str "virt-" (hash ffi-item)))
        event (.asEvent ffi-item)
        virtual (.asVirtual ffi-item)]
    (cond
      event
      (let [sender-profile (.-senderProfile event)
            inner-profile  (when sender-profile (.-inner sender-profile))
            sender         (or (when inner-profile (.-displayName inner-profile))
                               (.-sender event))
            content        (.-content event)
            content-tag    (.-tag content)
            content-inner  (.-inner content)
            reactions (try
                        (let [raw-rx (.reactions ffi-item)]
                          (into {} (for [k (js/Object.keys raw-rx)]
                                     [k (.-count (get raw-rx k))])))
                        (catch :default _ {}))
            read-by (try
                      (mapv #(.-sender %) (.readReceipts ffi-item))
                      (catch :default _ []))]

        {:id          id-str
         :type        :event
         :sender      sender
         :ts          (js/Number (.-timestamp event))
         :reactions    reactions
         :read-by      read-by
         :content-tag content-tag
         :content     (case content-tag
                        "MsgLike"
                        (let [msg (.-content content-inner)
                              kind (.-kind msg)
                              kind-tag (.-tag kind)
                              kind-inner (.-inner kind)]
                          {:tag kind-tag
                           :inner (case kind-tag
                                    "Message"
                                    (let [actual (.-content kind-inner)
                                          m-type (.-msgType actual)
                                          m-tag  (.-tag m-type)
                                          m-inner (.-inner m-type)
                                          m-content-obj (.-content m-inner)]
                                      {:tag   m-tag
                                       :content (case m-tag
                                                  ("Text" "Emote" "Notice") {:body (.-body m-content-obj)}
                                                  ("Image" "Video" "Sticker") {:source (.-source m-content-obj)
                                                                               :info   (when-let [info (.-info m-content-obj)]
                                                                                         {:w (some-> info .-width js/Number)
                                                                                          :h (some-> info .-height js/Number)
                                                                                          :mimetype (.-mimetype info)})}
                                                  {:unsupported true})})
                                    "Sticker"
                                    {:source (.-source kind-inner)
                                     :info (when-let [info (.-info kind-inner)]
                                             {:w (some-> info .-width js/Number)
                                              :h (some-> info .-height js/Number)})}
                                    nil)})
                        "RoomMembership" {:change (some-> content-inner .-change .-name)}
                        "ProfileChange"  {:id id-str}
                        nil)})

      virtual
      {:id   id-str
       :type :virtual
       :tag  (.-tag virtual)
       :ts   (some-> virtual .-inner .-ts js/Number)}

      :else
      {:id id-str :type :unknown})))
#+end_src

This is our diff trigger method. On a diff returned from the Rust SDK
It then takes the diff and tells reframe what to update the timeline
to now display. This could be just *adding* a single message or swapping
rooms.
#+begin_src clojurescript :tangle ../../src/timeline/base.cljs
(defn apply-timeline-diffs! [room-id updates]
  (let [current-events (get-in @re-frame.db/app-db [:timeline room-id] [])]
    (-> (apply-matrix-diffs current-events updates reify-item)
        (.then (fn [next-events]
                 (re-frame/dispatch [:sdk/update-timeline room-id next-events])))
        (.catch #(js/console.error "Timeline Diff Panic:" %)))))
#+end_src


This is a functional stub for now. I'll go back and split and describe
each of these later.
#+begin_src clojurescript :tangle ../../src/timeline/base.cljs
(re-frame/reg-event-db
 :sdk/update-timeline
 (fn [db [_ room-id events]]
   (assoc-in db [:timeline room-id] events)))

(re-frame/reg-event-fx
 :sdk/cleanup-timeline
 (fn [{:keys [db]} [_ room-id]]
   (when-let [subs (get-in db [:timeline-subs room-id])]
     (when-let [tl-handle (:tl-handle subs)]
       (.cancel tl-handle))
     (when-let [pag-handle (:pag-handle subs)]
       (.cancel pag-handle)))
   {:db (update db :timeline-subs dissoc room-id)}))

(re-frame/reg-event-db
 :sdk/update-pagination-status
 (fn [db [_ room-id status]]
   (assoc-in db [:timeline-pagination room-id] status)))


(re-frame/reg-event-fx
 :sdk/boot-timeline
 (fn [{:keys [db]} [_ room-id]]
   (let [client (:client db)]
     (when-let [room (.getRoom client room-id)]
       (-> (p/let [timeline (.timeline room)
                   listener #js {:onUpdate
                                 (fn [diffs]
                                   (apply-timeline-diffs! room-id diffs))}
                   timeline-handle (.addListener timeline listener)
                   pag-listener #js {:onUpdate
                                     (fn [status]
                                       (re-frame/dispatch [:sdk/update-pagination-status room-id status]))}
                   pag-handle (.subscribeToBackPaginationStatus timeline pag-listener)]
             (re-frame/dispatch [:sdk/save-timeline-sub room-id timeline timeline-handle pag-handle])
             (.paginateBackwards timeline 50))
           (.catch (fn [err]
                     (js/console.error err))))))
   {}))

(re-frame/reg-event-db
 :sdk/save-timeline-sub
 (fn [db [_ room-id timeline tl-handle pag-handle]]
   (assoc-in db [:timeline-subs room-id]
             {:timeline timeline
              :tl-handle tl-handle
              :pag-handle pag-handle})))

(re-frame/reg-sub
 :timeline/current-events
 (fn [db _]
   (let [active-room (:active-room-id db)]
     (get-in db [:timeline active-room] []))))

(re-frame/reg-event-fx
 :sdk/back-paginate
 (fn [{:keys [db]} [_ room-id]]
   (let [loading? (get-in db [:timeline/loading-more? room-id])
         status   (get-in db [:timeline-pagination room-id])]
     (if (and room-id
              (not loading?)
              (not= status "Paginating")
              (not= status "TimelineStartReached"))
       (when-let [timeline (get-in db [:timeline-subs room-id :timeline])]
         (-> (.paginateBackwards timeline 50)
             (.then #(re-frame/dispatch [:sdk/pagination-complete room-id])))
         {:db (assoc-in db [:timeline/loading-more? room-id] true)})
       {}))))

(re-frame/reg-event-db
 :sdk/pagination-complete
 (fn [db [_ room-id]]
   (let [timeline-path [:timeline-pagination room-id]
         ]
     (-> db
         (assoc-in [:timeline/loading-more? room-id] false)
         ))))

(re-frame/reg-sub
 :timeline/loading-more?
 (fn [db [_ room-id]]
   (get-in db [:timeline/loading-more? room-id] false)))
#+end_src

#+begin_src clojurescript :tangle ../../src/timeline/base.cljs
(defn text-message [content]
  (let [body (.-body content)]
    [:span.body body]))
#+end_src

#+begin_src clojurescript :tangle ../../src/timeline/base.cljs
(defn async-media-wrapper [content {:keys [class default-ratio]} render-fn]
  (r/with-let [client       @(re-frame/subscribe [:sdk/client])
               media-source (:source content)
               info         (:info content)
               w            (:w info)
               h            (:h info)
               style        (if (and w h)
                              {:aspect-ratio (str w " / " h)}
                              {:aspect-ratio (str default-ratio)})
               !blob-url    (r/atom nil)
               _ (when (and client media-source)
                   (p/let [bytes (.getMediaContent client media-source)
                           blob  (js/Blob. #js [bytes] #js {:type (or (:mimetype info) "image/png")})
                           url   (js/URL.createObjectURL blob)]
                     (reset! !blob-url url)))]
    (let [url @!blob-url]
      [:div.media-container {:class class :style style}
       (if url
         (render-fn url (or (:caption content) (:filename content) "media") "media-content-absolute")
         [:div.message-image-placeholder
          [:div.spinner]])])
    (finally
      (when-let [url @!blob-url]
        (js/URL.revokeObjectURL url)))))
#+end_src

#+begin_src clojurescript :tangle ../../src/timeline/base.cljs
(defn image-message [content]
  (async-media-wrapper content {:class "media-image" :default-ratio 1.33}
    (fn [url alt class-name]
      [:img {:src url :alt alt :class class-name :loading "lazy"}])))
#+end_src


#+begin_src clojurescript :tangle ../../src/timeline/base.cljs
(defn video-message [content]
  (async-media-wrapper content {:class "media-video" :default-ratio 1.77}
    (fn [url _ class-name]
      [:video {:src url :controls true :class class-name}])))
#+end_src

#+begin_src clojurescript :tangle ../../src/timeline/base.cljs
(defn sticker-message [content]
  (async-media-wrapper content {:class "media-sticker" :default-ratio 1.0}
    (fn [url alt class-name]
      [:img {:src url :alt alt :class class-name :loading "lazy"}])))
#+end_src

#+begin_src clojurescript :tangle ../../src/timeline/base.cljs
(defn render-message-content [msg-type-tag content-map]
  (case msg-type-tag
    "Text"    [:span.body (:body content-map)]
    "Image"   [image-message content-map]
    "Video"   [video-message content-map]
    "Sticker" [sticker-message content-map]i
    [:span.body (str "Unsupported message type: " msg-type-tag)]))
#+end_src


This is a very, very sloppy event-tile for now. We can probably make this less
silly later, but it does good enough to actually render the message and the
individual's display name.
#+begin_src clojurescript :tangle ../../src/timeline/base.cljs
(defn system-event-view [icon text]
  [:div.timeline-system-event
   [:span.system-icon icon]
   [:span.system-text text]])

(defn event-tile [item]
  (let [{:keys [sender content-tag content type reactions read-by]} item]
    (if (= type :virtual)
      [system-event-view "-" "Timeline Separator"]
      [:div.event-tile-container
       (cond
         (= content-tag "MsgLike")
         (let [{:keys [tag inner]} content]
           (cond
             (= tag "Sticker")
             [:div.message
              [:span.sender sender]
              [render-message-content "Sticker" inner]]

             (= tag "Redacted")
             [system-event-view "[x]" (str sender " deleted a message.")]

             (= tag "UnableToDecrypt")
             [system-event-view "[?]" (str "Unable to decrypt message from " sender)]

             (= tag "Message")
             (let [{m-tag :tag m-content :content} inner]
               [:div.message
                [:span.sender sender]
                [render-message-content m-tag m-content]])

             :else
             [system-event-view "[!]" (str "Unknown message kind: " tag)]))

         (= content-tag "RoomMembership")
         [system-event-view "->" (str sender " membership changed.")]

         (= content-tag "ProfileChange")
         [system-event-view "@" (str sender " changed their profile.")]

         :else
         [system-event-view "[!]" (str "Unknown event type: " content-tag)])

       (when (or (seq reactions) (seq read-by))
         [:div.event-metadata
          (when (seq reactions)
            [:div.reactions-row
             (for [[emoji count] reactions]
               ^{:key emoji} [:span.reaction-pill (str emoji " " count)])])
          (when (seq read-by)
            [:div.read-receipts-row
             [:span.receipt-count (str "âœ“ " (count read-by))]])])])))

#+end_src

Similar to Spaces and RoomLists we do a Virtuoso component here.
We ensure the array that will compose its table of individual elements
is a JS array and then we move on with defining the actual
behavior for the timeline.
** TODO Timeline is currently not performant for a few reasons
We need to button up this better, as this was the most recently added thing
from the enter refactoring of the "application view"

The table itself asks reframe to trigger the back pagination when the "start"
is reached. This should probably also have a somewhat automatic trigger until
size is reached, but the behavior may be impacted by the performant issue
mentioned above. Should be easily sorted, however.
#+begin_src clojurescript :tangle ../../src/timeline/base.cljs


(defn virtualized-timeline [events room-id]
  (r/with-let [!anchor-id (r/atom nil)
               !last-stable-idx (r/atom 10000)]
    (let [event-array (to-array events)
          get-id (fn [item] (:id item))
          _ (when (and (nil? @!anchor-id) (pos? (count event-array)))
              (let [id (get-id (first event-array))]
                (when (string? id)
                  (reset! !anchor-id id))))
          current-anchor @!anchor-id
          found-index (when current-anchor
                        (let [idx (.findIndex event-array #(= (get-id %) current-anchor))]
                          (if (>= idx 0) idx nil)))
          first-index (if found-index
                        (let [new-idx (- 10000 found-index)]
                          (reset! !last-stable-idx new-idx)
                          new-idx)
                        @!last-stable-idx)]
      [:> Virtuoso
       {:key room-id
        :data event-array
        :firstItemIndex first-index
        :alignToBottom true
        :followOutput (fn [at-bottom] (if at-bottom "smooth" false))
        :startReached #(re-frame/dispatch [:sdk/back-paginate room-id])
        :computeItemKey (fn [index item] (:id item))
        :itemContent (fn [index item]
                       (r/as-element
                        [:li.timeline-item {:key (:id item)}
                         [event-tile item]]))}])))
#+end_src


The timeline component itself. It subscribes to the active room id
and the active room's metadata. This way we can easily and effortless
update the timeline via reframe being told when the Rust SDK has
received an update.
#+begin_src clojurescript :tangle ../../src/timeline/base.cljs
(defn timeline []
  (let [active-id @(re-frame/subscribe [:rooms/active-id])
        room-meta @(re-frame/subscribe [:rooms/active-metadata])
        events    @(re-frame/subscribe [:timeline/current-events])]
    [:div.timeline-container
     (if-not active-id
       [:div.timeline-empty "Select a room to start chatting."]
       (let [display-name (or (.-name room-meta) active-id)]
         [:<>
          [:div.timeline-header
           [:h2.timeline-header-title display-name]]
          (let [loading? @(re-frame/subscribe [:timeline/loading-more? active-id])]
            [:div.timeline-messages
             (when loading?
               ^{:key "pagination-spinner"}
               [:div.spinner-container [:div.spinner]])
             ^{:key (str "virtuoso-wrapper-" active-id)}
             [virtualized-timeline events active-id]])
          [message-input]]))]))
#+end_src
