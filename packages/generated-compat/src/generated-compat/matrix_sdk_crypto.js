var _process;
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
import * as wasmBundle from "./wasm-bindgen/index.js";
import { AbstractFfiConverterByteArray, FfiConverterInt32, UniffiError, UniffiInternalError, UniffiRustCaller, uniffiCreateFfiConverterString, uniffiCreateRecord, uniffiTypeNameSymbol, variantOrdinalSymbol } from "uniffi-bindgen-react-native";
// Get converters from the other files, if any.
var nativeModule = function nativeModule() {
  return wasmBundle;
};
var uniffiCaller = new UniffiRustCaller(function () {
  return new wasmBundle.RustCallStatus();
});
var uniffiIsDebug =
// @ts-ignore -- The process global might not be defined
(typeof process === "undefined" ? "undefined" : _typeof(process)) !== "object" ||
// @ts-ignore -- The process global might not be defined
((_process = process) === null || _process === void 0 || (_process = _process.env) === null || _process === void 0 ? void 0 : _process.NODE_ENV) !== "production" || false;
/**
 * Generated factory for {@link DecryptionSettings} record objects.
 */
export var DecryptionSettings = function () {
  var _defaults = function defaults() {
    return {};
  };
  var create = function () {
    return uniffiCreateRecord(_defaults);
  }();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link DecryptionSettings}, with defaults specified
     * in Rust, in the {@link matrix_sdk_crypto} crate.
     */
    create: create,
    /**
     * Create a frozen instance of {@link DecryptionSettings}, with defaults specified
     * in Rust, in the {@link matrix_sdk_crypto} crate.
     */
    "new": create,
    /**
     * Defaults specified in the {@link matrix_sdk_crypto} crate.
     */
    defaults: function defaults() {
      return Object.freeze(_defaults());
    }
  });
}();
var FfiConverterTypeDecryptionSettings = function () {
  var FFIConverter = /*#__PURE__*/function (_AbstractFfiConverter) {
    function FFIConverter() {
      _classCallCheck(this, FFIConverter);
      return _callSuper(this, FFIConverter, arguments);
    }
    _inherits(FFIConverter, _AbstractFfiConverter);
    return _createClass(FFIConverter, [{
      key: "read",
      value: function read(from) {
        return {
          senderDeviceTrustRequirement: FfiConverterTypeTrustRequirement.read(from)
        };
      }
    }, {
      key: "write",
      value: function write(value, into) {
        FfiConverterTypeTrustRequirement.write(value.senderDeviceTrustRequirement, into);
      }
    }, {
      key: "allocationSize",
      value: function allocationSize(value) {
        return FfiConverterTypeTrustRequirement.allocationSize(value.senderDeviceTrustRequirement);
      }
    }]);
  }(AbstractFfiConverterByteArray);
  ;
  return new FFIConverter();
}();
var stringConverter = function () {
  var encoder = new TextEncoder();
  var decoder = new TextDecoder();
  return {
    stringToBytes: function stringToBytes(s) {
      return encoder.encode(s);
    },
    bytesToString: function bytesToString(ab) {
      return decoder.decode(ab);
    },
    stringByteLength: function stringByteLength(s) {
      return encoder.encode(s).byteLength;
    }
  };
}();
var FfiConverterString = uniffiCreateFfiConverterString(stringConverter);
/**
 * Strategy to collect the devices that should receive room keys for the
 * current discussion.
 */
export var CollectStrategy;
(function (CollectStrategy) {
  /**
   * Share with all (unblacklisted) devices.
   */
  CollectStrategy[CollectStrategy["AllDevices"] = 0] = "AllDevices";
  /**
   * Share with all devices, except errors for *verified* users cause sharing
   * to fail with an error.
   *
   * In this strategy, if a verified user has an unsigned device,
   * key sharing will fail with a
   * [`SessionRecipientCollectionError::VerifiedUserHasUnsignedDevice`].
   * If a verified user has replaced their identity, key
   * sharing will fail with a
   * [`SessionRecipientCollectionError::VerifiedUserChangedIdentity`].
   *
   * Otherwise, keys are shared with unsigned devices as normal.
   *
   * Once the problematic devices are blacklisted or whitelisted the
   * caller can retry to share a second time.
   */
  CollectStrategy[CollectStrategy["ErrorOnVerifiedUserProblem"] = 1] = "ErrorOnVerifiedUserProblem";
  /**
   * Share based on identity. Only distribute to devices signed by their
   * owner. If a user has no published identity he will not receive
   * any room keys.
   */
  CollectStrategy[CollectStrategy["IdentityBasedStrategy"] = 2] = "IdentityBasedStrategy";
  /**
   * Only share keys with devices that we "trust". A device is trusted if any
   * of the following is true:
   * - It was manually marked as trusted.
   * - It was marked as verified via interactive verification.
   * - It is signed by its owner identity, and this identity has been
   * trusted via interactive verification.
   * - It is the current own device of the user.
   */
  CollectStrategy[CollectStrategy["OnlyTrustedDevices"] = 3] = "OnlyTrustedDevices";
})(CollectStrategy || (CollectStrategy = {}));
var FfiConverterTypeCollectStrategy = function () {
  var ordinalConverter = FfiConverterInt32;
  var FFIConverter = /*#__PURE__*/function (_AbstractFfiConverter2) {
    function FFIConverter() {
      _classCallCheck(this, FFIConverter);
      return _callSuper(this, FFIConverter, arguments);
    }
    _inherits(FFIConverter, _AbstractFfiConverter2);
    return _createClass(FFIConverter, [{
      key: "read",
      value: function read(from) {
        switch (ordinalConverter.read(from)) {
          case 1:
            return CollectStrategy.AllDevices;
          case 2:
            return CollectStrategy.ErrorOnVerifiedUserProblem;
          case 3:
            return CollectStrategy.IdentityBasedStrategy;
          case 4:
            return CollectStrategy.OnlyTrustedDevices;
          default:
            throw new UniffiInternalError.UnexpectedEnumCase();
        }
      }
    }, {
      key: "write",
      value: function write(value, into) {
        switch (value) {
          case CollectStrategy.AllDevices:
            return ordinalConverter.write(1, into);
          case CollectStrategy.ErrorOnVerifiedUserProblem:
            return ordinalConverter.write(2, into);
          case CollectStrategy.IdentityBasedStrategy:
            return ordinalConverter.write(3, into);
          case CollectStrategy.OnlyTrustedDevices:
            return ordinalConverter.write(4, into);
        }
      }
    }, {
      key: "allocationSize",
      value: function allocationSize(value) {
        return ordinalConverter.allocationSize(0);
      }
    }]);
  }(AbstractFfiConverterByteArray);
  return new FFIConverter();
}();
/**
 * The state of an identity - verified, pinned etc.
 */
export var IdentityState;
(function (IdentityState) {
  /**
   * The user is verified with us
   */
  IdentityState[IdentityState["Verified"] = 0] = "Verified";
  /**
   * Either this is the first identity we have seen for this user, or the
   * user has acknowledged a change of identity explicitly e.g. by
   * clicking OK on a notification.
   */
  IdentityState[IdentityState["Pinned"] = 1] = "Pinned";
  /**
   * The user's identity has changed since it was pinned. The user should be
   * notified about this and given the opportunity to acknowledge the
   * change, which will make the new identity pinned.
   * When the user acknowledges the change, the app should call
   * [`crate::OtherUserIdentity::pin_current_master_key`].
   */
  IdentityState[IdentityState["PinViolation"] = 2] = "PinViolation";
  /**
   * The user's identity has changed, and before that it was verified. This
   * is a serious problem. The user can either verify again to make this
   * identity verified, or withdraw verification
   * [`UserIdentity::withdraw_verification`] to make it pinned.
   */
  IdentityState[IdentityState["VerificationViolation"] = 3] = "VerificationViolation";
})(IdentityState || (IdentityState = {}));
var FfiConverterTypeIdentityState = function () {
  var ordinalConverter = FfiConverterInt32;
  var FFIConverter = /*#__PURE__*/function (_AbstractFfiConverter3) {
    function FFIConverter() {
      _classCallCheck(this, FFIConverter);
      return _callSuper(this, FFIConverter, arguments);
    }
    _inherits(FFIConverter, _AbstractFfiConverter3);
    return _createClass(FFIConverter, [{
      key: "read",
      value: function read(from) {
        switch (ordinalConverter.read(from)) {
          case 1:
            return IdentityState.Verified;
          case 2:
            return IdentityState.Pinned;
          case 3:
            return IdentityState.PinViolation;
          case 4:
            return IdentityState.VerificationViolation;
          default:
            throw new UniffiInternalError.UnexpectedEnumCase();
        }
      }
    }, {
      key: "write",
      value: function write(value, into) {
        switch (value) {
          case IdentityState.Verified:
            return ordinalConverter.write(1, into);
          case IdentityState.Pinned:
            return ordinalConverter.write(2, into);
          case IdentityState.PinViolation:
            return ordinalConverter.write(3, into);
          case IdentityState.VerificationViolation:
            return ordinalConverter.write(4, into);
        }
      }
    }, {
      key: "allocationSize",
      value: function allocationSize(value) {
        return ordinalConverter.allocationSize(0);
      }
    }]);
  }(AbstractFfiConverterByteArray);
  return new FFIConverter();
}();
/**
 * The local trust state of a device.
 */
export var LocalTrust;
(function (LocalTrust) {
  /**
   * The device has been verified and is trusted.
   */
  LocalTrust[LocalTrust["Verified"] = 0] = "Verified";
  /**
   * The device been blacklisted from communicating.
   */
  LocalTrust[LocalTrust["BlackListed"] = 1] = "BlackListed";
  /**
   * The trust state of the device is being ignored.
   */
  LocalTrust[LocalTrust["Ignored"] = 2] = "Ignored";
  /**
   * The trust state is unset.
   */
  LocalTrust[LocalTrust["Unset"] = 3] = "Unset";
})(LocalTrust || (LocalTrust = {}));
var FfiConverterTypeLocalTrust = function () {
  var ordinalConverter = FfiConverterInt32;
  var FFIConverter = /*#__PURE__*/function (_AbstractFfiConverter4) {
    function FFIConverter() {
      _classCallCheck(this, FFIConverter);
      return _callSuper(this, FFIConverter, arguments);
    }
    _inherits(FFIConverter, _AbstractFfiConverter4);
    return _createClass(FFIConverter, [{
      key: "read",
      value: function read(from) {
        switch (ordinalConverter.read(from)) {
          case 1:
            return LocalTrust.Verified;
          case 2:
            return LocalTrust.BlackListed;
          case 3:
            return LocalTrust.Ignored;
          case 4:
            return LocalTrust.Unset;
          default:
            throw new UniffiInternalError.UnexpectedEnumCase();
        }
      }
    }, {
      key: "write",
      value: function write(value, into) {
        switch (value) {
          case LocalTrust.Verified:
            return ordinalConverter.write(1, into);
          case LocalTrust.BlackListed:
            return ordinalConverter.write(2, into);
          case LocalTrust.Ignored:
            return ordinalConverter.write(3, into);
          case LocalTrust.Unset:
            return ordinalConverter.write(4, into);
        }
      }
    }, {
      key: "allocationSize",
      value: function allocationSize(value) {
        return ordinalConverter.allocationSize(0);
      }
    }]);
  }(AbstractFfiConverterByteArray);
  return new FFIConverter();
}();
// Flat error type: LoginQrCodeDecodeError
export var LoginQrCodeDecodeError_Tags;
(function (LoginQrCodeDecodeError_Tags) {
  LoginQrCodeDecodeError_Tags["NotEnoughData"] = "NotEnoughData";
  LoginQrCodeDecodeError_Tags["NotUtf8"] = "NotUtf8";
  LoginQrCodeDecodeError_Tags["UrlParse"] = "UrlParse";
  LoginQrCodeDecodeError_Tags["InvalidMode"] = "InvalidMode";
  LoginQrCodeDecodeError_Tags["InvalidVersion"] = "InvalidVersion";
  LoginQrCodeDecodeError_Tags["Base64"] = "Base64";
  LoginQrCodeDecodeError_Tags["InvalidPrefix"] = "InvalidPrefix";
})(LoginQrCodeDecodeError_Tags || (LoginQrCodeDecodeError_Tags = {}));
/**
 * Error type for the decoding of the [`QrCodeData`].
 */
export var LoginQrCodeDecodeError = function () {
  /**
   * The QR code data is no long enough, it's missing some fields.
   */
  var NotEnoughData = /*#__PURE__*/function (_UniffiError) {
    function NotEnoughData(message) {
      var _this;
      _classCallCheck(this, NotEnoughData);
      _this = _callSuper(this, NotEnoughData, ["LoginQrCodeDecodeError", "NotEnoughData", message]);
      /**
       * @private
       * This field is private and should not be used.
       */
      _defineProperty(_this, uniffiTypeNameSymbol, "LoginQrCodeDecodeError");
      /**
       * @private
       * This field is private and should not be used.
       */
      _defineProperty(_this, variantOrdinalSymbol, 1);
      _defineProperty(_this, "tag", LoginQrCodeDecodeError_Tags.NotEnoughData);
      return _this;
    }
    _inherits(NotEnoughData, _UniffiError);
    return _createClass(NotEnoughData, null, [{
      key: "instanceOf",
      value: function instanceOf(e) {
        return _instanceOf(e) && e[variantOrdinalSymbol] === 1;
      }
    }]);
  }(UniffiError);
  /**
   * One of the URLs in the QR code data is not a valid UTF-8 encoded string.
   */
  var NotUtf8 = /*#__PURE__*/function (_UniffiError2) {
    function NotUtf8(message) {
      var _this2;
      _classCallCheck(this, NotUtf8);
      _this2 = _callSuper(this, NotUtf8, ["LoginQrCodeDecodeError", "NotUtf8", message]);
      /**
       * @private
       * This field is private and should not be used.
       */
      _defineProperty(_this2, uniffiTypeNameSymbol, "LoginQrCodeDecodeError");
      /**
       * @private
       * This field is private and should not be used.
       */
      _defineProperty(_this2, variantOrdinalSymbol, 2);
      _defineProperty(_this2, "tag", LoginQrCodeDecodeError_Tags.NotUtf8);
      return _this2;
    }
    _inherits(NotUtf8, _UniffiError2);
    return _createClass(NotUtf8, null, [{
      key: "instanceOf",
      value: function instanceOf(e) {
        return _instanceOf(e) && e[variantOrdinalSymbol] === 2;
      }
    }]);
  }(UniffiError);
  /**
   * One of the URLs in the QR code data could not be parsed.
   */
  var UrlParse = /*#__PURE__*/function (_UniffiError3) {
    function UrlParse(message) {
      var _this3;
      _classCallCheck(this, UrlParse);
      _this3 = _callSuper(this, UrlParse, ["LoginQrCodeDecodeError", "UrlParse", message]);
      /**
       * @private
       * This field is private and should not be used.
       */
      _defineProperty(_this3, uniffiTypeNameSymbol, "LoginQrCodeDecodeError");
      /**
       * @private
       * This field is private and should not be used.
       */
      _defineProperty(_this3, variantOrdinalSymbol, 3);
      _defineProperty(_this3, "tag", LoginQrCodeDecodeError_Tags.UrlParse);
      return _this3;
    }
    _inherits(UrlParse, _UniffiError3);
    return _createClass(UrlParse, null, [{
      key: "instanceOf",
      value: function instanceOf(e) {
        return _instanceOf(e) && e[variantOrdinalSymbol] === 3;
      }
    }]);
  }(UniffiError);
  /**
   * The QR code data contains an invalid mode, we expect the login (0x03)
   * mode or the reciprocate mode (0x04).
   */
  var InvalidMode = /*#__PURE__*/function (_UniffiError4) {
    function InvalidMode(message) {
      var _this4;
      _classCallCheck(this, InvalidMode);
      _this4 = _callSuper(this, InvalidMode, ["LoginQrCodeDecodeError", "InvalidMode", message]);
      /**
       * @private
       * This field is private and should not be used.
       */
      _defineProperty(_this4, uniffiTypeNameSymbol, "LoginQrCodeDecodeError");
      /**
       * @private
       * This field is private and should not be used.
       */
      _defineProperty(_this4, variantOrdinalSymbol, 4);
      _defineProperty(_this4, "tag", LoginQrCodeDecodeError_Tags.InvalidMode);
      return _this4;
    }
    _inherits(InvalidMode, _UniffiError4);
    return _createClass(InvalidMode, null, [{
      key: "instanceOf",
      value: function instanceOf(e) {
        return _instanceOf(e) && e[variantOrdinalSymbol] === 4;
      }
    }]);
  }(UniffiError);
  /**
   * The QR code data contains an unsupported version.
   */
  var InvalidVersion = /*#__PURE__*/function (_UniffiError5) {
    function InvalidVersion(message) {
      var _this5;
      _classCallCheck(this, InvalidVersion);
      _this5 = _callSuper(this, InvalidVersion, ["LoginQrCodeDecodeError", "InvalidVersion", message]);
      /**
       * @private
       * This field is private and should not be used.
       */
      _defineProperty(_this5, uniffiTypeNameSymbol, "LoginQrCodeDecodeError");
      /**
       * @private
       * This field is private and should not be used.
       */
      _defineProperty(_this5, variantOrdinalSymbol, 5);
      _defineProperty(_this5, "tag", LoginQrCodeDecodeError_Tags.InvalidVersion);
      return _this5;
    }
    _inherits(InvalidVersion, _UniffiError5);
    return _createClass(InvalidVersion, null, [{
      key: "instanceOf",
      value: function instanceOf(e) {
        return _instanceOf(e) && e[variantOrdinalSymbol] === 5;
      }
    }]);
  }(UniffiError);
  /**
   * The base64 encoded variant of the QR code data is not a valid base64
   * string.
   */
  var Base64 = /*#__PURE__*/function (_UniffiError6) {
    function Base64(message) {
      var _this6;
      _classCallCheck(this, Base64);
      _this6 = _callSuper(this, Base64, ["LoginQrCodeDecodeError", "Base64", message]);
      /**
       * @private
       * This field is private and should not be used.
       */
      _defineProperty(_this6, uniffiTypeNameSymbol, "LoginQrCodeDecodeError");
      /**
       * @private
       * This field is private and should not be used.
       */
      _defineProperty(_this6, variantOrdinalSymbol, 6);
      _defineProperty(_this6, "tag", LoginQrCodeDecodeError_Tags.Base64);
      return _this6;
    }
    _inherits(Base64, _UniffiError6);
    return _createClass(Base64, null, [{
      key: "instanceOf",
      value: function instanceOf(e) {
        return _instanceOf(e) && e[variantOrdinalSymbol] === 6;
      }
    }]);
  }(UniffiError);
  /**
   * The QR code data doesn't contain the expected `MATRIX` prefix.
   */
  var InvalidPrefix = /*#__PURE__*/function (_UniffiError7) {
    function InvalidPrefix(message) {
      var _this7;
      _classCallCheck(this, InvalidPrefix);
      _this7 = _callSuper(this, InvalidPrefix, ["LoginQrCodeDecodeError", "InvalidPrefix", message]);
      /**
       * @private
       * This field is private and should not be used.
       */
      _defineProperty(_this7, uniffiTypeNameSymbol, "LoginQrCodeDecodeError");
      /**
       * @private
       * This field is private and should not be used.
       */
      _defineProperty(_this7, variantOrdinalSymbol, 7);
      _defineProperty(_this7, "tag", LoginQrCodeDecodeError_Tags.InvalidPrefix);
      return _this7;
    }
    _inherits(InvalidPrefix, _UniffiError7);
    return _createClass(InvalidPrefix, null, [{
      key: "instanceOf",
      value: function instanceOf(e) {
        return _instanceOf(e) && e[variantOrdinalSymbol] === 7;
      }
    }]);
  }(UniffiError); // Utility function which does not rely on instanceof.
  function _instanceOf(e) {
    return e[uniffiTypeNameSymbol] === "LoginQrCodeDecodeError";
  }
  return {
    NotEnoughData: NotEnoughData,
    NotUtf8: NotUtf8,
    UrlParse: UrlParse,
    InvalidMode: InvalidMode,
    InvalidVersion: InvalidVersion,
    Base64: Base64,
    InvalidPrefix: InvalidPrefix,
    instanceOf: _instanceOf
  };
}();
var FfiConverterTypeLoginQrCodeDecodeError = function () {
  var intConverter = FfiConverterInt32;
  var FfiConverter = /*#__PURE__*/function (_AbstractFfiConverter5) {
    function FfiConverter() {
      _classCallCheck(this, FfiConverter);
      return _callSuper(this, FfiConverter, arguments);
    }
    _inherits(FfiConverter, _AbstractFfiConverter5);
    return _createClass(FfiConverter, [{
      key: "read",
      value: function read(from) {
        switch (intConverter.read(from)) {
          case 1:
            return new LoginQrCodeDecodeError.NotEnoughData(FfiConverterString.read(from));
          case 2:
            return new LoginQrCodeDecodeError.NotUtf8(FfiConverterString.read(from));
          case 3:
            return new LoginQrCodeDecodeError.UrlParse(FfiConverterString.read(from));
          case 4:
            return new LoginQrCodeDecodeError.InvalidMode(FfiConverterString.read(from));
          case 5:
            return new LoginQrCodeDecodeError.InvalidVersion(FfiConverterString.read(from));
          case 6:
            return new LoginQrCodeDecodeError.Base64(FfiConverterString.read(from));
          case 7:
            return new LoginQrCodeDecodeError.InvalidPrefix(FfiConverterString.read(from));
          default:
            throw new UniffiInternalError.UnexpectedEnumCase();
        }
      }
    }, {
      key: "write",
      value: function write(value, into) {
        var obj = value;
        var index = obj[variantOrdinalSymbol];
        intConverter.write(index, into);
      }
    }, {
      key: "allocationSize",
      value: function allocationSize(value) {
        return intConverter.allocationSize(0);
      }
    }]);
  }(AbstractFfiConverterByteArray);
  return new FfiConverter();
}();
/**
 * The result of a signature check.
 */
export var SignatureState;
(function (SignatureState) {
  /**
   * The signature is missing.
   */
  SignatureState[SignatureState["Missing"] = 0] = "Missing";
  /**
   * The signature is invalid.
   */
  SignatureState[SignatureState["Invalid"] = 1] = "Invalid";
  /**
   * The signature is valid but the device or user identity that created the
   * signature is not trusted.
   */
  SignatureState[SignatureState["ValidButNotTrusted"] = 2] = "ValidButNotTrusted";
  /**
   * The signature is valid and the device or user identity that created the
   * signature is trusted.
   */
  SignatureState[SignatureState["ValidAndTrusted"] = 3] = "ValidAndTrusted";
})(SignatureState || (SignatureState = {}));
var FfiConverterTypeSignatureState = function () {
  var ordinalConverter = FfiConverterInt32;
  var FFIConverter = /*#__PURE__*/function (_AbstractFfiConverter6) {
    function FFIConverter() {
      _classCallCheck(this, FFIConverter);
      return _callSuper(this, FFIConverter, arguments);
    }
    _inherits(FFIConverter, _AbstractFfiConverter6);
    return _createClass(FFIConverter, [{
      key: "read",
      value: function read(from) {
        switch (ordinalConverter.read(from)) {
          case 1:
            return SignatureState.Missing;
          case 2:
            return SignatureState.Invalid;
          case 3:
            return SignatureState.ValidButNotTrusted;
          case 4:
            return SignatureState.ValidAndTrusted;
          default:
            throw new UniffiInternalError.UnexpectedEnumCase();
        }
      }
    }, {
      key: "write",
      value: function write(value, into) {
        switch (value) {
          case SignatureState.Missing:
            return ordinalConverter.write(1, into);
          case SignatureState.Invalid:
            return ordinalConverter.write(2, into);
          case SignatureState.ValidButNotTrusted:
            return ordinalConverter.write(3, into);
          case SignatureState.ValidAndTrusted:
            return ordinalConverter.write(4, into);
        }
      }
    }, {
      key: "allocationSize",
      value: function allocationSize(value) {
        return ordinalConverter.allocationSize(0);
      }
    }]);
  }(AbstractFfiConverterByteArray);
  return new FFIConverter();
}();
/**
 * The trust level in the sender's device that is required to decrypt an
 * event.
 */
export var TrustRequirement;
(function (TrustRequirement) {
  /**
   * Decrypt events from everyone regardless of trust.
   */
  TrustRequirement[TrustRequirement["Untrusted"] = 0] = "Untrusted";
  /**
   * Only decrypt events from cross-signed devices or legacy sessions (Megolm
   * sessions created before we started collecting trust information).
   */
  TrustRequirement[TrustRequirement["CrossSignedOrLegacy"] = 1] = "CrossSignedOrLegacy";
  /**
   * Only decrypt events from cross-signed devices.
   */
  TrustRequirement[TrustRequirement["CrossSigned"] = 2] = "CrossSigned";
})(TrustRequirement || (TrustRequirement = {}));
var FfiConverterTypeTrustRequirement = function () {
  var ordinalConverter = FfiConverterInt32;
  var FFIConverter = /*#__PURE__*/function (_AbstractFfiConverter7) {
    function FFIConverter() {
      _classCallCheck(this, FFIConverter);
      return _callSuper(this, FFIConverter, arguments);
    }
    _inherits(FFIConverter, _AbstractFfiConverter7);
    return _createClass(FFIConverter, [{
      key: "read",
      value: function read(from) {
        switch (ordinalConverter.read(from)) {
          case 1:
            return TrustRequirement.Untrusted;
          case 2:
            return TrustRequirement.CrossSignedOrLegacy;
          case 3:
            return TrustRequirement.CrossSigned;
          default:
            throw new UniffiInternalError.UnexpectedEnumCase();
        }
      }
    }, {
      key: "write",
      value: function write(value, into) {
        switch (value) {
          case TrustRequirement.Untrusted:
            return ordinalConverter.write(1, into);
          case TrustRequirement.CrossSignedOrLegacy:
            return ordinalConverter.write(2, into);
          case TrustRequirement.CrossSigned:
            return ordinalConverter.write(3, into);
        }
      }
    }, {
      key: "allocationSize",
      value: function allocationSize(value) {
        return ordinalConverter.allocationSize(0);
      }
    }]);
  }(AbstractFfiConverterByteArray);
  return new FFIConverter();
}();
/**
 * Our best guess at the reason why an event can't be decrypted.
 */
export var UtdCause;
(function (UtdCause) {
  /**
   * We don't have an explanation for why this UTD happened - it is probably
   * a bug, or a network split between the two homeservers.
   *
   * For example:
   *
   * - the keys for this event are missing, but a key storage backup exists
   * and is working, so we should be able to find the keys in the backup.
   *
   * - the keys for this event are missing, and a key storage backup exists
   * on the server, but that backup is not working on this client even
   * though this device is verified.
   */
  UtdCause[UtdCause["Unknown"] = 0] = "Unknown";
  /**
   * We are missing the keys for this event, and the event was sent when we
   * were not a member of the room (or invited).
   */
  UtdCause[UtdCause["SentBeforeWeJoined"] = 1] = "SentBeforeWeJoined";
  /**
   * The message was sent by a user identity we have not verified, but the
   * user was previously verified.
   */
  UtdCause[UtdCause["VerificationViolation"] = 2] = "VerificationViolation";
  /**
   * The [`crate::TrustRequirement`] requires that the sending device be
   * signed by its owner, and it was not.
   */
  UtdCause[UtdCause["UnsignedDevice"] = 3] = "UnsignedDevice";
  /**
   * The [`crate::TrustRequirement`] requires that the sending device be
   * signed by its owner, and we were unable to securely find the device.
   *
   * This could be because the device has since been deleted, because we
   * haven't yet downloaded it from the server, or because the session
   * data was obtained from an insecure source (imported from a file,
   * obtained from a legacy (asymmetric) backup, unsafe key forward, etc.)
   */
  UtdCause[UtdCause["UnknownDevice"] = 4] = "UnknownDevice";
  /**
   * We are missing the keys for this event, but it is a "device-historical"
   * message and there is no key storage backup on the server, presumably
   * because the user has turned it off.
   *
   * Device-historical means that the message was sent before the current
   * device existed (but the current user was probably a member of the room
   * at the time the message was sent). Not to
   * be confused with pre-join or pre-invite messages (see
   * [`UtdCause::SentBeforeWeJoined`] for that).
   *
   * Expected message to user: "History is not available on this device".
   */
  UtdCause[UtdCause["HistoricalMessageAndBackupIsDisabled"] = 5] = "HistoricalMessageAndBackupIsDisabled";
  /**
   * The keys for this event are intentionally withheld.
   *
   * The sender has refused to share the key because our device does not meet
   * the sender's security requirements.
   */
  UtdCause[UtdCause["WithheldForUnverifiedOrInsecureDevice"] = 6] = "WithheldForUnverifiedOrInsecureDevice";
  /**
   * The keys for this event are missing, likely because the sender was
   * unable to share them (e.g., failure to establish an Olm 1:1
   * channel). Alternatively, the sender may have deliberately excluded
   * this device by cherry-picking and blocking it, in which case, no action
   * can be taken on our side.
   */
  UtdCause[UtdCause["WithheldBySender"] = 7] = "WithheldBySender";
  /**
   * We are missing the keys for this event, but it is a "device-historical"
   * message, and even though a key storage backup does exist, we can't use
   * it because our device is unverified.
   *
   * Device-historical means that the message was sent before the current
   * device existed (but the current user was probably a member of the room
   * at the time the message was sent). Not to
   * be confused with pre-join or pre-invite messages (see
   * [`UtdCause::SentBeforeWeJoined`] for that).
   *
   * Expected message to user: "You need to verify this device".
   */
  UtdCause[UtdCause["HistoricalMessageAndDeviceIsUnverified"] = 8] = "HistoricalMessageAndDeviceIsUnverified";
})(UtdCause || (UtdCause = {}));
var FfiConverterTypeUtdCause = function () {
  var ordinalConverter = FfiConverterInt32;
  var FFIConverter = /*#__PURE__*/function (_AbstractFfiConverter8) {
    function FFIConverter() {
      _classCallCheck(this, FFIConverter);
      return _callSuper(this, FFIConverter, arguments);
    }
    _inherits(FFIConverter, _AbstractFfiConverter8);
    return _createClass(FFIConverter, [{
      key: "read",
      value: function read(from) {
        switch (ordinalConverter.read(from)) {
          case 1:
            return UtdCause.Unknown;
          case 2:
            return UtdCause.SentBeforeWeJoined;
          case 3:
            return UtdCause.VerificationViolation;
          case 4:
            return UtdCause.UnsignedDevice;
          case 5:
            return UtdCause.UnknownDevice;
          case 6:
            return UtdCause.HistoricalMessageAndBackupIsDisabled;
          case 7:
            return UtdCause.WithheldForUnverifiedOrInsecureDevice;
          case 8:
            return UtdCause.WithheldBySender;
          case 9:
            return UtdCause.HistoricalMessageAndDeviceIsUnverified;
          default:
            throw new UniffiInternalError.UnexpectedEnumCase();
        }
      }
    }, {
      key: "write",
      value: function write(value, into) {
        switch (value) {
          case UtdCause.Unknown:
            return ordinalConverter.write(1, into);
          case UtdCause.SentBeforeWeJoined:
            return ordinalConverter.write(2, into);
          case UtdCause.VerificationViolation:
            return ordinalConverter.write(3, into);
          case UtdCause.UnsignedDevice:
            return ordinalConverter.write(4, into);
          case UtdCause.UnknownDevice:
            return ordinalConverter.write(5, into);
          case UtdCause.HistoricalMessageAndBackupIsDisabled:
            return ordinalConverter.write(6, into);
          case UtdCause.WithheldForUnverifiedOrInsecureDevice:
            return ordinalConverter.write(7, into);
          case UtdCause.WithheldBySender:
            return ordinalConverter.write(8, into);
          case UtdCause.HistoricalMessageAndDeviceIsUnverified:
            return ordinalConverter.write(9, into);
        }
      }
    }, {
      key: "allocationSize",
      value: function allocationSize(value) {
        return ordinalConverter.allocationSize(0);
      }
    }]);
  }(AbstractFfiConverterByteArray);
  return new FFIConverter();
}();
/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  var bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  var scaffoldingContractVersion = nativeModule().ubrn_ffi_matrix_sdk_crypto_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(scaffoldingContractVersion, bindingsContractVersion);
  }
}
export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeCollectStrategy: FfiConverterTypeCollectStrategy,
    FfiConverterTypeDecryptionSettings: FfiConverterTypeDecryptionSettings,
    FfiConverterTypeIdentityState: FfiConverterTypeIdentityState,
    FfiConverterTypeLocalTrust: FfiConverterTypeLocalTrust,
    FfiConverterTypeLoginQrCodeDecodeError: FfiConverterTypeLoginQrCodeDecodeError,
    FfiConverterTypeSignatureState: FfiConverterTypeSignatureState,
    FfiConverterTypeTrustRequirement: FfiConverterTypeTrustRequirement,
    FfiConverterTypeUtdCause: FfiConverterTypeUtdCause
  }
});