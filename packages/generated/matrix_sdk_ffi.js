// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
import * as wasmBundle from "./wasm-bindgen/index.js";
import { AbstractFfiConverterByteArray, FfiConverterArray, FfiConverterArrayBuffer, FfiConverterBool, FfiConverterCallback, FfiConverterDuration, FfiConverterFloat32, FfiConverterFloat64, FfiConverterInt32, FfiConverterInt64, FfiConverterMap, FfiConverterObject, FfiConverterOptional, FfiConverterUInt16, FfiConverterUInt32, FfiConverterUInt64, FfiConverterUInt8, UniffiAbstractObject, UniffiEnum, UniffiError, UniffiInternalError, UniffiResult, UniffiRustCaller, destructorGuardSymbol, pointerLiteralSymbol, uniffiCreateFfiConverterString, uniffiCreateRecord, uniffiRustCallAsync, uniffiTraitInterfaceCall, uniffiTraitInterfaceCallWithError, uniffiTypeNameSymbol, variantOrdinalSymbol } from "uniffi-bindgen-react-native";
// Get converters from the other files, if any.
import uniffiMatrixSdkModule from "./matrix_sdk";
import uniffiMatrixSdkBaseModule from "./matrix_sdk_base";
import uniffiMatrixSdkCommonModule from "./matrix_sdk_common";
import uniffiMatrixSdkCryptoModule from "./matrix_sdk_crypto";
import uniffiMatrixSdkUiModule from "./matrix_sdk_ui";
const { FfiConverterTypeBackupDownloadStrategy, FfiConverterTypeOAuthAuthorizationData, FfiConverterTypeRoomMemberRole, FfiConverterTypeRoomPaginationStatus, FfiConverterTypeRoomPowerLevelChanges, FfiConverterTypeServerVendorInfo, FfiConverterTypeVirtualElementCallWidgetConfig, FfiConverterTypeVirtualElementCallWidgetProperties, } = uniffiMatrixSdkModule.converters;
const { FfiConverterTypeEncryptionState, FfiConverterTypeMediaRetentionPolicy, } = uniffiMatrixSdkBaseModule.converters;
const { FfiConverterTypeShieldStateCode, } = uniffiMatrixSdkCommonModule.converters;
const { FfiConverterTypeCollectStrategy, FfiConverterTypeDecryptionSettings, FfiConverterTypeIdentityState, FfiConverterTypeUtdCause, } = uniffiMatrixSdkCryptoModule.converters;
const { FfiConverterTypeEventItemOrigin, FfiConverterTypeRoomPinnedEventsChange, FfiConverterTypeSpaceRoomListPaginationState, } = uniffiMatrixSdkUiModule.converters;
const nativeModule = () => wasmBundle;
const uniffiCaller = new UniffiRustCaller(() => new wasmBundle.RustCallStatus());
const uniffiIsDebug = 
// @ts-ignore -- The process global might not be defined
typeof process !== "object" ||
    // @ts-ignore -- The process global might not be defined
    process?.env?.NODE_ENV !== "production" ||
    false;
// Public interface members begin here.
/**
 * Creates a [`RoomMessageEventContentWithoutRelation`] given a
 * [`MessageContent`] value.
 */
export function contentWithoutRelationFromMessage(message) {
    return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(uniffiCaller.rustCallWithError(
    /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
    /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_content_without_relation_from_message(FfiConverterTypeMessageContent.lower(message), callStatus);
    }, 
    /*liftString:*/ FfiConverterString.lift));
}
/**
 * Create a caption edit.
 *
 * If no `formatted_caption` is provided, then it's assumed the `caption`
 * represents valid Markdown that can be used as the formatted caption.
 */
export function createCaptionEdit(caption, formattedCaption, mentions) {
    return FfiConverterTypeEditedContent.lift(uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_create_caption_edit(FfiConverterOptionalString.lower(caption), FfiConverterOptionalTypeFormattedBody.lower(formattedCaption), FfiConverterOptionalTypeMentions.lower(mentions), callStatus);
    }, 
    /*liftString:*/ FfiConverterString.lift));
}
export function genTransactionId() {
    return FfiConverterString.lift(uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_gen_transaction_id(callStatus);
    }, 
    /*liftString:*/ FfiConverterString.lift));
}
/**
 * Create the actual url that can be used to setup the WebView or IFrame
 * that contains the widget.
 *
 * # Arguments
 * * `widget_settings` - The widget settings to generate the url for.
 * * `room` - A Matrix room which is used to query the logged in username
 * * `props` - Properties from the client that can be used by a widget to adapt
 * to the client. e.g. language, font-scale...
 */
export async function generateWebviewUrl(widgetSettings, room, props, asyncOpts_) {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
        /*rustCaller:*/ uniffiCaller, 
        /*rustFutureFunc:*/ () => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_generate_webview_url(FfiConverterTypeWidgetSettings.lower(widgetSettings), FfiConverterTypeRoom.lower(room), FfiConverterTypeClientProperties.lower(props));
        }, 
        /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
        /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
        /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
        /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
        /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString), 
        /*liftString:*/ FfiConverterString.lift, 
        /*asyncOpts:*/ asyncOpts_, 
        /*errorHandler:*/ FfiConverterTypeParseError.lift.bind(FfiConverterTypeParseError));
    }
    catch (__error) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
}
/**
 * The Capabilities required to run a element call widget.
 *
 * This is intended to be used in combination with: `acquire_capabilities` of
 * the `CapabilitiesProvider`.
 *
 * `acquire_capabilities` can simply return the `WidgetCapabilities` from this
 * function. Even if there are non intersecting permissions to what the widget
 * requested.
 *
 * Editing and extending the capabilities from this function is also possible,
 * but should only be done as temporal workarounds until this function is
 * adjusted
 */
export function getElementCallRequiredPermissions(ownUserId, ownDeviceId) {
    return FfiConverterTypeWidgetCapabilities.lift(uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_get_element_call_required_permissions(FfiConverterString.lower(ownUserId), FfiConverterString.lower(ownDeviceId), callStatus);
    }, 
    /*liftString:*/ FfiConverterString.lift));
}
/**
 * Sets up logs and the tokio runtime for the current application.
 *
 * If `use_lightweight_tokio_runtime` is set to true, this will set up a
 * lightweight tokio runtime, for processes that have memory limitations (like
 * the NSE process on iOS). Otherwise, this can remain false, in which case a
 * multithreaded tokio runtime will be set up.
 */
export function initPlatform(config, useLightweightTokioRuntime) {
    uniffiCaller.rustCallWithError(
    /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
    /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_init_platform(FfiConverterTypeTracingConfiguration.lower(config), FfiConverterBool.lower(useLightweightTokioRuntime), callStatus);
    }, 
    /*liftString:*/ FfiConverterString.lift);
}
/**
 * Verifies the passed `String` matches the expected room alias format:
 *
 * This means it's lowercase, with no whitespace chars, has a single leading
 * `#` char and a single `:` separator between the local and domain parts, and
 * the local part only contains characters that can't be percent encoded.
 */
export function isRoomAliasFormatValid(alias) {
    return FfiConverterBool.lift(uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_is_room_alias_format_valid(FfiConverterString.lower(alias), callStatus);
    }, 
    /*liftString:*/ FfiConverterString.lift));
}
/**
 * Log an event.
 *
 * The target should be something like a module path, and can be referenced in
 * the filter string given to `init_platform`. `level` and `target` for a
 * callsite are fixed at the first `log_event` call for that callsite and can
 * not be changed afterwards, i.e. the level and target passed for second and
 * following `log_event`s with the same callsite will be ignored.
 *
 * This function leaks a little bit of memory for each unique (file + line +
 * level + target) it is called with. Please make sure that the number of
 * different combinations of those parameters this can be called with is
 * constant in the final executable.
 */
export function logEvent(file, line, level, target, message) {
    uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_log_event(FfiConverterString.lower(file), FfiConverterOptionalUInt32.lower(line), FfiConverterTypeLogLevel.lower(level), FfiConverterString.lower(target), FfiConverterString.lower(message), callStatus);
    }, 
    /*liftString:*/ FfiConverterString.lift);
}
export function makeWidgetDriver(settings) {
    return FfiConverterTypeWidgetDriverAndHandle.lift(uniffiCaller.rustCallWithError(
    /*liftError:*/ FfiConverterTypeParseError.lift.bind(FfiConverterTypeParseError), 
    /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_make_widget_driver(FfiConverterTypeWidgetSettings.lower(settings), callStatus);
    }, 
    /*liftString:*/ FfiConverterString.lift));
}
/**
 * Generates a `matrix.to` permalink to the given room alias.
 */
export function matrixToRoomAliasPermalink(roomAlias) {
    return FfiConverterString.lift(uniffiCaller.rustCallWithError(
    /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
    /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_matrix_to_room_alias_permalink(FfiConverterString.lower(roomAlias), callStatus);
    }, 
    /*liftString:*/ FfiConverterString.lift));
}
/**
 * Generates a `matrix.to` permalink to the given userID.
 */
export function matrixToUserPermalink(userId) {
    return FfiConverterString.lift(uniffiCaller.rustCallWithError(
    /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
    /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_matrix_to_user_permalink(FfiConverterString.lower(userId), callStatus);
    }, 
    /*liftString:*/ FfiConverterString.lift));
}
export function messageEventContentFromHtml(body, htmlBody) {
    return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_html(FfiConverterString.lower(body), FfiConverterString.lower(htmlBody), callStatus);
    }, 
    /*liftString:*/ FfiConverterString.lift));
}
export function messageEventContentFromHtmlAsEmote(body, htmlBody) {
    return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_html_as_emote(FfiConverterString.lower(body), FfiConverterString.lower(htmlBody), callStatus);
    }, 
    /*liftString:*/ FfiConverterString.lift));
}
export function messageEventContentFromMarkdown(md) {
    return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_markdown(FfiConverterString.lower(md), callStatus);
    }, 
    /*liftString:*/ FfiConverterString.lift));
}
export function messageEventContentFromMarkdownAsEmote(md) {
    return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_markdown_as_emote(FfiConverterString.lower(md), callStatus);
    }, 
    /*liftString:*/ FfiConverterString.lift));
}
export function messageEventContentNew(msgtype) {
    return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(uniffiCaller.rustCallWithError(
    /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
    /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_message_event_content_new(FfiConverterTypeMessageType.lower(msgtype), callStatus);
    }, 
    /*liftString:*/ FfiConverterString.lift));
}
/**
 * `WidgetSettings` are usually created from a state event.
 * (currently unimplemented)
 *
 * In some cases the client wants to create custom `WidgetSettings`
 * for specific rooms based on other conditions.
 * This function returns a `WidgetSettings` object which can be used
 * to setup a widget using `run_client_widget_api`
 * and to generate the correct url for the widget.
 *
 * # Arguments
 *
 * * `props` - A struct containing the configuration parameters for a element
 * call widget.
 */
export function newVirtualElementCallWidget(props, config) {
    return FfiConverterTypeWidgetSettings.lift(uniffiCaller.rustCallWithError(
    /*liftError:*/ FfiConverterTypeParseError.lift.bind(FfiConverterTypeParseError), 
    /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_new_virtual_element_call_widget(FfiConverterTypeVirtualElementCallWidgetProperties.lower(props), FfiConverterTypeVirtualElementCallWidgetConfig.lower(config), callStatus);
    }, 
    /*liftString:*/ FfiConverterString.lift));
}
/**
 * Parse a matrix entity from a given URI, be it either
 * a `matrix.to` link or a `matrix:` URI
 */
export function parseMatrixEntityFrom(uri) {
    return FfiConverterOptionalTypeMatrixEntity.lift(uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_parse_matrix_entity_from(FfiConverterString.lower(uri), callStatus);
    }, 
    /*liftString:*/ FfiConverterString.lift));
}
/**
 * Updates the tracing subscriber with a new file writer based on the provided
 * configuration.
 *
 * This method will throw if `init_platform` hasn't been called, or if it was
 * called with `write_to_files` set to `None`.
 */
export function reloadTracingFileWriter(configuration) {
    uniffiCaller.rustCallWithError(
    /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
    /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_reload_tracing_file_writer(FfiConverterTypeTracingFileConfiguration.lower(configuration), callStatus);
    }, 
    /*liftString:*/ FfiConverterString.lift);
}
/**
 * Transforms a Room's display name into a valid room alias name.
 */
export function roomAliasNameFromRoomDisplayName(roomName) {
    return FfiConverterString.lift(uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_room_alias_name_from_room_display_name(FfiConverterString.lower(roomName), callStatus);
    }, 
    /*liftString:*/ FfiConverterString.lift));
}
export function sdkGitSha() {
    return FfiConverterString.lift(uniffiCaller.rustCall(
    /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_sdk_git_sha(callStatus);
    }, 
    /*liftString:*/ FfiConverterString.lift));
}
/**
 * Get the suggested power level for the given role.
 *
 * Returns an error if the value of the power level is unsupported.
 */
export function suggestedPowerLevelForRole(role) {
    return FfiConverterTypePowerLevel.lift(uniffiCaller.rustCallWithError(
    /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
    /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_suggested_power_level_for_role(FfiConverterTypeRoomMemberRole.lower(role), callStatus);
    }, 
    /*liftString:*/ FfiConverterString.lift));
}
/**
 * Get the suggested role for the given power level.
 *
 * Returns an error if the value of the power level is out of range for numbers
 * accepted in canonical JSON.
 */
export function suggestedRoleForPowerLevel(powerLevel) {
    return FfiConverterTypeRoomMemberRole.lift(uniffiCaller.rustCallWithError(
    /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
    /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_func_suggested_role_for_power_level(FfiConverterTypePowerLevel.lower(powerLevel), callStatus);
    }, 
    /*liftString:*/ FfiConverterString.lift));
}
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceAccountDataListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onChange: (uniffiHandle, event) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeAccountDataListener.lift(uniffiHandle);
                return jsCallback.onChange(FfiConverterTypeAccountDataEvent.lift(event));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // AccountDataListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeAccountDataListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_accountdatalistener(uniffiCallbackInterfaceAccountDataListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeAccountDataListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceBackupStateListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (uniffiHandle, status) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeBackupStateListener.lift(uniffiHandle);
                return jsCallback.onUpdate(FfiConverterTypeBackupState.lift(status));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // BackupStateListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeBackupStateListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_backupstatelistener(uniffiCallbackInterfaceBackupStateListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeBackupStateListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceBackupSteadyStateListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (uniffiHandle, status) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeBackupSteadyStateListener.lift(uniffiHandle);
                return jsCallback.onUpdate(FfiConverterTypeBackupUploadState.lift(status));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // BackupSteadyStateListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeBackupSteadyStateListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_backupsteadystatelistener(uniffiCallbackInterfaceBackupSteadyStateListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeBackupSteadyStateListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceCallDeclineListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        call: (uniffiHandle, declinerUserId) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeCallDeclineListener.lift(uniffiHandle);
                return jsCallback.call(FfiConverterString.lift(declinerUserId));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // CallDeclineListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeCallDeclineListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_calldeclinelistener(uniffiCallbackInterfaceCallDeclineListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeCallDeclineListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceClientDelegate = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        didReceiveAuthError: (uniffiHandle, isSoftLogout) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeClientDelegate.lift(uniffiHandle);
                return jsCallback.didReceiveAuthError(FfiConverterBool.lift(isSoftLogout));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // ClientDelegate: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeClientDelegate.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_clientdelegate(uniffiCallbackInterfaceClientDelegate.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeClientDelegate = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceClientSessionDelegate = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        retrieveSessionFromKeychain: (uniffiHandle, userId) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeClientSessionDelegate.lift(uniffiHandle);
                return jsCallback.retrieveSessionFromKeychain(FfiConverterString.lift(userId));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => {
                UniffiResult.writeSuccess(uniffiResult, FfiConverterTypeSession.lower(obj));
            };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCallWithError(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*isErrorType:*/ ClientError.instanceOf, 
            /*lowerError:*/ FfiConverterTypeClientError.lower.bind(FfiConverterTypeClientError), 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        saveSessionInKeychain: (uniffiHandle, session) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeClientSessionDelegate.lift(uniffiHandle);
                return jsCallback.saveSessionInKeychain(FfiConverterTypeSession.lift(session));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // ClientSessionDelegate: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeClientSessionDelegate.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_clientsessiondelegate(uniffiCallbackInterfaceClientSessionDelegate.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeClientSessionDelegate = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceEnableRecoveryProgressListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (uniffiHandle, status) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeEnableRecoveryProgressListener.lift(uniffiHandle);
                return jsCallback.onUpdate(FfiConverterTypeEnableRecoveryProgress.lift(status));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // EnableRecoveryProgressListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeEnableRecoveryProgressListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_enablerecoveryprogresslistener(uniffiCallbackInterfaceEnableRecoveryProgressListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeEnableRecoveryProgressListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceGeneratedQrLoginProgressListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (uniffiHandle, state) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeGeneratedQrLoginProgressListener.lift(uniffiHandle);
                return jsCallback.onUpdate(FfiConverterTypeGeneratedQrLoginProgress.lift(state));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // GeneratedQrLoginProgressListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeGeneratedQrLoginProgressListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_generatedqrloginprogresslistener(uniffiCallbackInterfaceGeneratedQrLoginProgressListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeGeneratedQrLoginProgressListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceGrantGeneratedQrLoginProgressListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (uniffiHandle, state) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeGrantGeneratedQrLoginProgressListener.lift(uniffiHandle);
                return jsCallback.onUpdate(FfiConverterTypeGrantGeneratedQrLoginProgress.lift(state));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // GrantGeneratedQrLoginProgressListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeGrantGeneratedQrLoginProgressListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_grantgeneratedqrloginprogresslistener(uniffiCallbackInterfaceGrantGeneratedQrLoginProgressListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeGrantGeneratedQrLoginProgressListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceGrantQrLoginProgressListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (uniffiHandle, state) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeGrantQrLoginProgressListener.lift(uniffiHandle);
                return jsCallback.onUpdate(FfiConverterTypeGrantQrLoginProgress.lift(state));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // GrantQrLoginProgressListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeGrantQrLoginProgressListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_grantqrloginprogresslistener(uniffiCallbackInterfaceGrantQrLoginProgressListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeGrantQrLoginProgressListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceIdentityStatusChangeListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        call: (uniffiHandle, identityStatusChange) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeIdentityStatusChangeListener.lift(uniffiHandle);
                return jsCallback.call(FfiConverterArrayTypeIdentityStatusChange.lift(identityStatusChange));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // IdentityStatusChangeListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeIdentityStatusChangeListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_identitystatuschangelistener(uniffiCallbackInterfaceIdentityStatusChangeListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeIdentityStatusChangeListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceIgnoredUsersListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        call: (uniffiHandle, ignoredUserIds) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeIgnoredUsersListener.lift(uniffiHandle);
                return jsCallback.call(FfiConverterArrayString.lift(ignoredUserIds));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // IgnoredUsersListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeIgnoredUsersListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_ignoreduserslistener(uniffiCallbackInterfaceIgnoredUsersListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeIgnoredUsersListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceKnockRequestsListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        call: (uniffiHandle, joinRequests) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeKnockRequestsListener.lift(uniffiHandle);
                return jsCallback.call(FfiConverterArrayTypeKnockRequest.lift(joinRequests));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // KnockRequestsListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeKnockRequestsListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_knockrequestslistener(uniffiCallbackInterfaceKnockRequestsListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeKnockRequestsListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceLiveLocationShareListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        call: (uniffiHandle, liveLocationShares) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeLiveLocationShareListener.lift(uniffiHandle);
                return jsCallback.call(FfiConverterArrayTypeLiveLocationShare.lift(liveLocationShares));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // LiveLocationShareListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeLiveLocationShareListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_livelocationsharelistener(uniffiCallbackInterfaceLiveLocationShareListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeLiveLocationShareListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceMediaPreviewConfigListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onChange: (uniffiHandle, mediaPreviewConfig) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeMediaPreviewConfigListener.lift(uniffiHandle);
                return jsCallback.onChange(FfiConverterOptionalTypeMediaPreviewConfig.lift(mediaPreviewConfig));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // MediaPreviewConfigListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeMediaPreviewConfigListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_mediapreviewconfiglistener(uniffiCallbackInterfaceMediaPreviewConfigListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeMediaPreviewConfigListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceNotificationSettingsDelegate = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        settingsDidChange: (uniffiHandle) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeNotificationSettingsDelegate.lift(uniffiHandle);
                return jsCallback.settingsDidChange();
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // NotificationSettingsDelegate: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeNotificationSettingsDelegate.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_notificationsettingsdelegate(uniffiCallbackInterfaceNotificationSettingsDelegate.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeNotificationSettingsDelegate = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfacePaginationStatusListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (uniffiHandle, status) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypePaginationStatusListener.lift(uniffiHandle);
                return jsCallback.onUpdate(FfiConverterTypeRoomPaginationStatus.lift(status));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // PaginationStatusListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypePaginationStatusListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_paginationstatuslistener(uniffiCallbackInterfacePaginationStatusListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypePaginationStatusListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceProgressWatcher = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        transmissionProgress: (uniffiHandle, progress) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeProgressWatcher.lift(uniffiHandle);
                return jsCallback.transmissionProgress(FfiConverterTypeTransmissionProgress.lift(progress));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // ProgressWatcher: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeProgressWatcher.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_progresswatcher(uniffiCallbackInterfaceProgressWatcher.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeProgressWatcher = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceQrLoginProgressListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (uniffiHandle, state) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeQrLoginProgressListener.lift(uniffiHandle);
                return jsCallback.onUpdate(FfiConverterTypeQrLoginProgress.lift(state));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // QrLoginProgressListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeQrLoginProgressListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_qrloginprogresslistener(uniffiCallbackInterfaceQrLoginProgressListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeQrLoginProgressListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRecoveryStateListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (uniffiHandle, status) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeRecoveryStateListener.lift(uniffiHandle);
                return jsCallback.onUpdate(FfiConverterTypeRecoveryState.lift(status));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // RecoveryStateListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeRecoveryStateListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_recoverystatelistener(uniffiCallbackInterfaceRecoveryStateListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeRecoveryStateListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRoomAccountDataListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onChange: (uniffiHandle, event, roomId) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeRoomAccountDataListener.lift(uniffiHandle);
                return jsCallback.onChange(FfiConverterTypeRoomAccountDataEvent.lift(event), FfiConverterString.lift(roomId));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // RoomAccountDataListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeRoomAccountDataListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomaccountdatalistener(uniffiCallbackInterfaceRoomAccountDataListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomAccountDataListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRoomDirectorySearchEntriesListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (uniffiHandle, roomEntriesUpdate) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeRoomDirectorySearchEntriesListener.lift(uniffiHandle);
                return jsCallback.onUpdate(FfiConverterArrayTypeRoomDirectorySearchEntryUpdate.lift(roomEntriesUpdate));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // RoomDirectorySearchEntriesListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeRoomDirectorySearchEntriesListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomdirectorysearchentrieslistener(uniffiCallbackInterfaceRoomDirectorySearchEntriesListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomDirectorySearchEntriesListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRoomInfoListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        call: (uniffiHandle, roomInfo) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeRoomInfoListener.lift(uniffiHandle);
                return jsCallback.call(FfiConverterTypeRoomInfo.lift(roomInfo));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // RoomInfoListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeRoomInfoListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roominfolistener(uniffiCallbackInterfaceRoomInfoListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomInfoListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRoomListEntriesListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (uniffiHandle, roomEntriesUpdate) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeRoomListEntriesListener.lift(uniffiHandle);
                return jsCallback.onUpdate(FfiConverterArrayTypeRoomListEntriesUpdate.lift(roomEntriesUpdate));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // RoomListEntriesListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeRoomListEntriesListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistentrieslistener(uniffiCallbackInterfaceRoomListEntriesListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomListEntriesListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRoomListLoadingStateListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (uniffiHandle, state) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeRoomListLoadingStateListener.lift(uniffiHandle);
                return jsCallback.onUpdate(FfiConverterTypeRoomListLoadingState.lift(state));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // RoomListLoadingStateListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeRoomListLoadingStateListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistloadingstatelistener(uniffiCallbackInterfaceRoomListLoadingStateListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomListLoadingStateListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRoomListServiceStateListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (uniffiHandle, state) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeRoomListServiceStateListener.lift(uniffiHandle);
                return jsCallback.onUpdate(FfiConverterTypeRoomListServiceState.lift(state));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // RoomListServiceStateListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeRoomListServiceStateListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistservicestatelistener(uniffiCallbackInterfaceRoomListServiceStateListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomListServiceStateListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceRoomListServiceSyncIndicatorListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (uniffiHandle, syncIndicator) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeRoomListServiceSyncIndicatorListener.lift(uniffiHandle);
                return jsCallback.onUpdate(FfiConverterTypeRoomListServiceSyncIndicator.lift(syncIndicator));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // RoomListServiceSyncIndicatorListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeRoomListServiceSyncIndicatorListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistservicesyncindicatorlistener(uniffiCallbackInterfaceRoomListServiceSyncIndicatorListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeRoomListServiceSyncIndicatorListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceSendQueueListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (uniffiHandle, update) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeSendQueueListener.lift(uniffiHandle);
                return jsCallback.onUpdate(FfiConverterTypeRoomSendQueueUpdate.lift(update));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // SendQueueListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeSendQueueListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sendqueuelistener(uniffiCallbackInterfaceSendQueueListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeSendQueueListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceSendQueueRoomErrorListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onError: (uniffiHandle, roomId, error) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeSendQueueRoomErrorListener.lift(uniffiHandle);
                return jsCallback.onError(FfiConverterString.lift(roomId), FfiConverterTypeClientError.lift(error));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // SendQueueRoomErrorListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeSendQueueRoomErrorListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sendqueueroomerrorlistener(uniffiCallbackInterfaceSendQueueRoomErrorListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeSendQueueRoomErrorListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceSendQueueRoomUpdateListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (uniffiHandle, roomId, update) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeSendQueueRoomUpdateListener.lift(uniffiHandle);
                return jsCallback.onUpdate(FfiConverterString.lift(roomId), FfiConverterTypeRoomSendQueueUpdate.lift(update));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // SendQueueRoomUpdateListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeSendQueueRoomUpdateListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sendqueueroomupdatelistener(uniffiCallbackInterfaceSendQueueRoomUpdateListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeSendQueueRoomUpdateListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceSessionVerificationControllerDelegate = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        didReceiveVerificationRequest: (uniffiHandle, details) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeSessionVerificationControllerDelegate.lift(uniffiHandle);
                return jsCallback.didReceiveVerificationRequest(FfiConverterTypeSessionVerificationRequestDetails.lift(details));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        didAcceptVerificationRequest: (uniffiHandle) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeSessionVerificationControllerDelegate.lift(uniffiHandle);
                return jsCallback.didAcceptVerificationRequest();
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        didStartSasVerification: (uniffiHandle) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeSessionVerificationControllerDelegate.lift(uniffiHandle);
                return jsCallback.didStartSasVerification();
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        didReceiveVerificationData: (uniffiHandle, data) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeSessionVerificationControllerDelegate.lift(uniffiHandle);
                return jsCallback.didReceiveVerificationData(FfiConverterTypeSessionVerificationData.lift(data));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        didFail: (uniffiHandle) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeSessionVerificationControllerDelegate.lift(uniffiHandle);
                return jsCallback.didFail();
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        didCancel: (uniffiHandle) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeSessionVerificationControllerDelegate.lift(uniffiHandle);
                return jsCallback.didCancel();
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        didFinish: (uniffiHandle) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeSessionVerificationControllerDelegate.lift(uniffiHandle);
                return jsCallback.didFinish();
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // SessionVerificationControllerDelegate: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeSessionVerificationControllerDelegate.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sessionverificationcontrollerdelegate(uniffiCallbackInterfaceSessionVerificationControllerDelegate.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeSessionVerificationControllerDelegate = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceSpaceRoomListEntriesListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (uniffiHandle, rooms) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeSpaceRoomListEntriesListener.lift(uniffiHandle);
                return jsCallback.onUpdate(FfiConverterArrayTypeSpaceListUpdate.lift(rooms));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // SpaceRoomListEntriesListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeSpaceRoomListEntriesListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_spaceroomlistentrieslistener(uniffiCallbackInterfaceSpaceRoomListEntriesListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeSpaceRoomListEntriesListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceSpaceRoomListPaginationStateListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (uniffiHandle, paginationState) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeSpaceRoomListPaginationStateListener.lift(uniffiHandle);
                return jsCallback.onUpdate(FfiConverterTypeSpaceRoomListPaginationState.lift(paginationState));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // SpaceRoomListPaginationStateListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeSpaceRoomListPaginationStateListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_spaceroomlistpaginationstatelistener(uniffiCallbackInterfaceSpaceRoomListPaginationStateListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeSpaceRoomListPaginationStateListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceSpaceRoomListSpaceListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (uniffiHandle, space) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeSpaceRoomListSpaceListener.lift(uniffiHandle);
                return jsCallback.onUpdate(FfiConverterOptionalTypeSpaceRoom.lift(space));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // SpaceRoomListSpaceListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeSpaceRoomListSpaceListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_spaceroomlistspacelistener(uniffiCallbackInterfaceSpaceRoomListSpaceListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeSpaceRoomListSpaceListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceSpaceServiceJoinedSpacesListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (uniffiHandle, roomUpdates) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeSpaceServiceJoinedSpacesListener.lift(uniffiHandle);
                return jsCallback.onUpdate(FfiConverterArrayTypeSpaceListUpdate.lift(roomUpdates));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // SpaceServiceJoinedSpacesListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeSpaceServiceJoinedSpacesListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_spaceservicejoinedspaceslistener(uniffiCallbackInterfaceSpaceServiceJoinedSpacesListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeSpaceServiceJoinedSpacesListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceSyncNotificationListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onNotification: (uniffiHandle, notification, roomId) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeSyncNotificationListener.lift(uniffiHandle);
                return jsCallback.onNotification(FfiConverterTypeNotificationItem.lift(notification), FfiConverterString.lift(roomId));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // SyncNotificationListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeSyncNotificationListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_syncnotificationlistener(uniffiCallbackInterfaceSyncNotificationListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeSyncNotificationListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceSyncServiceStateObserver = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (uniffiHandle, state) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeSyncServiceStateObserver.lift(uniffiHandle);
                return jsCallback.onUpdate(FfiConverterTypeSyncServiceState.lift(state));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // SyncServiceStateObserver: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeSyncServiceStateObserver.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_syncservicestateobserver(uniffiCallbackInterfaceSyncServiceStateObserver.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeSyncServiceStateObserver = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceTimelineListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (uniffiHandle, diff) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeTimelineListener.lift(uniffiHandle);
                return jsCallback.onUpdate(FfiConverterArrayTypeTimelineDiff.lift(diff));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // TimelineListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeTimelineListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_timelinelistener(uniffiCallbackInterfaceTimelineListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeTimelineListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceTypingNotificationsListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        call: (uniffiHandle, typingUserIds) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeTypingNotificationsListener.lift(uniffiHandle);
                return jsCallback.call(FfiConverterArrayString.lift(typingUserIds));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // TypingNotificationsListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeTypingNotificationsListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_typingnotificationslistener(uniffiCallbackInterfaceTypingNotificationsListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeTypingNotificationsListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceUnableToDecryptDelegate = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUtd: (uniffiHandle, info) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeUnableToDecryptDelegate.lift(uniffiHandle);
                return jsCallback.onUtd(FfiConverterTypeUnableToDecryptInfo.lift(info));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // UnableToDecryptDelegate: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeUnableToDecryptDelegate.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_unabletodecryptdelegate(uniffiCallbackInterfaceUnableToDecryptDelegate.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeUnableToDecryptDelegate = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceVerificationStateListener = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        onUpdate: (uniffiHandle, status) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeVerificationStateListener.lift(uniffiHandle);
                return jsCallback.onUpdate(FfiConverterTypeVerificationState.lift(status));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => { };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // VerificationStateListener: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeVerificationStateListener.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_verificationstatelistener(uniffiCallbackInterfaceVerificationStateListener.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeVerificationStateListener = new FfiConverterCallback();
// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceWidgetCapabilitiesProvider = {
    // Create the VTable using a series of closures.
    // ts automatically converts these into C callback functions.
    vtable: {
        acquireCapabilities: (uniffiHandle, capabilities) => {
            const uniffiMakeCall = () => {
                const jsCallback = FfiConverterTypeWidgetCapabilitiesProvider.lift(uniffiHandle);
                return jsCallback.acquireCapabilities(FfiConverterTypeWidgetCapabilities.lift(capabilities));
            };
            const uniffiResult = UniffiResult.ready();
            const uniffiHandleSuccess = (obj) => {
                UniffiResult.writeSuccess(uniffiResult, FfiConverterTypeWidgetCapabilities.lower(obj));
            };
            const uniffiHandleError = (code, errBuf) => {
                UniffiResult.writeError(uniffiResult, code, errBuf);
            };
            uniffiTraitInterfaceCall(
            /*makeCall:*/ uniffiMakeCall, 
            /*handleSuccess:*/ uniffiHandleSuccess, 
            /*handleError:*/ uniffiHandleError, 
            /*lowerString:*/ FfiConverterString.lower);
            return uniffiResult;
        },
        uniffiFree: (uniffiHandle) => {
            // WidgetCapabilitiesProvider: this will throw a stale handle error if the handle isn't found.
            FfiConverterTypeWidgetCapabilitiesProvider.drop(uniffiHandle);
        }
    },
    register: () => {
        nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_init_callback_vtable_widgetcapabilitiesprovider(uniffiCallbackInterfaceWidgetCapabilitiesProvider.vtable);
    },
};
// FfiConverter protocol for callback interfaces
const FfiConverterTypeWidgetCapabilitiesProvider = new FfiConverterCallback();
/**
 * Generated factory for {@link AbstractProgress} record objects.
 */
export const AbstractProgress = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link AbstractProgress}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link AbstractProgress}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeAbstractProgress = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                current: FfiConverterUInt64.read(from),
                total: FfiConverterUInt64.read(from)
            };
        }
        write(value, into) {
            FfiConverterUInt64.write(value.current, into);
            FfiConverterUInt64.write(value.total, into);
        }
        allocationSize(value) {
            return FfiConverterUInt64.allocationSize(value.current) +
                FfiConverterUInt64.allocationSize(value.total);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link AudioInfo} record objects.
 */
export const AudioInfo = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link AudioInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link AudioInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeAudioInfo = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                duration: FfiConverterOptionalDuration.read(from),
                size: FfiConverterOptionalUInt64.read(from),
                mimetype: FfiConverterOptionalString.read(from)
            };
        }
        write(value, into) {
            FfiConverterOptionalDuration.write(value.duration, into);
            FfiConverterOptionalUInt64.write(value.size, into);
            FfiConverterOptionalString.write(value.mimetype, into);
        }
        allocationSize(value) {
            return FfiConverterOptionalDuration.allocationSize(value.duration) +
                FfiConverterOptionalUInt64.allocationSize(value.size) +
                FfiConverterOptionalString.allocationSize(value.mimetype);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link AudioMessageContent} record objects.
 */
export const AudioMessageContent = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link AudioMessageContent}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link AudioMessageContent}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeAudioMessageContent = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                filename: FfiConverterString.read(from),
                caption: FfiConverterOptionalString.read(from),
                formattedCaption: FfiConverterOptionalTypeFormattedBody.read(from),
                source: FfiConverterTypeMediaSource.read(from),
                info: FfiConverterOptionalTypeAudioInfo.read(from),
                audio: FfiConverterOptionalTypeUnstableAudioDetailsContent.read(from),
                voice: FfiConverterOptionalTypeUnstableVoiceContent.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.filename, into);
            FfiConverterOptionalString.write(value.caption, into);
            FfiConverterOptionalTypeFormattedBody.write(value.formattedCaption, into);
            FfiConverterTypeMediaSource.write(value.source, into);
            FfiConverterOptionalTypeAudioInfo.write(value.info, into);
            FfiConverterOptionalTypeUnstableAudioDetailsContent.write(value.audio, into);
            FfiConverterOptionalTypeUnstableVoiceContent.write(value.voice, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.filename) +
                FfiConverterOptionalString.allocationSize(value.caption) +
                FfiConverterOptionalTypeFormattedBody.allocationSize(value.formattedCaption) +
                FfiConverterTypeMediaSource.allocationSize(value.source) +
                FfiConverterOptionalTypeAudioInfo.allocationSize(value.info) +
                FfiConverterOptionalTypeUnstableAudioDetailsContent.allocationSize(value.audio) +
                FfiConverterOptionalTypeUnstableVoiceContent.allocationSize(value.voice);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link AuthDataPasswordDetails} record objects.
 */
export const AuthDataPasswordDetails = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link AuthDataPasswordDetails}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link AuthDataPasswordDetails}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeAuthDataPasswordDetails = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                identifier: FfiConverterString.read(from),
                password: FfiConverterString.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.identifier, into);
            FfiConverterString.write(value.password, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.identifier) +
                FfiConverterString.allocationSize(value.password);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link ClientProperties} record objects.
 */
export const ClientProperties = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link ClientProperties}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link ClientProperties}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeClientProperties = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                clientId: FfiConverterString.read(from),
                languageTag: FfiConverterOptionalString.read(from),
                theme: FfiConverterOptionalString.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.clientId, into);
            FfiConverterOptionalString.write(value.languageTag, into);
            FfiConverterOptionalString.write(value.theme, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.clientId) +
                FfiConverterOptionalString.allocationSize(value.languageTag) +
                FfiConverterOptionalString.allocationSize(value.theme);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link ComposerDraft} record objects.
 */
export const ComposerDraft = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link ComposerDraft}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link ComposerDraft}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeComposerDraft = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                plainText: FfiConverterString.read(from),
                htmlText: FfiConverterOptionalString.read(from),
                draftType: FfiConverterTypeComposerDraftType.read(from),
                attachments: FfiConverterArrayTypeDraftAttachment.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.plainText, into);
            FfiConverterOptionalString.write(value.htmlText, into);
            FfiConverterTypeComposerDraftType.write(value.draftType, into);
            FfiConverterArrayTypeDraftAttachment.write(value.attachments, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.plainText) +
                FfiConverterOptionalString.allocationSize(value.htmlText) +
                FfiConverterTypeComposerDraftType.allocationSize(value.draftType) +
                FfiConverterArrayTypeDraftAttachment.allocationSize(value.attachments);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link ConditionalPushRule} record objects.
 */
export const ConditionalPushRule = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link ConditionalPushRule}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link ConditionalPushRule}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeConditionalPushRule = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                actions: FfiConverterArrayTypeAction.read(from),
                default_: FfiConverterBool.read(from),
                enabled: FfiConverterBool.read(from),
                ruleId: FfiConverterString.read(from),
                conditions: FfiConverterArrayTypePushCondition.read(from)
            };
        }
        write(value, into) {
            FfiConverterArrayTypeAction.write(value.actions, into);
            FfiConverterBool.write(value.default_, into);
            FfiConverterBool.write(value.enabled, into);
            FfiConverterString.write(value.ruleId, into);
            FfiConverterArrayTypePushCondition.write(value.conditions, into);
        }
        allocationSize(value) {
            return FfiConverterArrayTypeAction.allocationSize(value.actions) +
                FfiConverterBool.allocationSize(value.default_) +
                FfiConverterBool.allocationSize(value.enabled) +
                FfiConverterString.allocationSize(value.ruleId) +
                FfiConverterArrayTypePushCondition.allocationSize(value.conditions);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link CreateRoomParameters} record objects.
 */
export const CreateRoomParameters = (() => {
    const defaults = () => ({ topic: undefined, isDirect: false, invite: undefined, avatar: undefined, powerLevelContentOverride: undefined, joinRuleOverride: undefined, historyVisibilityOverride: undefined, canonicalAlias: undefined
    });
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link CreateRoomParameters}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link CreateRoomParameters}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeCreateRoomParameters = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                name: FfiConverterOptionalString.read(from),
                topic: FfiConverterOptionalString.read(from),
                isEncrypted: FfiConverterBool.read(from),
                isDirect: FfiConverterBool.read(from),
                visibility: FfiConverterTypeRoomVisibility.read(from),
                preset: FfiConverterTypeRoomPreset.read(from),
                invite: FfiConverterOptionalArrayString.read(from),
                avatar: FfiConverterOptionalString.read(from),
                powerLevelContentOverride: FfiConverterOptionalTypePowerLevels.read(from),
                joinRuleOverride: FfiConverterOptionalTypeJoinRule.read(from),
                historyVisibilityOverride: FfiConverterOptionalTypeRoomHistoryVisibility.read(from),
                canonicalAlias: FfiConverterOptionalString.read(from)
            };
        }
        write(value, into) {
            FfiConverterOptionalString.write(value.name, into);
            FfiConverterOptionalString.write(value.topic, into);
            FfiConverterBool.write(value.isEncrypted, into);
            FfiConverterBool.write(value.isDirect, into);
            FfiConverterTypeRoomVisibility.write(value.visibility, into);
            FfiConverterTypeRoomPreset.write(value.preset, into);
            FfiConverterOptionalArrayString.write(value.invite, into);
            FfiConverterOptionalString.write(value.avatar, into);
            FfiConverterOptionalTypePowerLevels.write(value.powerLevelContentOverride, into);
            FfiConverterOptionalTypeJoinRule.write(value.joinRuleOverride, into);
            FfiConverterOptionalTypeRoomHistoryVisibility.write(value.historyVisibilityOverride, into);
            FfiConverterOptionalString.write(value.canonicalAlias, into);
        }
        allocationSize(value) {
            return FfiConverterOptionalString.allocationSize(value.name) +
                FfiConverterOptionalString.allocationSize(value.topic) +
                FfiConverterBool.allocationSize(value.isEncrypted) +
                FfiConverterBool.allocationSize(value.isDirect) +
                FfiConverterTypeRoomVisibility.allocationSize(value.visibility) +
                FfiConverterTypeRoomPreset.allocationSize(value.preset) +
                FfiConverterOptionalArrayString.allocationSize(value.invite) +
                FfiConverterOptionalString.allocationSize(value.avatar) +
                FfiConverterOptionalTypePowerLevels.allocationSize(value.powerLevelContentOverride) +
                FfiConverterOptionalTypeJoinRule.allocationSize(value.joinRuleOverride) +
                FfiConverterOptionalTypeRoomHistoryVisibility.allocationSize(value.historyVisibilityOverride) +
                FfiConverterOptionalString.allocationSize(value.canonicalAlias);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link EmoteMessageContent} record objects.
 */
export const EmoteMessageContent = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link EmoteMessageContent}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link EmoteMessageContent}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeEmoteMessageContent = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                body: FfiConverterString.read(from),
                formatted: FfiConverterOptionalTypeFormattedBody.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.body, into);
            FfiConverterOptionalTypeFormattedBody.write(value.formatted, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.body) +
                FfiConverterOptionalTypeFormattedBody.allocationSize(value.formatted);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link EventTimelineItem} record objects.
 */
export const EventTimelineItem = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link EventTimelineItem}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link EventTimelineItem}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeEventTimelineItem = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                isRemote: FfiConverterBool.read(from),
                eventOrTransactionId: FfiConverterTypeEventOrTransactionId.read(from),
                sender: FfiConverterString.read(from),
                senderProfile: FfiConverterTypeProfileDetails.read(from),
                isOwn: FfiConverterBool.read(from),
                isEditable: FfiConverterBool.read(from),
                content: FfiConverterTypeTimelineItemContent.read(from),
                timestamp: FfiConverterTypeTimestamp.read(from),
                localSendState: FfiConverterOptionalTypeEventSendState.read(from),
                localCreatedAt: FfiConverterOptionalUInt64.read(from),
                readReceipts: FfiConverterMapStringTypeReceipt.read(from),
                origin: FfiConverterOptionalTypeEventItemOrigin.read(from),
                canBeRepliedTo: FfiConverterBool.read(from),
                lazyProvider: FfiConverterTypeLazyTimelineItemProvider.read(from)
            };
        }
        write(value, into) {
            FfiConverterBool.write(value.isRemote, into);
            FfiConverterTypeEventOrTransactionId.write(value.eventOrTransactionId, into);
            FfiConverterString.write(value.sender, into);
            FfiConverterTypeProfileDetails.write(value.senderProfile, into);
            FfiConverterBool.write(value.isOwn, into);
            FfiConverterBool.write(value.isEditable, into);
            FfiConverterTypeTimelineItemContent.write(value.content, into);
            FfiConverterTypeTimestamp.write(value.timestamp, into);
            FfiConverterOptionalTypeEventSendState.write(value.localSendState, into);
            FfiConverterOptionalUInt64.write(value.localCreatedAt, into);
            FfiConverterMapStringTypeReceipt.write(value.readReceipts, into);
            FfiConverterOptionalTypeEventItemOrigin.write(value.origin, into);
            FfiConverterBool.write(value.canBeRepliedTo, into);
            FfiConverterTypeLazyTimelineItemProvider.write(value.lazyProvider, into);
        }
        allocationSize(value) {
            return FfiConverterBool.allocationSize(value.isRemote) +
                FfiConverterTypeEventOrTransactionId.allocationSize(value.eventOrTransactionId) +
                FfiConverterString.allocationSize(value.sender) +
                FfiConverterTypeProfileDetails.allocationSize(value.senderProfile) +
                FfiConverterBool.allocationSize(value.isOwn) +
                FfiConverterBool.allocationSize(value.isEditable) +
                FfiConverterTypeTimelineItemContent.allocationSize(value.content) +
                FfiConverterTypeTimestamp.allocationSize(value.timestamp) +
                FfiConverterOptionalTypeEventSendState.allocationSize(value.localSendState) +
                FfiConverterOptionalUInt64.allocationSize(value.localCreatedAt) +
                FfiConverterMapStringTypeReceipt.allocationSize(value.readReceipts) +
                FfiConverterOptionalTypeEventItemOrigin.allocationSize(value.origin) +
                FfiConverterBool.allocationSize(value.canBeRepliedTo) +
                FfiConverterTypeLazyTimelineItemProvider.allocationSize(value.lazyProvider);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link EventTimelineItemDebugInfo} record objects.
 */
export const EventTimelineItemDebugInfo = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link EventTimelineItemDebugInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link EventTimelineItemDebugInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeEventTimelineItemDebugInfo = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                model: FfiConverterString.read(from),
                originalJson: FfiConverterOptionalString.read(from),
                latestEditJson: FfiConverterOptionalString.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.model, into);
            FfiConverterOptionalString.write(value.originalJson, into);
            FfiConverterOptionalString.write(value.latestEditJson, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.model) +
                FfiConverterOptionalString.allocationSize(value.originalJson) +
                FfiConverterOptionalString.allocationSize(value.latestEditJson);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link FileInfo} record objects.
 */
export const FileInfo = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link FileInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link FileInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeFileInfo = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                mimetype: FfiConverterOptionalString.read(from),
                size: FfiConverterOptionalUInt64.read(from),
                thumbnailInfo: FfiConverterOptionalTypeThumbnailInfo.read(from),
                thumbnailSource: FfiConverterOptionalTypeMediaSource.read(from)
            };
        }
        write(value, into) {
            FfiConverterOptionalString.write(value.mimetype, into);
            FfiConverterOptionalUInt64.write(value.size, into);
            FfiConverterOptionalTypeThumbnailInfo.write(value.thumbnailInfo, into);
            FfiConverterOptionalTypeMediaSource.write(value.thumbnailSource, into);
        }
        allocationSize(value) {
            return FfiConverterOptionalString.allocationSize(value.mimetype) +
                FfiConverterOptionalUInt64.allocationSize(value.size) +
                FfiConverterOptionalTypeThumbnailInfo.allocationSize(value.thumbnailInfo) +
                FfiConverterOptionalTypeMediaSource.allocationSize(value.thumbnailSource);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link FileMessageContent} record objects.
 */
export const FileMessageContent = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link FileMessageContent}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link FileMessageContent}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeFileMessageContent = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                filename: FfiConverterString.read(from),
                caption: FfiConverterOptionalString.read(from),
                formattedCaption: FfiConverterOptionalTypeFormattedBody.read(from),
                source: FfiConverterTypeMediaSource.read(from),
                info: FfiConverterOptionalTypeFileInfo.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.filename, into);
            FfiConverterOptionalString.write(value.caption, into);
            FfiConverterOptionalTypeFormattedBody.write(value.formattedCaption, into);
            FfiConverterTypeMediaSource.write(value.source, into);
            FfiConverterOptionalTypeFileInfo.write(value.info, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.filename) +
                FfiConverterOptionalString.allocationSize(value.caption) +
                FfiConverterOptionalTypeFormattedBody.allocationSize(value.formattedCaption) +
                FfiConverterTypeMediaSource.allocationSize(value.source) +
                FfiConverterOptionalTypeFileInfo.allocationSize(value.info);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link FormattedBody} record objects.
 */
export const FormattedBody = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link FormattedBody}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link FormattedBody}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeFormattedBody = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                format: FfiConverterTypeMessageFormat.read(from),
                body: FfiConverterString.read(from)
            };
        }
        write(value, into) {
            FfiConverterTypeMessageFormat.write(value.format, into);
            FfiConverterString.write(value.body, into);
        }
        allocationSize(value) {
            return FfiConverterTypeMessageFormat.allocationSize(value.format) +
                FfiConverterString.allocationSize(value.body);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link HttpPusherData} record objects.
 */
export const HttpPusherData = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link HttpPusherData}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link HttpPusherData}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeHttpPusherData = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                url: FfiConverterString.read(from),
                format: FfiConverterOptionalTypePushFormat.read(from),
                defaultPayload: FfiConverterOptionalString.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.url, into);
            FfiConverterOptionalTypePushFormat.write(value.format, into);
            FfiConverterOptionalString.write(value.defaultPayload, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.url) +
                FfiConverterOptionalTypePushFormat.allocationSize(value.format) +
                FfiConverterOptionalString.allocationSize(value.defaultPayload);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link IdentityStatusChange} record objects.
 */
export const IdentityStatusChange = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link IdentityStatusChange}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link IdentityStatusChange}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeIdentityStatusChange = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                userId: FfiConverterString.read(from),
                changedTo: FfiConverterTypeIdentityState.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.userId, into);
            FfiConverterTypeIdentityState.write(value.changedTo, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.userId) +
                FfiConverterTypeIdentityState.allocationSize(value.changedTo);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link IgnoredUser} record objects.
 */
export const IgnoredUser = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link IgnoredUser}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link IgnoredUser}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeIgnoredUser = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {};
        }
        write(value, into) {
        }
        allocationSize(value) {
            return 0;
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link ImageInfo} record objects.
 */
export const ImageInfo = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link ImageInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link ImageInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeImageInfo = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                height: FfiConverterOptionalUInt64.read(from),
                width: FfiConverterOptionalUInt64.read(from),
                mimetype: FfiConverterOptionalString.read(from),
                size: FfiConverterOptionalUInt64.read(from),
                thumbnailInfo: FfiConverterOptionalTypeThumbnailInfo.read(from),
                thumbnailSource: FfiConverterOptionalTypeMediaSource.read(from),
                blurhash: FfiConverterOptionalString.read(from),
                isAnimated: FfiConverterOptionalBool.read(from)
            };
        }
        write(value, into) {
            FfiConverterOptionalUInt64.write(value.height, into);
            FfiConverterOptionalUInt64.write(value.width, into);
            FfiConverterOptionalString.write(value.mimetype, into);
            FfiConverterOptionalUInt64.write(value.size, into);
            FfiConverterOptionalTypeThumbnailInfo.write(value.thumbnailInfo, into);
            FfiConverterOptionalTypeMediaSource.write(value.thumbnailSource, into);
            FfiConverterOptionalString.write(value.blurhash, into);
            FfiConverterOptionalBool.write(value.isAnimated, into);
        }
        allocationSize(value) {
            return FfiConverterOptionalUInt64.allocationSize(value.height) +
                FfiConverterOptionalUInt64.allocationSize(value.width) +
                FfiConverterOptionalString.allocationSize(value.mimetype) +
                FfiConverterOptionalUInt64.allocationSize(value.size) +
                FfiConverterOptionalTypeThumbnailInfo.allocationSize(value.thumbnailInfo) +
                FfiConverterOptionalTypeMediaSource.allocationSize(value.thumbnailSource) +
                FfiConverterOptionalString.allocationSize(value.blurhash) +
                FfiConverterOptionalBool.allocationSize(value.isAnimated);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link ImageMessageContent} record objects.
 */
export const ImageMessageContent = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link ImageMessageContent}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link ImageMessageContent}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeImageMessageContent = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                filename: FfiConverterString.read(from),
                caption: FfiConverterOptionalString.read(from),
                formattedCaption: FfiConverterOptionalTypeFormattedBody.read(from),
                source: FfiConverterTypeMediaSource.read(from),
                info: FfiConverterOptionalTypeImageInfo.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.filename, into);
            FfiConverterOptionalString.write(value.caption, into);
            FfiConverterOptionalTypeFormattedBody.write(value.formattedCaption, into);
            FfiConverterTypeMediaSource.write(value.source, into);
            FfiConverterOptionalTypeImageInfo.write(value.info, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.filename) +
                FfiConverterOptionalString.allocationSize(value.caption) +
                FfiConverterOptionalTypeFormattedBody.allocationSize(value.formattedCaption) +
                FfiConverterTypeMediaSource.allocationSize(value.source) +
                FfiConverterOptionalTypeImageInfo.allocationSize(value.info);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link KnockRequest} record objects.
 */
export const KnockRequest = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link KnockRequest}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link KnockRequest}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeKnockRequest = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                eventId: FfiConverterString.read(from),
                userId: FfiConverterString.read(from),
                roomId: FfiConverterString.read(from),
                displayName: FfiConverterOptionalString.read(from),
                avatarUrl: FfiConverterOptionalString.read(from),
                reason: FfiConverterOptionalString.read(from),
                timestamp: FfiConverterOptionalUInt64.read(from),
                isSeen: FfiConverterBool.read(from),
                actions: FfiConverterTypeKnockRequestActions.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.eventId, into);
            FfiConverterString.write(value.userId, into);
            FfiConverterString.write(value.roomId, into);
            FfiConverterOptionalString.write(value.displayName, into);
            FfiConverterOptionalString.write(value.avatarUrl, into);
            FfiConverterOptionalString.write(value.reason, into);
            FfiConverterOptionalUInt64.write(value.timestamp, into);
            FfiConverterBool.write(value.isSeen, into);
            FfiConverterTypeKnockRequestActions.write(value.actions, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.eventId) +
                FfiConverterString.allocationSize(value.userId) +
                FfiConverterString.allocationSize(value.roomId) +
                FfiConverterOptionalString.allocationSize(value.displayName) +
                FfiConverterOptionalString.allocationSize(value.avatarUrl) +
                FfiConverterOptionalString.allocationSize(value.reason) +
                FfiConverterOptionalUInt64.allocationSize(value.timestamp) +
                FfiConverterBool.allocationSize(value.isSeen) +
                FfiConverterTypeKnockRequestActions.allocationSize(value.actions);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link LastLocation} record objects.
 */
export const LastLocation = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link LastLocation}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link LastLocation}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeLastLocation = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                location: FfiConverterTypeLocationContent.read(from),
                ts: FfiConverterUInt64.read(from)
            };
        }
        write(value, into) {
            FfiConverterTypeLocationContent.write(value.location, into);
            FfiConverterUInt64.write(value.ts, into);
        }
        allocationSize(value) {
            return FfiConverterTypeLocationContent.allocationSize(value.location) +
                FfiConverterUInt64.allocationSize(value.ts);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link LeaveSpaceRoom} record objects.
 */
export const LeaveSpaceRoom = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link LeaveSpaceRoom}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link LeaveSpaceRoom}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeLeaveSpaceRoom = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                spaceRoom: FfiConverterTypeSpaceRoom.read(from),
                isLastAdmin: FfiConverterBool.read(from)
            };
        }
        write(value, into) {
            FfiConverterTypeSpaceRoom.write(value.spaceRoom, into);
            FfiConverterBool.write(value.isLastAdmin, into);
        }
        allocationSize(value) {
            return FfiConverterTypeSpaceRoom.allocationSize(value.spaceRoom) +
                FfiConverterBool.allocationSize(value.isLastAdmin);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link LiveLocationShare} record objects.
 */
export const LiveLocationShare = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link LiveLocationShare}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link LiveLocationShare}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeLiveLocationShare = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                lastLocation: FfiConverterTypeLastLocation.read(from),
                isLive: FfiConverterBool.read(from),
                userId: FfiConverterString.read(from)
            };
        }
        write(value, into) {
            FfiConverterTypeLastLocation.write(value.lastLocation, into);
            FfiConverterBool.write(value.isLive, into);
            FfiConverterString.write(value.userId, into);
        }
        allocationSize(value) {
            return FfiConverterTypeLastLocation.allocationSize(value.lastLocation) +
                FfiConverterBool.allocationSize(value.isLive) +
                FfiConverterString.allocationSize(value.userId);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link LocationContent} record objects.
 */
export const LocationContent = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link LocationContent}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link LocationContent}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeLocationContent = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                body: FfiConverterString.read(from),
                geoUri: FfiConverterString.read(from),
                description: FfiConverterOptionalString.read(from),
                zoomLevel: FfiConverterOptionalUInt8.read(from),
                asset: FfiConverterOptionalTypeAssetType.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.body, into);
            FfiConverterString.write(value.geoUri, into);
            FfiConverterOptionalString.write(value.description, into);
            FfiConverterOptionalUInt8.write(value.zoomLevel, into);
            FfiConverterOptionalTypeAssetType.write(value.asset, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.body) +
                FfiConverterString.allocationSize(value.geoUri) +
                FfiConverterOptionalString.allocationSize(value.description) +
                FfiConverterOptionalUInt8.allocationSize(value.zoomLevel) +
                FfiConverterOptionalTypeAssetType.allocationSize(value.asset);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link MatrixEntity} record objects.
 */
export const MatrixEntity = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link MatrixEntity}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link MatrixEntity}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeMatrixEntity = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                id: FfiConverterTypeMatrixId.read(from),
                via: FfiConverterArrayString.read(from)
            };
        }
        write(value, into) {
            FfiConverterTypeMatrixId.write(value.id, into);
            FfiConverterArrayString.write(value.via, into);
        }
        allocationSize(value) {
            return FfiConverterTypeMatrixId.allocationSize(value.id) +
                FfiConverterArrayString.allocationSize(value.via);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link MediaPreviewConfig} record objects.
 */
export const MediaPreviewConfig = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link MediaPreviewConfig}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link MediaPreviewConfig}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeMediaPreviewConfig = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                mediaPreviews: FfiConverterOptionalTypeMediaPreviews.read(from),
                inviteAvatars: FfiConverterOptionalTypeInviteAvatars.read(from)
            };
        }
        write(value, into) {
            FfiConverterOptionalTypeMediaPreviews.write(value.mediaPreviews, into);
            FfiConverterOptionalTypeInviteAvatars.write(value.inviteAvatars, into);
        }
        allocationSize(value) {
            return FfiConverterOptionalTypeMediaPreviews.allocationSize(value.mediaPreviews) +
                FfiConverterOptionalTypeInviteAvatars.allocationSize(value.inviteAvatars);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link MediaUploadProgress} record objects.
 */
export const MediaUploadProgress = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link MediaUploadProgress}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link MediaUploadProgress}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeMediaUploadProgress = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                index: FfiConverterUInt64.read(from),
                progress: FfiConverterTypeAbstractProgress.read(from)
            };
        }
        write(value, into) {
            FfiConverterUInt64.write(value.index, into);
            FfiConverterTypeAbstractProgress.write(value.progress, into);
        }
        allocationSize(value) {
            return FfiConverterUInt64.allocationSize(value.index) +
                FfiConverterTypeAbstractProgress.allocationSize(value.progress);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link Mentions} record objects.
 */
export const Mentions = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Mentions}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link Mentions}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeMentions = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                userIds: FfiConverterArrayString.read(from),
                room: FfiConverterBool.read(from)
            };
        }
        write(value, into) {
            FfiConverterArrayString.write(value.userIds, into);
            FfiConverterBool.write(value.room, into);
        }
        allocationSize(value) {
            return FfiConverterArrayString.allocationSize(value.userIds) +
                FfiConverterBool.allocationSize(value.room);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link MessageContent} record objects.
 */
export const MessageContent = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link MessageContent}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link MessageContent}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeMessageContent = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                msgType: FfiConverterTypeMessageType.read(from),
                body: FfiConverterString.read(from),
                isEdited: FfiConverterBool.read(from),
                mentions: FfiConverterOptionalTypeMentions.read(from)
            };
        }
        write(value, into) {
            FfiConverterTypeMessageType.write(value.msgType, into);
            FfiConverterString.write(value.body, into);
            FfiConverterBool.write(value.isEdited, into);
            FfiConverterOptionalTypeMentions.write(value.mentions, into);
        }
        allocationSize(value) {
            return FfiConverterTypeMessageType.allocationSize(value.msgType) +
                FfiConverterString.allocationSize(value.body) +
                FfiConverterBool.allocationSize(value.isEdited) +
                FfiConverterOptionalTypeMentions.allocationSize(value.mentions);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link MsgLikeContent} record objects.
 */
export const MsgLikeContent = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link MsgLikeContent}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link MsgLikeContent}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeMsgLikeContent = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                kind: FfiConverterTypeMsgLikeKind.read(from),
                reactions: FfiConverterArrayTypeReaction.read(from),
                inReplyTo: FfiConverterOptionalTypeInReplyToDetails.read(from),
                threadRoot: FfiConverterOptionalString.read(from),
                threadSummary: FfiConverterOptionalTypeThreadSummary.read(from)
            };
        }
        write(value, into) {
            FfiConverterTypeMsgLikeKind.write(value.kind, into);
            FfiConverterArrayTypeReaction.write(value.reactions, into);
            FfiConverterOptionalTypeInReplyToDetails.write(value.inReplyTo, into);
            FfiConverterOptionalString.write(value.threadRoot, into);
            FfiConverterOptionalTypeThreadSummary.write(value.threadSummary, into);
        }
        allocationSize(value) {
            return FfiConverterTypeMsgLikeKind.allocationSize(value.kind) +
                FfiConverterArrayTypeReaction.allocationSize(value.reactions) +
                FfiConverterOptionalTypeInReplyToDetails.allocationSize(value.inReplyTo) +
                FfiConverterOptionalString.allocationSize(value.threadRoot) +
                FfiConverterOptionalTypeThreadSummary.allocationSize(value.threadSummary);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link NoticeMessageContent} record objects.
 */
export const NoticeMessageContent = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link NoticeMessageContent}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link NoticeMessageContent}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeNoticeMessageContent = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                body: FfiConverterString.read(from),
                formatted: FfiConverterOptionalTypeFormattedBody.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.body, into);
            FfiConverterOptionalTypeFormattedBody.write(value.formatted, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.body) +
                FfiConverterOptionalTypeFormattedBody.allocationSize(value.formatted);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link NotificationItem} record objects.
 */
export const NotificationItem = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link NotificationItem}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link NotificationItem}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeNotificationItem = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                event: FfiConverterTypeNotificationEvent.read(from),
                senderInfo: FfiConverterTypeNotificationSenderInfo.read(from),
                roomInfo: FfiConverterTypeNotificationRoomInfo.read(from),
                isNoisy: FfiConverterOptionalBool.read(from),
                hasMention: FfiConverterOptionalBool.read(from),
                threadId: FfiConverterOptionalString.read(from),
                actions: FfiConverterOptionalArrayTypeAction.read(from)
            };
        }
        write(value, into) {
            FfiConverterTypeNotificationEvent.write(value.event, into);
            FfiConverterTypeNotificationSenderInfo.write(value.senderInfo, into);
            FfiConverterTypeNotificationRoomInfo.write(value.roomInfo, into);
            FfiConverterOptionalBool.write(value.isNoisy, into);
            FfiConverterOptionalBool.write(value.hasMention, into);
            FfiConverterOptionalString.write(value.threadId, into);
            FfiConverterOptionalArrayTypeAction.write(value.actions, into);
        }
        allocationSize(value) {
            return FfiConverterTypeNotificationEvent.allocationSize(value.event) +
                FfiConverterTypeNotificationSenderInfo.allocationSize(value.senderInfo) +
                FfiConverterTypeNotificationRoomInfo.allocationSize(value.roomInfo) +
                FfiConverterOptionalBool.allocationSize(value.isNoisy) +
                FfiConverterOptionalBool.allocationSize(value.hasMention) +
                FfiConverterOptionalString.allocationSize(value.threadId) +
                FfiConverterOptionalArrayTypeAction.allocationSize(value.actions);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link NotificationItemsRequest} record objects.
 */
export const NotificationItemsRequest = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link NotificationItemsRequest}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link NotificationItemsRequest}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeNotificationItemsRequest = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                roomId: FfiConverterString.read(from),
                eventIds: FfiConverterArrayString.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.roomId, into);
            FfiConverterArrayString.write(value.eventIds, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.roomId) +
                FfiConverterArrayString.allocationSize(value.eventIds);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link NotificationPowerLevels} record objects.
 */
export const NotificationPowerLevels = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link NotificationPowerLevels}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link NotificationPowerLevels}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeNotificationPowerLevels = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                room: FfiConverterInt32.read(from)
            };
        }
        write(value, into) {
            FfiConverterInt32.write(value.room, into);
        }
        allocationSize(value) {
            return FfiConverterInt32.allocationSize(value.room);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link NotificationRoomInfo} record objects.
 */
export const NotificationRoomInfo = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link NotificationRoomInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link NotificationRoomInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeNotificationRoomInfo = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                displayName: FfiConverterString.read(from),
                avatarUrl: FfiConverterOptionalString.read(from),
                canonicalAlias: FfiConverterOptionalString.read(from),
                topic: FfiConverterOptionalString.read(from),
                joinRule: FfiConverterOptionalTypeJoinRule.read(from),
                joinedMembersCount: FfiConverterUInt64.read(from),
                isEncrypted: FfiConverterOptionalBool.read(from),
                isDirect: FfiConverterBool.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.displayName, into);
            FfiConverterOptionalString.write(value.avatarUrl, into);
            FfiConverterOptionalString.write(value.canonicalAlias, into);
            FfiConverterOptionalString.write(value.topic, into);
            FfiConverterOptionalTypeJoinRule.write(value.joinRule, into);
            FfiConverterUInt64.write(value.joinedMembersCount, into);
            FfiConverterOptionalBool.write(value.isEncrypted, into);
            FfiConverterBool.write(value.isDirect, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.displayName) +
                FfiConverterOptionalString.allocationSize(value.avatarUrl) +
                FfiConverterOptionalString.allocationSize(value.canonicalAlias) +
                FfiConverterOptionalString.allocationSize(value.topic) +
                FfiConverterOptionalTypeJoinRule.allocationSize(value.joinRule) +
                FfiConverterUInt64.allocationSize(value.joinedMembersCount) +
                FfiConverterOptionalBool.allocationSize(value.isEncrypted) +
                FfiConverterBool.allocationSize(value.isDirect);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link NotificationSenderInfo} record objects.
 */
export const NotificationSenderInfo = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link NotificationSenderInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link NotificationSenderInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeNotificationSenderInfo = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                displayName: FfiConverterOptionalString.read(from),
                avatarUrl: FfiConverterOptionalString.read(from),
                isNameAmbiguous: FfiConverterBool.read(from)
            };
        }
        write(value, into) {
            FfiConverterOptionalString.write(value.displayName, into);
            FfiConverterOptionalString.write(value.avatarUrl, into);
            FfiConverterBool.write(value.isNameAmbiguous, into);
        }
        allocationSize(value) {
            return FfiConverterOptionalString.allocationSize(value.displayName) +
                FfiConverterOptionalString.allocationSize(value.avatarUrl) +
                FfiConverterBool.allocationSize(value.isNameAmbiguous);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link OidcConfiguration} record objects.
 */
export const OidcConfiguration = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link OidcConfiguration}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link OidcConfiguration}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeOidcConfiguration = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                clientName: FfiConverterOptionalString.read(from),
                redirectUri: FfiConverterString.read(from),
                clientUri: FfiConverterString.read(from),
                logoUri: FfiConverterOptionalString.read(from),
                tosUri: FfiConverterOptionalString.read(from),
                policyUri: FfiConverterOptionalString.read(from),
                staticRegistrations: FfiConverterMapStringString.read(from)
            };
        }
        write(value, into) {
            FfiConverterOptionalString.write(value.clientName, into);
            FfiConverterString.write(value.redirectUri, into);
            FfiConverterString.write(value.clientUri, into);
            FfiConverterOptionalString.write(value.logoUri, into);
            FfiConverterOptionalString.write(value.tosUri, into);
            FfiConverterOptionalString.write(value.policyUri, into);
            FfiConverterMapStringString.write(value.staticRegistrations, into);
        }
        allocationSize(value) {
            return FfiConverterOptionalString.allocationSize(value.clientName) +
                FfiConverterString.allocationSize(value.redirectUri) +
                FfiConverterString.allocationSize(value.clientUri) +
                FfiConverterOptionalString.allocationSize(value.logoUri) +
                FfiConverterOptionalString.allocationSize(value.tosUri) +
                FfiConverterOptionalString.allocationSize(value.policyUri) +
                FfiConverterMapStringString.allocationSize(value.staticRegistrations);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link OidcCrossSigningResetInfo} record objects.
 */
export const OidcCrossSigningResetInfo = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link OidcCrossSigningResetInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link OidcCrossSigningResetInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeOidcCrossSigningResetInfo = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                approvalUrl: FfiConverterString.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.approvalUrl, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.approvalUrl);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link PassPhrase} record objects.
 */
export const PassPhrase = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PassPhrase}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link PassPhrase}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypePassPhrase = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                algorithm: FfiConverterTypeKeyDerivationAlgorithm.read(from),
                salt: FfiConverterString.read(from),
                iterations: FfiConverterUInt64.read(from),
                bits: FfiConverterUInt64.read(from)
            };
        }
        write(value, into) {
            FfiConverterTypeKeyDerivationAlgorithm.write(value.algorithm, into);
            FfiConverterString.write(value.salt, into);
            FfiConverterUInt64.write(value.iterations, into);
            FfiConverterUInt64.write(value.bits, into);
        }
        allocationSize(value) {
            return FfiConverterTypeKeyDerivationAlgorithm.allocationSize(value.algorithm) +
                FfiConverterString.allocationSize(value.salt) +
                FfiConverterUInt64.allocationSize(value.iterations) +
                FfiConverterUInt64.allocationSize(value.bits);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link PatternedPushRule} record objects.
 */
export const PatternedPushRule = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PatternedPushRule}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link PatternedPushRule}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypePatternedPushRule = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                actions: FfiConverterArrayTypeAction.read(from),
                default_: FfiConverterBool.read(from),
                enabled: FfiConverterBool.read(from),
                ruleId: FfiConverterString.read(from),
                pattern: FfiConverterString.read(from)
            };
        }
        write(value, into) {
            FfiConverterArrayTypeAction.write(value.actions, into);
            FfiConverterBool.write(value.default_, into);
            FfiConverterBool.write(value.enabled, into);
            FfiConverterString.write(value.ruleId, into);
            FfiConverterString.write(value.pattern, into);
        }
        allocationSize(value) {
            return FfiConverterArrayTypeAction.allocationSize(value.actions) +
                FfiConverterBool.allocationSize(value.default_) +
                FfiConverterBool.allocationSize(value.enabled) +
                FfiConverterString.allocationSize(value.ruleId) +
                FfiConverterString.allocationSize(value.pattern);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link PollAnswer} record objects.
 */
export const PollAnswer = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PollAnswer}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link PollAnswer}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypePollAnswer = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                id: FfiConverterString.read(from),
                text: FfiConverterString.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.id, into);
            FfiConverterString.write(value.text, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.id) +
                FfiConverterString.allocationSize(value.text);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link PollData} record objects.
 */
export const PollData = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PollData}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link PollData}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypePollData = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                question: FfiConverterString.read(from),
                answers: FfiConverterArrayString.read(from),
                maxSelections: FfiConverterUInt8.read(from),
                pollKind: FfiConverterTypePollKind.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.question, into);
            FfiConverterArrayString.write(value.answers, into);
            FfiConverterUInt8.write(value.maxSelections, into);
            FfiConverterTypePollKind.write(value.pollKind, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.question) +
                FfiConverterArrayString.allocationSize(value.answers) +
                FfiConverterUInt8.allocationSize(value.maxSelections) +
                FfiConverterTypePollKind.allocationSize(value.pollKind);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link PowerLevels} record objects.
 */
export const PowerLevels = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PowerLevels}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link PowerLevels}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypePowerLevels = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                usersDefault: FfiConverterOptionalInt32.read(from),
                eventsDefault: FfiConverterOptionalInt32.read(from),
                stateDefault: FfiConverterOptionalInt32.read(from),
                ban: FfiConverterOptionalInt32.read(from),
                kick: FfiConverterOptionalInt32.read(from),
                redact: FfiConverterOptionalInt32.read(from),
                invite: FfiConverterOptionalInt32.read(from),
                notifications: FfiConverterOptionalTypeNotificationPowerLevels.read(from),
                users: FfiConverterMapStringInt32.read(from),
                events: FfiConverterMapStringInt32.read(from)
            };
        }
        write(value, into) {
            FfiConverterOptionalInt32.write(value.usersDefault, into);
            FfiConverterOptionalInt32.write(value.eventsDefault, into);
            FfiConverterOptionalInt32.write(value.stateDefault, into);
            FfiConverterOptionalInt32.write(value.ban, into);
            FfiConverterOptionalInt32.write(value.kick, into);
            FfiConverterOptionalInt32.write(value.redact, into);
            FfiConverterOptionalInt32.write(value.invite, into);
            FfiConverterOptionalTypeNotificationPowerLevels.write(value.notifications, into);
            FfiConverterMapStringInt32.write(value.users, into);
            FfiConverterMapStringInt32.write(value.events, into);
        }
        allocationSize(value) {
            return FfiConverterOptionalInt32.allocationSize(value.usersDefault) +
                FfiConverterOptionalInt32.allocationSize(value.eventsDefault) +
                FfiConverterOptionalInt32.allocationSize(value.stateDefault) +
                FfiConverterOptionalInt32.allocationSize(value.ban) +
                FfiConverterOptionalInt32.allocationSize(value.kick) +
                FfiConverterOptionalInt32.allocationSize(value.redact) +
                FfiConverterOptionalInt32.allocationSize(value.invite) +
                FfiConverterOptionalTypeNotificationPowerLevels.allocationSize(value.notifications) +
                FfiConverterMapStringInt32.allocationSize(value.users) +
                FfiConverterMapStringInt32.allocationSize(value.events);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link PredecessorRoom} record objects.
 */
export const PredecessorRoom = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PredecessorRoom}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link PredecessorRoom}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypePredecessorRoom = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                roomId: FfiConverterString.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.roomId, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.roomId);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link PusherIdentifiers} record objects.
 */
export const PusherIdentifiers = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PusherIdentifiers}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link PusherIdentifiers}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypePusherIdentifiers = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                pushkey: FfiConverterString.read(from),
                appId: FfiConverterString.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.pushkey, into);
            FfiConverterString.write(value.appId, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.pushkey) +
                FfiConverterString.allocationSize(value.appId);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link Reaction} record objects.
 */
export const Reaction = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Reaction}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link Reaction}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeReaction = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                key: FfiConverterString.read(from),
                senders: FfiConverterArrayTypeReactionSenderData.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.key, into);
            FfiConverterArrayTypeReactionSenderData.write(value.senders, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.key) +
                FfiConverterArrayTypeReactionSenderData.allocationSize(value.senders);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link ReactionSenderData} record objects.
 */
export const ReactionSenderData = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link ReactionSenderData}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link ReactionSenderData}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeReactionSenderData = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                senderId: FfiConverterString.read(from),
                timestamp: FfiConverterTypeTimestamp.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.senderId, into);
            FfiConverterTypeTimestamp.write(value.timestamp, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.senderId) +
                FfiConverterTypeTimestamp.allocationSize(value.timestamp);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link Receipt} record objects.
 */
export const Receipt = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Receipt}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link Receipt}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeReceipt = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                timestamp: FfiConverterOptionalTypeTimestamp.read(from)
            };
        }
        write(value, into) {
            FfiConverterOptionalTypeTimestamp.write(value.timestamp, into);
        }
        allocationSize(value) {
            return FfiConverterOptionalTypeTimestamp.allocationSize(value.timestamp);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link RequestConfig} record objects.
 */
export const RequestConfig = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link RequestConfig}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link RequestConfig}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeRequestConfig = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                retryLimit: FfiConverterOptionalUInt64.read(from),
                timeout: FfiConverterOptionalUInt64.read(from),
                maxConcurrentRequests: FfiConverterOptionalUInt64.read(from),
                maxRetryTime: FfiConverterOptionalUInt64.read(from)
            };
        }
        write(value, into) {
            FfiConverterOptionalUInt64.write(value.retryLimit, into);
            FfiConverterOptionalUInt64.write(value.timeout, into);
            FfiConverterOptionalUInt64.write(value.maxConcurrentRequests, into);
            FfiConverterOptionalUInt64.write(value.maxRetryTime, into);
        }
        allocationSize(value) {
            return FfiConverterOptionalUInt64.allocationSize(value.retryLimit) +
                FfiConverterOptionalUInt64.allocationSize(value.timeout) +
                FfiConverterOptionalUInt64.allocationSize(value.maxConcurrentRequests) +
                FfiConverterOptionalUInt64.allocationSize(value.maxRetryTime);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link ResolvedRoomAlias} record objects.
 */
export const ResolvedRoomAlias = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link ResolvedRoomAlias}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link ResolvedRoomAlias}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeResolvedRoomAlias = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                roomId: FfiConverterString.read(from),
                servers: FfiConverterArrayString.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.roomId, into);
            FfiConverterArrayString.write(value.servers, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.roomId) +
                FfiConverterArrayString.allocationSize(value.servers);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link RoomDescription} record objects.
 */
export const RoomDescription = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link RoomDescription}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link RoomDescription}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeRoomDescription = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                roomId: FfiConverterString.read(from),
                name: FfiConverterOptionalString.read(from),
                topic: FfiConverterOptionalString.read(from),
                alias: FfiConverterOptionalString.read(from),
                avatarUrl: FfiConverterOptionalString.read(from),
                joinRule: FfiConverterOptionalTypePublicRoomJoinRule.read(from),
                isWorldReadable: FfiConverterBool.read(from),
                joinedMembers: FfiConverterUInt64.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.roomId, into);
            FfiConverterOptionalString.write(value.name, into);
            FfiConverterOptionalString.write(value.topic, into);
            FfiConverterOptionalString.write(value.alias, into);
            FfiConverterOptionalString.write(value.avatarUrl, into);
            FfiConverterOptionalTypePublicRoomJoinRule.write(value.joinRule, into);
            FfiConverterBool.write(value.isWorldReadable, into);
            FfiConverterUInt64.write(value.joinedMembers, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.roomId) +
                FfiConverterOptionalString.allocationSize(value.name) +
                FfiConverterOptionalString.allocationSize(value.topic) +
                FfiConverterOptionalString.allocationSize(value.alias) +
                FfiConverterOptionalString.allocationSize(value.avatarUrl) +
                FfiConverterOptionalTypePublicRoomJoinRule.allocationSize(value.joinRule) +
                FfiConverterBool.allocationSize(value.isWorldReadable) +
                FfiConverterUInt64.allocationSize(value.joinedMembers);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link RoomHero} record objects.
 */
export const RoomHero = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link RoomHero}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link RoomHero}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeRoomHero = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                userId: FfiConverterString.read(from),
                displayName: FfiConverterOptionalString.read(from),
                avatarUrl: FfiConverterOptionalString.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.userId, into);
            FfiConverterOptionalString.write(value.displayName, into);
            FfiConverterOptionalString.write(value.avatarUrl, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.userId) +
                FfiConverterOptionalString.allocationSize(value.displayName) +
                FfiConverterOptionalString.allocationSize(value.avatarUrl);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link RoomInfo} record objects.
 */
export const RoomInfo = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link RoomInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link RoomInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeRoomInfo = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                id: FfiConverterString.read(from),
                encryptionState: FfiConverterTypeEncryptionState.read(from),
                creators: FfiConverterOptionalArrayString.read(from),
                displayName: FfiConverterOptionalString.read(from),
                rawName: FfiConverterOptionalString.read(from),
                topic: FfiConverterOptionalString.read(from),
                avatarUrl: FfiConverterOptionalString.read(from),
                isDirect: FfiConverterBool.read(from),
                isPublic: FfiConverterOptionalBool.read(from),
                isSpace: FfiConverterBool.read(from),
                successorRoom: FfiConverterOptionalTypeSuccessorRoom.read(from),
                isFavourite: FfiConverterBool.read(from),
                canonicalAlias: FfiConverterOptionalString.read(from),
                alternativeAliases: FfiConverterArrayString.read(from),
                membership: FfiConverterTypeMembership.read(from),
                inviter: FfiConverterOptionalTypeRoomMember.read(from),
                heroes: FfiConverterArrayTypeRoomHero.read(from),
                activeMembersCount: FfiConverterUInt64.read(from),
                invitedMembersCount: FfiConverterUInt64.read(from),
                joinedMembersCount: FfiConverterUInt64.read(from),
                highlightCount: FfiConverterUInt64.read(from),
                notificationCount: FfiConverterUInt64.read(from),
                cachedUserDefinedNotificationMode: FfiConverterOptionalTypeRoomNotificationMode.read(from),
                hasRoomCall: FfiConverterBool.read(from),
                activeRoomCallParticipants: FfiConverterArrayString.read(from),
                isMarkedUnread: FfiConverterBool.read(from),
                numUnreadMessages: FfiConverterUInt64.read(from),
                numUnreadNotifications: FfiConverterUInt64.read(from),
                numUnreadMentions: FfiConverterUInt64.read(from),
                pinnedEventIds: FfiConverterArrayString.read(from),
                joinRule: FfiConverterOptionalTypeJoinRule.read(from),
                historyVisibility: FfiConverterTypeRoomHistoryVisibility.read(from),
                powerLevels: FfiConverterOptionalTypeRoomPowerLevels.read(from),
                roomVersion: FfiConverterOptionalString.read(from),
                privilegedCreatorsRole: FfiConverterBool.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.id, into);
            FfiConverterTypeEncryptionState.write(value.encryptionState, into);
            FfiConverterOptionalArrayString.write(value.creators, into);
            FfiConverterOptionalString.write(value.displayName, into);
            FfiConverterOptionalString.write(value.rawName, into);
            FfiConverterOptionalString.write(value.topic, into);
            FfiConverterOptionalString.write(value.avatarUrl, into);
            FfiConverterBool.write(value.isDirect, into);
            FfiConverterOptionalBool.write(value.isPublic, into);
            FfiConverterBool.write(value.isSpace, into);
            FfiConverterOptionalTypeSuccessorRoom.write(value.successorRoom, into);
            FfiConverterBool.write(value.isFavourite, into);
            FfiConverterOptionalString.write(value.canonicalAlias, into);
            FfiConverterArrayString.write(value.alternativeAliases, into);
            FfiConverterTypeMembership.write(value.membership, into);
            FfiConverterOptionalTypeRoomMember.write(value.inviter, into);
            FfiConverterArrayTypeRoomHero.write(value.heroes, into);
            FfiConverterUInt64.write(value.activeMembersCount, into);
            FfiConverterUInt64.write(value.invitedMembersCount, into);
            FfiConverterUInt64.write(value.joinedMembersCount, into);
            FfiConverterUInt64.write(value.highlightCount, into);
            FfiConverterUInt64.write(value.notificationCount, into);
            FfiConverterOptionalTypeRoomNotificationMode.write(value.cachedUserDefinedNotificationMode, into);
            FfiConverterBool.write(value.hasRoomCall, into);
            FfiConverterArrayString.write(value.activeRoomCallParticipants, into);
            FfiConverterBool.write(value.isMarkedUnread, into);
            FfiConverterUInt64.write(value.numUnreadMessages, into);
            FfiConverterUInt64.write(value.numUnreadNotifications, into);
            FfiConverterUInt64.write(value.numUnreadMentions, into);
            FfiConverterArrayString.write(value.pinnedEventIds, into);
            FfiConverterOptionalTypeJoinRule.write(value.joinRule, into);
            FfiConverterTypeRoomHistoryVisibility.write(value.historyVisibility, into);
            FfiConverterOptionalTypeRoomPowerLevels.write(value.powerLevels, into);
            FfiConverterOptionalString.write(value.roomVersion, into);
            FfiConverterBool.write(value.privilegedCreatorsRole, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.id) +
                FfiConverterTypeEncryptionState.allocationSize(value.encryptionState) +
                FfiConverterOptionalArrayString.allocationSize(value.creators) +
                FfiConverterOptionalString.allocationSize(value.displayName) +
                FfiConverterOptionalString.allocationSize(value.rawName) +
                FfiConverterOptionalString.allocationSize(value.topic) +
                FfiConverterOptionalString.allocationSize(value.avatarUrl) +
                FfiConverterBool.allocationSize(value.isDirect) +
                FfiConverterOptionalBool.allocationSize(value.isPublic) +
                FfiConverterBool.allocationSize(value.isSpace) +
                FfiConverterOptionalTypeSuccessorRoom.allocationSize(value.successorRoom) +
                FfiConverterBool.allocationSize(value.isFavourite) +
                FfiConverterOptionalString.allocationSize(value.canonicalAlias) +
                FfiConverterArrayString.allocationSize(value.alternativeAliases) +
                FfiConverterTypeMembership.allocationSize(value.membership) +
                FfiConverterOptionalTypeRoomMember.allocationSize(value.inviter) +
                FfiConverterArrayTypeRoomHero.allocationSize(value.heroes) +
                FfiConverterUInt64.allocationSize(value.activeMembersCount) +
                FfiConverterUInt64.allocationSize(value.invitedMembersCount) +
                FfiConverterUInt64.allocationSize(value.joinedMembersCount) +
                FfiConverterUInt64.allocationSize(value.highlightCount) +
                FfiConverterUInt64.allocationSize(value.notificationCount) +
                FfiConverterOptionalTypeRoomNotificationMode.allocationSize(value.cachedUserDefinedNotificationMode) +
                FfiConverterBool.allocationSize(value.hasRoomCall) +
                FfiConverterArrayString.allocationSize(value.activeRoomCallParticipants) +
                FfiConverterBool.allocationSize(value.isMarkedUnread) +
                FfiConverterUInt64.allocationSize(value.numUnreadMessages) +
                FfiConverterUInt64.allocationSize(value.numUnreadNotifications) +
                FfiConverterUInt64.allocationSize(value.numUnreadMentions) +
                FfiConverterArrayString.allocationSize(value.pinnedEventIds) +
                FfiConverterOptionalTypeJoinRule.allocationSize(value.joinRule) +
                FfiConverterTypeRoomHistoryVisibility.allocationSize(value.historyVisibility) +
                FfiConverterOptionalTypeRoomPowerLevels.allocationSize(value.powerLevels) +
                FfiConverterOptionalString.allocationSize(value.roomVersion) +
                FfiConverterBool.allocationSize(value.privilegedCreatorsRole);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link RoomListLoadingStateResult} record objects.
 */
export const RoomListLoadingStateResult = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link RoomListLoadingStateResult}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link RoomListLoadingStateResult}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeRoomListLoadingStateResult = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                state: FfiConverterTypeRoomListLoadingState.read(from),
                stateStream: FfiConverterTypeTaskHandle.read(from)
            };
        }
        write(value, into) {
            FfiConverterTypeRoomListLoadingState.write(value.state, into);
            FfiConverterTypeTaskHandle.write(value.stateStream, into);
        }
        allocationSize(value) {
            return FfiConverterTypeRoomListLoadingState.allocationSize(value.state) +
                FfiConverterTypeTaskHandle.allocationSize(value.stateStream);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link RoomMember} record objects.
 */
export const RoomMember = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link RoomMember}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link RoomMember}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeRoomMember = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                userId: FfiConverterString.read(from),
                displayName: FfiConverterOptionalString.read(from),
                avatarUrl: FfiConverterOptionalString.read(from),
                membership: FfiConverterTypeMembershipState.read(from),
                isNameAmbiguous: FfiConverterBool.read(from),
                powerLevel: FfiConverterTypePowerLevel.read(from),
                isIgnored: FfiConverterBool.read(from),
                suggestedRoleForPowerLevel: FfiConverterTypeRoomMemberRole.read(from),
                membershipChangeReason: FfiConverterOptionalString.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.userId, into);
            FfiConverterOptionalString.write(value.displayName, into);
            FfiConverterOptionalString.write(value.avatarUrl, into);
            FfiConverterTypeMembershipState.write(value.membership, into);
            FfiConverterBool.write(value.isNameAmbiguous, into);
            FfiConverterTypePowerLevel.write(value.powerLevel, into);
            FfiConverterBool.write(value.isIgnored, into);
            FfiConverterTypeRoomMemberRole.write(value.suggestedRoleForPowerLevel, into);
            FfiConverterOptionalString.write(value.membershipChangeReason, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.userId) +
                FfiConverterOptionalString.allocationSize(value.displayName) +
                FfiConverterOptionalString.allocationSize(value.avatarUrl) +
                FfiConverterTypeMembershipState.allocationSize(value.membership) +
                FfiConverterBool.allocationSize(value.isNameAmbiguous) +
                FfiConverterTypePowerLevel.allocationSize(value.powerLevel) +
                FfiConverterBool.allocationSize(value.isIgnored) +
                FfiConverterTypeRoomMemberRole.allocationSize(value.suggestedRoleForPowerLevel) +
                FfiConverterOptionalString.allocationSize(value.membershipChangeReason);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link RoomMemberWithSenderInfo} record objects.
 */
export const RoomMemberWithSenderInfo = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link RoomMemberWithSenderInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link RoomMemberWithSenderInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeRoomMemberWithSenderInfo = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                roomMember: FfiConverterTypeRoomMember.read(from),
                senderInfo: FfiConverterOptionalTypeRoomMember.read(from)
            };
        }
        write(value, into) {
            FfiConverterTypeRoomMember.write(value.roomMember, into);
            FfiConverterOptionalTypeRoomMember.write(value.senderInfo, into);
        }
        allocationSize(value) {
            return FfiConverterTypeRoomMember.allocationSize(value.roomMember) +
                FfiConverterOptionalTypeRoomMember.allocationSize(value.senderInfo);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link RoomNotificationSettings} record objects.
 */
export const RoomNotificationSettings = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link RoomNotificationSettings}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link RoomNotificationSettings}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeRoomNotificationSettings = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                mode: FfiConverterTypeRoomNotificationMode.read(from),
                isDefault: FfiConverterBool.read(from)
            };
        }
        write(value, into) {
            FfiConverterTypeRoomNotificationMode.write(value.mode, into);
            FfiConverterBool.write(value.isDefault, into);
        }
        allocationSize(value) {
            return FfiConverterTypeRoomNotificationMode.allocationSize(value.mode) +
                FfiConverterBool.allocationSize(value.isDefault);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link RoomPowerLevelsValues} record objects.
 */
export const RoomPowerLevelsValues = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link RoomPowerLevelsValues}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link RoomPowerLevelsValues}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeRoomPowerLevelsValues = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                ban: FfiConverterInt64.read(from),
                invite: FfiConverterInt64.read(from),
                kick: FfiConverterInt64.read(from),
                redact: FfiConverterInt64.read(from),
                eventsDefault: FfiConverterInt64.read(from),
                stateDefault: FfiConverterInt64.read(from),
                usersDefault: FfiConverterInt64.read(from),
                roomName: FfiConverterInt64.read(from),
                roomAvatar: FfiConverterInt64.read(from),
                roomTopic: FfiConverterInt64.read(from),
                spaceChild: FfiConverterInt64.read(from)
            };
        }
        write(value, into) {
            FfiConverterInt64.write(value.ban, into);
            FfiConverterInt64.write(value.invite, into);
            FfiConverterInt64.write(value.kick, into);
            FfiConverterInt64.write(value.redact, into);
            FfiConverterInt64.write(value.eventsDefault, into);
            FfiConverterInt64.write(value.stateDefault, into);
            FfiConverterInt64.write(value.usersDefault, into);
            FfiConverterInt64.write(value.roomName, into);
            FfiConverterInt64.write(value.roomAvatar, into);
            FfiConverterInt64.write(value.roomTopic, into);
            FfiConverterInt64.write(value.spaceChild, into);
        }
        allocationSize(value) {
            return FfiConverterInt64.allocationSize(value.ban) +
                FfiConverterInt64.allocationSize(value.invite) +
                FfiConverterInt64.allocationSize(value.kick) +
                FfiConverterInt64.allocationSize(value.redact) +
                FfiConverterInt64.allocationSize(value.eventsDefault) +
                FfiConverterInt64.allocationSize(value.stateDefault) +
                FfiConverterInt64.allocationSize(value.usersDefault) +
                FfiConverterInt64.allocationSize(value.roomName) +
                FfiConverterInt64.allocationSize(value.roomAvatar) +
                FfiConverterInt64.allocationSize(value.roomTopic) +
                FfiConverterInt64.allocationSize(value.spaceChild);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link RoomPreviewInfo} record objects.
 */
export const RoomPreviewInfo = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link RoomPreviewInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link RoomPreviewInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeRoomPreviewInfo = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                roomId: FfiConverterString.read(from),
                canonicalAlias: FfiConverterOptionalString.read(from),
                name: FfiConverterOptionalString.read(from),
                topic: FfiConverterOptionalString.read(from),
                avatarUrl: FfiConverterOptionalString.read(from),
                numJoinedMembers: FfiConverterUInt64.read(from),
                numActiveMembers: FfiConverterOptionalUInt64.read(from),
                roomType: FfiConverterTypeRoomType.read(from),
                isHistoryWorldReadable: FfiConverterOptionalBool.read(from),
                membership: FfiConverterOptionalTypeMembership.read(from),
                joinRule: FfiConverterOptionalTypeJoinRule.read(from),
                isDirect: FfiConverterOptionalBool.read(from),
                heroes: FfiConverterOptionalArrayTypeRoomHero.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.roomId, into);
            FfiConverterOptionalString.write(value.canonicalAlias, into);
            FfiConverterOptionalString.write(value.name, into);
            FfiConverterOptionalString.write(value.topic, into);
            FfiConverterOptionalString.write(value.avatarUrl, into);
            FfiConverterUInt64.write(value.numJoinedMembers, into);
            FfiConverterOptionalUInt64.write(value.numActiveMembers, into);
            FfiConverterTypeRoomType.write(value.roomType, into);
            FfiConverterOptionalBool.write(value.isHistoryWorldReadable, into);
            FfiConverterOptionalTypeMembership.write(value.membership, into);
            FfiConverterOptionalTypeJoinRule.write(value.joinRule, into);
            FfiConverterOptionalBool.write(value.isDirect, into);
            FfiConverterOptionalArrayTypeRoomHero.write(value.heroes, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.roomId) +
                FfiConverterOptionalString.allocationSize(value.canonicalAlias) +
                FfiConverterOptionalString.allocationSize(value.name) +
                FfiConverterOptionalString.allocationSize(value.topic) +
                FfiConverterOptionalString.allocationSize(value.avatarUrl) +
                FfiConverterUInt64.allocationSize(value.numJoinedMembers) +
                FfiConverterOptionalUInt64.allocationSize(value.numActiveMembers) +
                FfiConverterTypeRoomType.allocationSize(value.roomType) +
                FfiConverterOptionalBool.allocationSize(value.isHistoryWorldReadable) +
                FfiConverterOptionalTypeMembership.allocationSize(value.membership) +
                FfiConverterOptionalTypeJoinRule.allocationSize(value.joinRule) +
                FfiConverterOptionalBool.allocationSize(value.isDirect) +
                FfiConverterOptionalArrayTypeRoomHero.allocationSize(value.heroes);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link Ruleset} record objects.
 */
export const Ruleset = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Ruleset}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link Ruleset}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeRuleset = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                content: FfiConverterArrayTypePatternedPushRule.read(from),
                override: FfiConverterArrayTypeConditionalPushRule.read(from),
                room: FfiConverterArrayTypeSimplePushRule.read(from),
                sender: FfiConverterArrayTypeSimplePushRule.read(from),
                underride: FfiConverterArrayTypeConditionalPushRule.read(from)
            };
        }
        write(value, into) {
            FfiConverterArrayTypePatternedPushRule.write(value.content, into);
            FfiConverterArrayTypeConditionalPushRule.write(value.override, into);
            FfiConverterArrayTypeSimplePushRule.write(value.room, into);
            FfiConverterArrayTypeSimplePushRule.write(value.sender, into);
            FfiConverterArrayTypeConditionalPushRule.write(value.underride, into);
        }
        allocationSize(value) {
            return FfiConverterArrayTypePatternedPushRule.allocationSize(value.content) +
                FfiConverterArrayTypeConditionalPushRule.allocationSize(value.override) +
                FfiConverterArrayTypeSimplePushRule.allocationSize(value.room) +
                FfiConverterArrayTypeSimplePushRule.allocationSize(value.sender) +
                FfiConverterArrayTypeConditionalPushRule.allocationSize(value.underride);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link SearchUsersResults} record objects.
 */
export const SearchUsersResults = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link SearchUsersResults}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link SearchUsersResults}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeSearchUsersResults = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                results: FfiConverterArrayTypeUserProfile.read(from),
                limited: FfiConverterBool.read(from)
            };
        }
        write(value, into) {
            FfiConverterArrayTypeUserProfile.write(value.results, into);
            FfiConverterBool.write(value.limited, into);
        }
        allocationSize(value) {
            return FfiConverterArrayTypeUserProfile.allocationSize(value.results) +
                FfiConverterBool.allocationSize(value.limited);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link SecretStorageV1AesHmacSha2Properties} record objects.
 */
export const SecretStorageV1AesHmacSha2Properties = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link SecretStorageV1AesHmacSha2Properties}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link SecretStorageV1AesHmacSha2Properties}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeSecretStorageV1AesHmacSha2Properties = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                iv: FfiConverterOptionalString.read(from),
                mac: FfiConverterOptionalString.read(from)
            };
        }
        write(value, into) {
            FfiConverterOptionalString.write(value.iv, into);
            FfiConverterOptionalString.write(value.mac, into);
        }
        allocationSize(value) {
            return FfiConverterOptionalString.allocationSize(value.iv) +
                FfiConverterOptionalString.allocationSize(value.mac);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link Session} record objects.
 */
export const Session = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Session}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link Session}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeSession = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                accessToken: FfiConverterString.read(from),
                refreshToken: FfiConverterOptionalString.read(from),
                userId: FfiConverterString.read(from),
                deviceId: FfiConverterString.read(from),
                homeserverUrl: FfiConverterString.read(from),
                oidcData: FfiConverterOptionalString.read(from),
                slidingSyncVersion: FfiConverterTypeSlidingSyncVersion.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.accessToken, into);
            FfiConverterOptionalString.write(value.refreshToken, into);
            FfiConverterString.write(value.userId, into);
            FfiConverterString.write(value.deviceId, into);
            FfiConverterString.write(value.homeserverUrl, into);
            FfiConverterOptionalString.write(value.oidcData, into);
            FfiConverterTypeSlidingSyncVersion.write(value.slidingSyncVersion, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.accessToken) +
                FfiConverterOptionalString.allocationSize(value.refreshToken) +
                FfiConverterString.allocationSize(value.userId) +
                FfiConverterString.allocationSize(value.deviceId) +
                FfiConverterString.allocationSize(value.homeserverUrl) +
                FfiConverterOptionalString.allocationSize(value.oidcData) +
                FfiConverterTypeSlidingSyncVersion.allocationSize(value.slidingSyncVersion);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link SessionVerificationRequestDetails} record objects.
 */
export const SessionVerificationRequestDetails = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link SessionVerificationRequestDetails}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link SessionVerificationRequestDetails}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeSessionVerificationRequestDetails = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                senderProfile: FfiConverterTypeUserProfile.read(from),
                flowId: FfiConverterString.read(from),
                deviceId: FfiConverterString.read(from),
                deviceDisplayName: FfiConverterOptionalString.read(from),
                firstSeenTimestamp: FfiConverterTypeTimestamp.read(from)
            };
        }
        write(value, into) {
            FfiConverterTypeUserProfile.write(value.senderProfile, into);
            FfiConverterString.write(value.flowId, into);
            FfiConverterString.write(value.deviceId, into);
            FfiConverterOptionalString.write(value.deviceDisplayName, into);
            FfiConverterTypeTimestamp.write(value.firstSeenTimestamp, into);
        }
        allocationSize(value) {
            return FfiConverterTypeUserProfile.allocationSize(value.senderProfile) +
                FfiConverterString.allocationSize(value.flowId) +
                FfiConverterString.allocationSize(value.deviceId) +
                FfiConverterOptionalString.allocationSize(value.deviceDisplayName) +
                FfiConverterTypeTimestamp.allocationSize(value.firstSeenTimestamp);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link SimplePushRule} record objects.
 */
export const SimplePushRule = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link SimplePushRule}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link SimplePushRule}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeSimplePushRule = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                actions: FfiConverterArrayTypeAction.read(from),
                default_: FfiConverterBool.read(from),
                enabled: FfiConverterBool.read(from),
                ruleId: FfiConverterString.read(from)
            };
        }
        write(value, into) {
            FfiConverterArrayTypeAction.write(value.actions, into);
            FfiConverterBool.write(value.default_, into);
            FfiConverterBool.write(value.enabled, into);
            FfiConverterString.write(value.ruleId, into);
        }
        allocationSize(value) {
            return FfiConverterArrayTypeAction.allocationSize(value.actions) +
                FfiConverterBool.allocationSize(value.default_) +
                FfiConverterBool.allocationSize(value.enabled) +
                FfiConverterString.allocationSize(value.ruleId);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link SpaceRoom} record objects.
 */
export const SpaceRoom = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link SpaceRoom}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link SpaceRoom}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeSpaceRoom = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                roomId: FfiConverterString.read(from),
                canonicalAlias: FfiConverterOptionalString.read(from),
                displayName: FfiConverterString.read(from),
                rawName: FfiConverterOptionalString.read(from),
                topic: FfiConverterOptionalString.read(from),
                avatarUrl: FfiConverterOptionalString.read(from),
                roomType: FfiConverterTypeRoomType.read(from),
                numJoinedMembers: FfiConverterUInt64.read(from),
                joinRule: FfiConverterOptionalTypeJoinRule.read(from),
                worldReadable: FfiConverterOptionalBool.read(from),
                guestCanJoin: FfiConverterBool.read(from),
                isDirect: FfiConverterOptionalBool.read(from),
                childrenCount: FfiConverterUInt64.read(from),
                state: FfiConverterOptionalTypeMembership.read(from),
                heroes: FfiConverterOptionalArrayTypeRoomHero.read(from),
                via: FfiConverterArrayString.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.roomId, into);
            FfiConverterOptionalString.write(value.canonicalAlias, into);
            FfiConverterString.write(value.displayName, into);
            FfiConverterOptionalString.write(value.rawName, into);
            FfiConverterOptionalString.write(value.topic, into);
            FfiConverterOptionalString.write(value.avatarUrl, into);
            FfiConverterTypeRoomType.write(value.roomType, into);
            FfiConverterUInt64.write(value.numJoinedMembers, into);
            FfiConverterOptionalTypeJoinRule.write(value.joinRule, into);
            FfiConverterOptionalBool.write(value.worldReadable, into);
            FfiConverterBool.write(value.guestCanJoin, into);
            FfiConverterOptionalBool.write(value.isDirect, into);
            FfiConverterUInt64.write(value.childrenCount, into);
            FfiConverterOptionalTypeMembership.write(value.state, into);
            FfiConverterOptionalArrayTypeRoomHero.write(value.heroes, into);
            FfiConverterArrayString.write(value.via, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.roomId) +
                FfiConverterOptionalString.allocationSize(value.canonicalAlias) +
                FfiConverterString.allocationSize(value.displayName) +
                FfiConverterOptionalString.allocationSize(value.rawName) +
                FfiConverterOptionalString.allocationSize(value.topic) +
                FfiConverterOptionalString.allocationSize(value.avatarUrl) +
                FfiConverterTypeRoomType.allocationSize(value.roomType) +
                FfiConverterUInt64.allocationSize(value.numJoinedMembers) +
                FfiConverterOptionalTypeJoinRule.allocationSize(value.joinRule) +
                FfiConverterOptionalBool.allocationSize(value.worldReadable) +
                FfiConverterBool.allocationSize(value.guestCanJoin) +
                FfiConverterOptionalBool.allocationSize(value.isDirect) +
                FfiConverterUInt64.allocationSize(value.childrenCount) +
                FfiConverterOptionalTypeMembership.allocationSize(value.state) +
                FfiConverterOptionalArrayTypeRoomHero.allocationSize(value.heroes) +
                FfiConverterArrayString.allocationSize(value.via);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link SuccessorRoom} record objects.
 */
export const SuccessorRoom = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link SuccessorRoom}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link SuccessorRoom}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeSuccessorRoom = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                roomId: FfiConverterString.read(from),
                reason: FfiConverterOptionalString.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.roomId, into);
            FfiConverterOptionalString.write(value.reason, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.roomId) +
                FfiConverterOptionalString.allocationSize(value.reason);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link TagInfo} record objects.
 */
export const TagInfo = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link TagInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link TagInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeTagInfo = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                order: FfiConverterOptionalFloat64.read(from)
            };
        }
        write(value, into) {
            FfiConverterOptionalFloat64.write(value.order, into);
        }
        allocationSize(value) {
            return FfiConverterOptionalFloat64.allocationSize(value.order);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link TextMessageContent} record objects.
 */
export const TextMessageContent = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link TextMessageContent}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link TextMessageContent}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeTextMessageContent = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                body: FfiConverterString.read(from),
                formatted: FfiConverterOptionalTypeFormattedBody.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.body, into);
            FfiConverterOptionalTypeFormattedBody.write(value.formatted, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.body) +
                FfiConverterOptionalTypeFormattedBody.allocationSize(value.formatted);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link ThreadSubscription} record objects.
 */
export const ThreadSubscription = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link ThreadSubscription}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link ThreadSubscription}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeThreadSubscription = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                automatic: FfiConverterBool.read(from)
            };
        }
        write(value, into) {
            FfiConverterBool.write(value.automatic, into);
        }
        allocationSize(value) {
            return FfiConverterBool.allocationSize(value.automatic);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link ThumbnailInfo} record objects.
 */
export const ThumbnailInfo = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link ThumbnailInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link ThumbnailInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeThumbnailInfo = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                height: FfiConverterOptionalUInt64.read(from),
                width: FfiConverterOptionalUInt64.read(from),
                mimetype: FfiConverterOptionalString.read(from),
                size: FfiConverterOptionalUInt64.read(from)
            };
        }
        write(value, into) {
            FfiConverterOptionalUInt64.write(value.height, into);
            FfiConverterOptionalUInt64.write(value.width, into);
            FfiConverterOptionalString.write(value.mimetype, into);
            FfiConverterOptionalUInt64.write(value.size, into);
        }
        allocationSize(value) {
            return FfiConverterOptionalUInt64.allocationSize(value.height) +
                FfiConverterOptionalUInt64.allocationSize(value.width) +
                FfiConverterOptionalString.allocationSize(value.mimetype) +
                FfiConverterOptionalUInt64.allocationSize(value.size);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link TimelineConfiguration} record objects.
 */
export const TimelineConfiguration = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link TimelineConfiguration}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link TimelineConfiguration}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeTimelineConfiguration = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                focus: FfiConverterTypeTimelineFocus.read(from),
                filter: FfiConverterTypeTimelineFilter.read(from),
                internalIdPrefix: FfiConverterOptionalString.read(from),
                dateDividerMode: FfiConverterTypeDateDividerMode.read(from),
                trackReadReceipts: FfiConverterBool.read(from),
                reportUtds: FfiConverterBool.read(from)
            };
        }
        write(value, into) {
            FfiConverterTypeTimelineFocus.write(value.focus, into);
            FfiConverterTypeTimelineFilter.write(value.filter, into);
            FfiConverterOptionalString.write(value.internalIdPrefix, into);
            FfiConverterTypeDateDividerMode.write(value.dateDividerMode, into);
            FfiConverterBool.write(value.trackReadReceipts, into);
            FfiConverterBool.write(value.reportUtds, into);
        }
        allocationSize(value) {
            return FfiConverterTypeTimelineFocus.allocationSize(value.focus) +
                FfiConverterTypeTimelineFilter.allocationSize(value.filter) +
                FfiConverterOptionalString.allocationSize(value.internalIdPrefix) +
                FfiConverterTypeDateDividerMode.allocationSize(value.dateDividerMode) +
                FfiConverterBool.allocationSize(value.trackReadReceipts) +
                FfiConverterBool.allocationSize(value.reportUtds);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link TimelineUniqueId} record objects.
 */
export const TimelineUniqueId = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link TimelineUniqueId}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link TimelineUniqueId}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeTimelineUniqueId = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                id: FfiConverterString.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.id, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.id);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link TracingConfiguration} record objects.
 */
export const TracingConfiguration = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link TracingConfiguration}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link TracingConfiguration}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeTracingConfiguration = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                logLevel: FfiConverterTypeLogLevel.read(from),
                traceLogPacks: FfiConverterArrayTypeTraceLogPacks.read(from),
                extraTargets: FfiConverterArrayString.read(from),
                writeToStdoutOrSystem: FfiConverterBool.read(from),
                writeToFiles: FfiConverterOptionalTypeTracingFileConfiguration.read(from)
            };
        }
        write(value, into) {
            FfiConverterTypeLogLevel.write(value.logLevel, into);
            FfiConverterArrayTypeTraceLogPacks.write(value.traceLogPacks, into);
            FfiConverterArrayString.write(value.extraTargets, into);
            FfiConverterBool.write(value.writeToStdoutOrSystem, into);
            FfiConverterOptionalTypeTracingFileConfiguration.write(value.writeToFiles, into);
        }
        allocationSize(value) {
            return FfiConverterTypeLogLevel.allocationSize(value.logLevel) +
                FfiConverterArrayTypeTraceLogPacks.allocationSize(value.traceLogPacks) +
                FfiConverterArrayString.allocationSize(value.extraTargets) +
                FfiConverterBool.allocationSize(value.writeToStdoutOrSystem) +
                FfiConverterOptionalTypeTracingFileConfiguration.allocationSize(value.writeToFiles);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link TracingFileConfiguration} record objects.
 */
export const TracingFileConfiguration = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link TracingFileConfiguration}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link TracingFileConfiguration}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeTracingFileConfiguration = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                path: FfiConverterString.read(from),
                filePrefix: FfiConverterString.read(from),
                fileSuffix: FfiConverterOptionalString.read(from),
                maxFiles: FfiConverterOptionalUInt64.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.path, into);
            FfiConverterString.write(value.filePrefix, into);
            FfiConverterOptionalString.write(value.fileSuffix, into);
            FfiConverterOptionalUInt64.write(value.maxFiles, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.path) +
                FfiConverterString.allocationSize(value.filePrefix) +
                FfiConverterOptionalString.allocationSize(value.fileSuffix) +
                FfiConverterOptionalUInt64.allocationSize(value.maxFiles);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link TransmissionProgress} record objects.
 */
export const TransmissionProgress = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link TransmissionProgress}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link TransmissionProgress}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeTransmissionProgress = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                current: FfiConverterUInt64.read(from),
                total: FfiConverterUInt64.read(from)
            };
        }
        write(value, into) {
            FfiConverterUInt64.write(value.current, into);
            FfiConverterUInt64.write(value.total, into);
        }
        allocationSize(value) {
            return FfiConverterUInt64.allocationSize(value.current) +
                FfiConverterUInt64.allocationSize(value.total);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link UnableToDecryptInfo} record objects.
 */
export const UnableToDecryptInfo = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link UnableToDecryptInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link UnableToDecryptInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeUnableToDecryptInfo = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                eventId: FfiConverterString.read(from),
                timeToDecryptMs: FfiConverterOptionalUInt64.read(from),
                cause: FfiConverterTypeUtdCause.read(from),
                eventLocalAgeMillis: FfiConverterInt64.read(from),
                userTrustsOwnIdentity: FfiConverterBool.read(from),
                senderHomeserver: FfiConverterString.read(from),
                ownHomeserver: FfiConverterOptionalString.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.eventId, into);
            FfiConverterOptionalUInt64.write(value.timeToDecryptMs, into);
            FfiConverterTypeUtdCause.write(value.cause, into);
            FfiConverterInt64.write(value.eventLocalAgeMillis, into);
            FfiConverterBool.write(value.userTrustsOwnIdentity, into);
            FfiConverterString.write(value.senderHomeserver, into);
            FfiConverterOptionalString.write(value.ownHomeserver, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.eventId) +
                FfiConverterOptionalUInt64.allocationSize(value.timeToDecryptMs) +
                FfiConverterTypeUtdCause.allocationSize(value.cause) +
                FfiConverterInt64.allocationSize(value.eventLocalAgeMillis) +
                FfiConverterBool.allocationSize(value.userTrustsOwnIdentity) +
                FfiConverterString.allocationSize(value.senderHomeserver) +
                FfiConverterOptionalString.allocationSize(value.ownHomeserver);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link UnstableAudioDetailsContent} record objects.
 */
export const UnstableAudioDetailsContent = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link UnstableAudioDetailsContent}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link UnstableAudioDetailsContent}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeUnstableAudioDetailsContent = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                duration: FfiConverterDuration.read(from),
                waveform: FfiConverterArrayUInt16.read(from)
            };
        }
        write(value, into) {
            FfiConverterDuration.write(value.duration, into);
            FfiConverterArrayUInt16.write(value.waveform, into);
        }
        allocationSize(value) {
            return FfiConverterDuration.allocationSize(value.duration) +
                FfiConverterArrayUInt16.allocationSize(value.waveform);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link UnstableVoiceContent} record objects.
 */
export const UnstableVoiceContent = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link UnstableVoiceContent}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link UnstableVoiceContent}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeUnstableVoiceContent = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {};
        }
        write(value, into) {
        }
        allocationSize(value) {
            return 0;
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link UploadParameters} record objects.
 */
export const UploadParameters = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link UploadParameters}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link UploadParameters}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeUploadParameters = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                source: FfiConverterTypeUploadSource.read(from),
                caption: FfiConverterOptionalString.read(from),
                formattedCaption: FfiConverterOptionalTypeFormattedBody.read(from),
                mentions: FfiConverterOptionalTypeMentions.read(from),
                inReplyTo: FfiConverterOptionalString.read(from)
            };
        }
        write(value, into) {
            FfiConverterTypeUploadSource.write(value.source, into);
            FfiConverterOptionalString.write(value.caption, into);
            FfiConverterOptionalTypeFormattedBody.write(value.formattedCaption, into);
            FfiConverterOptionalTypeMentions.write(value.mentions, into);
            FfiConverterOptionalString.write(value.inReplyTo, into);
        }
        allocationSize(value) {
            return FfiConverterTypeUploadSource.allocationSize(value.source) +
                FfiConverterOptionalString.allocationSize(value.caption) +
                FfiConverterOptionalTypeFormattedBody.allocationSize(value.formattedCaption) +
                FfiConverterOptionalTypeMentions.allocationSize(value.mentions) +
                FfiConverterOptionalString.allocationSize(value.inReplyTo);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link UserPowerLevelUpdate} record objects.
 */
export const UserPowerLevelUpdate = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link UserPowerLevelUpdate}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link UserPowerLevelUpdate}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeUserPowerLevelUpdate = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                userId: FfiConverterString.read(from),
                powerLevel: FfiConverterInt64.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.userId, into);
            FfiConverterInt64.write(value.powerLevel, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.userId) +
                FfiConverterInt64.allocationSize(value.powerLevel);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link UserProfile} record objects.
 */
export const UserProfile = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link UserProfile}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link UserProfile}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeUserProfile = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                userId: FfiConverterString.read(from),
                displayName: FfiConverterOptionalString.read(from),
                avatarUrl: FfiConverterOptionalString.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.userId, into);
            FfiConverterOptionalString.write(value.displayName, into);
            FfiConverterOptionalString.write(value.avatarUrl, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.userId) +
                FfiConverterOptionalString.allocationSize(value.displayName) +
                FfiConverterOptionalString.allocationSize(value.avatarUrl);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link UserTagName} record objects.
 */
export const UserTagName = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link UserTagName}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link UserTagName}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeUserTagName = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                name: FfiConverterString.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.name, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.name);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link VideoInfo} record objects.
 */
export const VideoInfo = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link VideoInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link VideoInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeVideoInfo = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                duration: FfiConverterOptionalDuration.read(from),
                height: FfiConverterOptionalUInt64.read(from),
                width: FfiConverterOptionalUInt64.read(from),
                mimetype: FfiConverterOptionalString.read(from),
                size: FfiConverterOptionalUInt64.read(from),
                thumbnailInfo: FfiConverterOptionalTypeThumbnailInfo.read(from),
                thumbnailSource: FfiConverterOptionalTypeMediaSource.read(from),
                blurhash: FfiConverterOptionalString.read(from)
            };
        }
        write(value, into) {
            FfiConverterOptionalDuration.write(value.duration, into);
            FfiConverterOptionalUInt64.write(value.height, into);
            FfiConverterOptionalUInt64.write(value.width, into);
            FfiConverterOptionalString.write(value.mimetype, into);
            FfiConverterOptionalUInt64.write(value.size, into);
            FfiConverterOptionalTypeThumbnailInfo.write(value.thumbnailInfo, into);
            FfiConverterOptionalTypeMediaSource.write(value.thumbnailSource, into);
            FfiConverterOptionalString.write(value.blurhash, into);
        }
        allocationSize(value) {
            return FfiConverterOptionalDuration.allocationSize(value.duration) +
                FfiConverterOptionalUInt64.allocationSize(value.height) +
                FfiConverterOptionalUInt64.allocationSize(value.width) +
                FfiConverterOptionalString.allocationSize(value.mimetype) +
                FfiConverterOptionalUInt64.allocationSize(value.size) +
                FfiConverterOptionalTypeThumbnailInfo.allocationSize(value.thumbnailInfo) +
                FfiConverterOptionalTypeMediaSource.allocationSize(value.thumbnailSource) +
                FfiConverterOptionalString.allocationSize(value.blurhash);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link VideoMessageContent} record objects.
 */
export const VideoMessageContent = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link VideoMessageContent}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link VideoMessageContent}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeVideoMessageContent = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                filename: FfiConverterString.read(from),
                caption: FfiConverterOptionalString.read(from),
                formattedCaption: FfiConverterOptionalTypeFormattedBody.read(from),
                source: FfiConverterTypeMediaSource.read(from),
                info: FfiConverterOptionalTypeVideoInfo.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.filename, into);
            FfiConverterOptionalString.write(value.caption, into);
            FfiConverterOptionalTypeFormattedBody.write(value.formattedCaption, into);
            FfiConverterTypeMediaSource.write(value.source, into);
            FfiConverterOptionalTypeVideoInfo.write(value.info, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.filename) +
                FfiConverterOptionalString.allocationSize(value.caption) +
                FfiConverterOptionalTypeFormattedBody.allocationSize(value.formattedCaption) +
                FfiConverterTypeMediaSource.allocationSize(value.source) +
                FfiConverterOptionalTypeVideoInfo.allocationSize(value.info);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link WidgetCapabilities} record objects.
 */
export const WidgetCapabilities = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link WidgetCapabilities}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link WidgetCapabilities}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeWidgetCapabilities = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                read: FfiConverterArrayTypeWidgetEventFilter.read(from),
                send: FfiConverterArrayTypeWidgetEventFilter.read(from),
                requiresClient: FfiConverterBool.read(from),
                updateDelayedEvent: FfiConverterBool.read(from),
                sendDelayedEvent: FfiConverterBool.read(from)
            };
        }
        write(value, into) {
            FfiConverterArrayTypeWidgetEventFilter.write(value.read, into);
            FfiConverterArrayTypeWidgetEventFilter.write(value.send, into);
            FfiConverterBool.write(value.requiresClient, into);
            FfiConverterBool.write(value.updateDelayedEvent, into);
            FfiConverterBool.write(value.sendDelayedEvent, into);
        }
        allocationSize(value) {
            return FfiConverterArrayTypeWidgetEventFilter.allocationSize(value.read) +
                FfiConverterArrayTypeWidgetEventFilter.allocationSize(value.send) +
                FfiConverterBool.allocationSize(value.requiresClient) +
                FfiConverterBool.allocationSize(value.updateDelayedEvent) +
                FfiConverterBool.allocationSize(value.sendDelayedEvent);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link WidgetDriverAndHandle} record objects.
 */
export const WidgetDriverAndHandle = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link WidgetDriverAndHandle}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link WidgetDriverAndHandle}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeWidgetDriverAndHandle = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                driver: FfiConverterTypeWidgetDriver.read(from),
                handle: FfiConverterTypeWidgetDriverHandle.read(from)
            };
        }
        write(value, into) {
            FfiConverterTypeWidgetDriver.write(value.driver, into);
            FfiConverterTypeWidgetDriverHandle.write(value.handle, into);
        }
        allocationSize(value) {
            return FfiConverterTypeWidgetDriver.allocationSize(value.driver) +
                FfiConverterTypeWidgetDriverHandle.allocationSize(value.handle);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link WidgetSettings} record objects.
 */
export const WidgetSettings = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link WidgetSettings}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link WidgetSettings}, with defaults specified
         * in Rust, in the {@link matrix_sdk_ffi} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_ffi} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeWidgetSettings = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                widgetId: FfiConverterString.read(from),
                initAfterContentLoad: FfiConverterBool.read(from),
                rawUrl: FfiConverterString.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.widgetId, into);
            FfiConverterBool.write(value.initAfterContentLoad, into);
            FfiConverterString.write(value.rawUrl, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.widgetId) +
                FfiConverterBool.allocationSize(value.initAfterContentLoad) +
                FfiConverterString.allocationSize(value.rawUrl);
        }
    }
    ;
    return new FFIConverter();
})();
const stringConverter = (() => {
    const encoder = new TextEncoder();
    const decoder = new TextDecoder();
    return {
        stringToBytes: (s) => encoder.encode(s),
        bytesToString: (ab) => decoder.decode(ab),
        stringByteLength: (s) => encoder.encode(s).byteLength,
    };
})();
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);
// FfiConverter for Timestamp, a type alias for /*u64*/bigint.
const FfiConverterTypeTimestamp = FfiConverterUInt64;
// Enum: AccountDataEvent
export var AccountDataEvent_Tags;
(function (AccountDataEvent_Tags) {
    AccountDataEvent_Tags["Direct"] = "Direct";
    AccountDataEvent_Tags["IdentityServer"] = "IdentityServer";
    AccountDataEvent_Tags["IgnoredUserList"] = "IgnoredUserList";
    AccountDataEvent_Tags["PushRules"] = "PushRules";
    AccountDataEvent_Tags["SecretStorageDefaultKey"] = "SecretStorageDefaultKey";
    AccountDataEvent_Tags["SecretStorageKey"] = "SecretStorageKey";
})(AccountDataEvent_Tags || (AccountDataEvent_Tags = {}));
/**
 * Global account data events.
 */
export const AccountDataEvent = (() => {
    /**
     * m.direct
     */
    class Direct_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "AccountDataEvent";
        tag = AccountDataEvent_Tags.Direct;
        inner;
        constructor(inner) {
            super("AccountDataEvent", "Direct");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Direct_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === AccountDataEvent_Tags.Direct;
        }
    }
    /**
     * m.identity_server
     */
    class IdentityServer_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "AccountDataEvent";
        tag = AccountDataEvent_Tags.IdentityServer;
        inner;
        constructor(inner) {
            super("AccountDataEvent", "IdentityServer");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new IdentityServer_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === AccountDataEvent_Tags.IdentityServer;
        }
    }
    /**
     * m.ignored_user_list
     */
    class IgnoredUserList_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "AccountDataEvent";
        tag = AccountDataEvent_Tags.IgnoredUserList;
        inner;
        constructor(inner) {
            super("AccountDataEvent", "IgnoredUserList");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new IgnoredUserList_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === AccountDataEvent_Tags.IgnoredUserList;
        }
    }
    /**
     * m.push_rules
     */
    class PushRules_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "AccountDataEvent";
        tag = AccountDataEvent_Tags.PushRules;
        inner;
        constructor(inner) {
            super("AccountDataEvent", "PushRules");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new PushRules_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === AccountDataEvent_Tags.PushRules;
        }
    }
    /**
     * m.secret_storage.default_key
     */
    class SecretStorageDefaultKey_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "AccountDataEvent";
        tag = AccountDataEvent_Tags.SecretStorageDefaultKey;
        inner;
        constructor(inner) {
            super("AccountDataEvent", "SecretStorageDefaultKey");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new SecretStorageDefaultKey_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === AccountDataEvent_Tags.SecretStorageDefaultKey;
        }
    }
    /**
     * m.secret_storage.key.*
     */
    class SecretStorageKey_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "AccountDataEvent";
        tag = AccountDataEvent_Tags.SecretStorageKey;
        inner;
        constructor(inner) {
            super("AccountDataEvent", "SecretStorageKey");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new SecretStorageKey_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === AccountDataEvent_Tags.SecretStorageKey;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "AccountDataEvent";
    }
    return Object.freeze({
        instanceOf,
        Direct: Direct_,
        IdentityServer: IdentityServer_,
        IgnoredUserList: IgnoredUserList_,
        PushRules: PushRules_,
        SecretStorageDefaultKey: SecretStorageDefaultKey_,
        SecretStorageKey: SecretStorageKey_
    });
})();
// FfiConverter for enum AccountDataEvent
const FfiConverterTypeAccountDataEvent = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new AccountDataEvent.Direct({ map: FfiConverterMapStringArrayString.read(from) });
                case 2: return new AccountDataEvent.IdentityServer({ baseUrl: FfiConverterOptionalString.read(from) });
                case 3: return new AccountDataEvent.IgnoredUserList({ ignoredUsers: FfiConverterMapStringTypeIgnoredUser.read(from) });
                case 4: return new AccountDataEvent.PushRules({ global: FfiConverterTypeRuleset.read(from) });
                case 5: return new AccountDataEvent.SecretStorageDefaultKey({ keyId: FfiConverterString.read(from) });
                case 6: return new AccountDataEvent.SecretStorageKey({ keyId: FfiConverterString.read(from), name: FfiConverterOptionalString.read(from), algorithm: FfiConverterTypeSecretStorageEncryptionAlgorithm.read(from), passphrase: FfiConverterOptionalTypePassPhrase.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case AccountDataEvent_Tags.Direct: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterMapStringArrayString.write(inner.map, into);
                    return;
                }
                case AccountDataEvent_Tags.IdentityServer: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterOptionalString.write(inner.baseUrl, into);
                    return;
                }
                case AccountDataEvent_Tags.IgnoredUserList: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterMapStringTypeIgnoredUser.write(inner.ignoredUsers, into);
                    return;
                }
                case AccountDataEvent_Tags.PushRules: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterTypeRuleset.write(inner.global, into);
                    return;
                }
                case AccountDataEvent_Tags.SecretStorageDefaultKey: {
                    ordinalConverter.write(5, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.keyId, into);
                    return;
                }
                case AccountDataEvent_Tags.SecretStorageKey: {
                    ordinalConverter.write(6, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.keyId, into);
                    FfiConverterOptionalString.write(inner.name, into);
                    FfiConverterTypeSecretStorageEncryptionAlgorithm.write(inner.algorithm, into);
                    FfiConverterOptionalTypePassPhrase.write(inner.passphrase, into);
                    return;
                }
                default:
                    // Throwing from here means that AccountDataEvent_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case AccountDataEvent_Tags.Direct: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterMapStringArrayString.allocationSize(inner.map);
                    return size;
                }
                case AccountDataEvent_Tags.IdentityServer: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterOptionalString.allocationSize(inner.baseUrl);
                    return size;
                }
                case AccountDataEvent_Tags.IgnoredUserList: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterMapStringTypeIgnoredUser.allocationSize(inner.ignoredUsers);
                    return size;
                }
                case AccountDataEvent_Tags.PushRules: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterTypeRuleset.allocationSize(inner.global);
                    return size;
                }
                case AccountDataEvent_Tags.SecretStorageDefaultKey: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(5);
                    size += FfiConverterString.allocationSize(inner.keyId);
                    return size;
                }
                case AccountDataEvent_Tags.SecretStorageKey: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(6);
                    size += FfiConverterString.allocationSize(inner.keyId);
                    size += FfiConverterOptionalString.allocationSize(inner.name);
                    size += FfiConverterTypeSecretStorageEncryptionAlgorithm.allocationSize(inner.algorithm);
                    size += FfiConverterOptionalTypePassPhrase.allocationSize(inner.passphrase);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: AccountDataEventType
export var AccountDataEventType_Tags;
(function (AccountDataEventType_Tags) {
    AccountDataEventType_Tags["Direct"] = "Direct";
    AccountDataEventType_Tags["IdentityServer"] = "IdentityServer";
    AccountDataEventType_Tags["IgnoredUserList"] = "IgnoredUserList";
    AccountDataEventType_Tags["PushRules"] = "PushRules";
    AccountDataEventType_Tags["SecretStorageDefaultKey"] = "SecretStorageDefaultKey";
    AccountDataEventType_Tags["SecretStorageKey"] = "SecretStorageKey";
})(AccountDataEventType_Tags || (AccountDataEventType_Tags = {}));
/**
 * Types of global account data events.
 */
export const AccountDataEventType = (() => {
    /**
     * m.direct
     */
    class Direct_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "AccountDataEventType";
        tag = AccountDataEventType_Tags.Direct;
        constructor() {
            super("AccountDataEventType", "Direct");
        }
        static new() {
            return new Direct_();
        }
        static instanceOf(obj) {
            return obj.tag === AccountDataEventType_Tags.Direct;
        }
    }
    /**
     * m.identity_server
     */
    class IdentityServer_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "AccountDataEventType";
        tag = AccountDataEventType_Tags.IdentityServer;
        constructor() {
            super("AccountDataEventType", "IdentityServer");
        }
        static new() {
            return new IdentityServer_();
        }
        static instanceOf(obj) {
            return obj.tag === AccountDataEventType_Tags.IdentityServer;
        }
    }
    /**
     * m.ignored_user_list
     */
    class IgnoredUserList_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "AccountDataEventType";
        tag = AccountDataEventType_Tags.IgnoredUserList;
        constructor() {
            super("AccountDataEventType", "IgnoredUserList");
        }
        static new() {
            return new IgnoredUserList_();
        }
        static instanceOf(obj) {
            return obj.tag === AccountDataEventType_Tags.IgnoredUserList;
        }
    }
    /**
     * m.push_rules
     */
    class PushRules_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "AccountDataEventType";
        tag = AccountDataEventType_Tags.PushRules;
        constructor() {
            super("AccountDataEventType", "PushRules");
        }
        static new() {
            return new PushRules_();
        }
        static instanceOf(obj) {
            return obj.tag === AccountDataEventType_Tags.PushRules;
        }
    }
    /**
     * m.secret_storage.default_key
     */
    class SecretStorageDefaultKey_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "AccountDataEventType";
        tag = AccountDataEventType_Tags.SecretStorageDefaultKey;
        constructor() {
            super("AccountDataEventType", "SecretStorageDefaultKey");
        }
        static new() {
            return new SecretStorageDefaultKey_();
        }
        static instanceOf(obj) {
            return obj.tag === AccountDataEventType_Tags.SecretStorageDefaultKey;
        }
    }
    /**
     * m.secret_storage.key.*
     */
    class SecretStorageKey_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "AccountDataEventType";
        tag = AccountDataEventType_Tags.SecretStorageKey;
        inner;
        constructor(inner) {
            super("AccountDataEventType", "SecretStorageKey");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new SecretStorageKey_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === AccountDataEventType_Tags.SecretStorageKey;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "AccountDataEventType";
    }
    return Object.freeze({
        instanceOf,
        Direct: Direct_,
        IdentityServer: IdentityServer_,
        IgnoredUserList: IgnoredUserList_,
        PushRules: PushRules_,
        SecretStorageDefaultKey: SecretStorageDefaultKey_,
        SecretStorageKey: SecretStorageKey_
    });
})();
// FfiConverter for enum AccountDataEventType
const FfiConverterTypeAccountDataEventType = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new AccountDataEventType.Direct();
                case 2: return new AccountDataEventType.IdentityServer();
                case 3: return new AccountDataEventType.IgnoredUserList();
                case 4: return new AccountDataEventType.PushRules();
                case 5: return new AccountDataEventType.SecretStorageDefaultKey();
                case 6: return new AccountDataEventType.SecretStorageKey({ keyId: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case AccountDataEventType_Tags.Direct: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case AccountDataEventType_Tags.IdentityServer: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case AccountDataEventType_Tags.IgnoredUserList: {
                    ordinalConverter.write(3, into);
                    return;
                }
                case AccountDataEventType_Tags.PushRules: {
                    ordinalConverter.write(4, into);
                    return;
                }
                case AccountDataEventType_Tags.SecretStorageDefaultKey: {
                    ordinalConverter.write(5, into);
                    return;
                }
                case AccountDataEventType_Tags.SecretStorageKey: {
                    ordinalConverter.write(6, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.keyId, into);
                    return;
                }
                default:
                    // Throwing from here means that AccountDataEventType_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case AccountDataEventType_Tags.Direct: {
                    return ordinalConverter.allocationSize(1);
                }
                case AccountDataEventType_Tags.IdentityServer: {
                    return ordinalConverter.allocationSize(2);
                }
                case AccountDataEventType_Tags.IgnoredUserList: {
                    return ordinalConverter.allocationSize(3);
                }
                case AccountDataEventType_Tags.PushRules: {
                    return ordinalConverter.allocationSize(4);
                }
                case AccountDataEventType_Tags.SecretStorageDefaultKey: {
                    return ordinalConverter.allocationSize(5);
                }
                case AccountDataEventType_Tags.SecretStorageKey: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(6);
                    size += FfiConverterString.allocationSize(inner.keyId);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: AccountManagementAction
export var AccountManagementAction_Tags;
(function (AccountManagementAction_Tags) {
    AccountManagementAction_Tags["Profile"] = "Profile";
    AccountManagementAction_Tags["SessionsList"] = "SessionsList";
    AccountManagementAction_Tags["SessionView"] = "SessionView";
    AccountManagementAction_Tags["SessionEnd"] = "SessionEnd";
    AccountManagementAction_Tags["AccountDeactivate"] = "AccountDeactivate";
    AccountManagementAction_Tags["CrossSigningReset"] = "CrossSigningReset";
})(AccountManagementAction_Tags || (AccountManagementAction_Tags = {}));
export const AccountManagementAction = (() => {
    class Profile_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "AccountManagementAction";
        tag = AccountManagementAction_Tags.Profile;
        constructor() {
            super("AccountManagementAction", "Profile");
        }
        static new() {
            return new Profile_();
        }
        static instanceOf(obj) {
            return obj.tag === AccountManagementAction_Tags.Profile;
        }
    }
    class SessionsList_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "AccountManagementAction";
        tag = AccountManagementAction_Tags.SessionsList;
        constructor() {
            super("AccountManagementAction", "SessionsList");
        }
        static new() {
            return new SessionsList_();
        }
        static instanceOf(obj) {
            return obj.tag === AccountManagementAction_Tags.SessionsList;
        }
    }
    class SessionView_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "AccountManagementAction";
        tag = AccountManagementAction_Tags.SessionView;
        inner;
        constructor(inner) {
            super("AccountManagementAction", "SessionView");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new SessionView_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === AccountManagementAction_Tags.SessionView;
        }
    }
    class SessionEnd_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "AccountManagementAction";
        tag = AccountManagementAction_Tags.SessionEnd;
        inner;
        constructor(inner) {
            super("AccountManagementAction", "SessionEnd");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new SessionEnd_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === AccountManagementAction_Tags.SessionEnd;
        }
    }
    class AccountDeactivate_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "AccountManagementAction";
        tag = AccountManagementAction_Tags.AccountDeactivate;
        constructor() {
            super("AccountManagementAction", "AccountDeactivate");
        }
        static new() {
            return new AccountDeactivate_();
        }
        static instanceOf(obj) {
            return obj.tag === AccountManagementAction_Tags.AccountDeactivate;
        }
    }
    class CrossSigningReset_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "AccountManagementAction";
        tag = AccountManagementAction_Tags.CrossSigningReset;
        constructor() {
            super("AccountManagementAction", "CrossSigningReset");
        }
        static new() {
            return new CrossSigningReset_();
        }
        static instanceOf(obj) {
            return obj.tag === AccountManagementAction_Tags.CrossSigningReset;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "AccountManagementAction";
    }
    return Object.freeze({
        instanceOf,
        Profile: Profile_,
        SessionsList: SessionsList_,
        SessionView: SessionView_,
        SessionEnd: SessionEnd_,
        AccountDeactivate: AccountDeactivate_,
        CrossSigningReset: CrossSigningReset_
    });
})();
// FfiConverter for enum AccountManagementAction
const FfiConverterTypeAccountManagementAction = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new AccountManagementAction.Profile();
                case 2: return new AccountManagementAction.SessionsList();
                case 3: return new AccountManagementAction.SessionView({ deviceId: FfiConverterString.read(from) });
                case 4: return new AccountManagementAction.SessionEnd({ deviceId: FfiConverterString.read(from) });
                case 5: return new AccountManagementAction.AccountDeactivate();
                case 6: return new AccountManagementAction.CrossSigningReset();
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case AccountManagementAction_Tags.Profile: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case AccountManagementAction_Tags.SessionsList: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case AccountManagementAction_Tags.SessionView: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.deviceId, into);
                    return;
                }
                case AccountManagementAction_Tags.SessionEnd: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.deviceId, into);
                    return;
                }
                case AccountManagementAction_Tags.AccountDeactivate: {
                    ordinalConverter.write(5, into);
                    return;
                }
                case AccountManagementAction_Tags.CrossSigningReset: {
                    ordinalConverter.write(6, into);
                    return;
                }
                default:
                    // Throwing from here means that AccountManagementAction_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case AccountManagementAction_Tags.Profile: {
                    return ordinalConverter.allocationSize(1);
                }
                case AccountManagementAction_Tags.SessionsList: {
                    return ordinalConverter.allocationSize(2);
                }
                case AccountManagementAction_Tags.SessionView: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterString.allocationSize(inner.deviceId);
                    return size;
                }
                case AccountManagementAction_Tags.SessionEnd: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterString.allocationSize(inner.deviceId);
                    return size;
                }
                case AccountManagementAction_Tags.AccountDeactivate: {
                    return ordinalConverter.allocationSize(5);
                }
                case AccountManagementAction_Tags.CrossSigningReset: {
                    return ordinalConverter.allocationSize(6);
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: Action
export var Action_Tags;
(function (Action_Tags) {
    Action_Tags["Notify"] = "Notify";
    Action_Tags["SetTweak"] = "SetTweak";
})(Action_Tags || (Action_Tags = {}));
/**
 * Enum representing the push notification actions for a rule.
 */
export const Action = (() => {
    /**
     * Causes matching events to generate a notification.
     */
    class Notify_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "Action";
        tag = Action_Tags.Notify;
        constructor() {
            super("Action", "Notify");
        }
        static new() {
            return new Notify_();
        }
        static instanceOf(obj) {
            return obj.tag === Action_Tags.Notify;
        }
    }
    /**
     * Sets an entry in the 'tweaks' dictionary sent to the push gateway.
     */
    class SetTweak_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "Action";
        tag = Action_Tags.SetTweak;
        inner;
        constructor(inner) {
            super("Action", "SetTweak");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new SetTweak_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === Action_Tags.SetTweak;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "Action";
    }
    return Object.freeze({
        instanceOf,
        Notify: Notify_,
        SetTweak: SetTweak_
    });
})();
// FfiConverter for enum Action
const FfiConverterTypeAction = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new Action.Notify();
                case 2: return new Action.SetTweak({ value: FfiConverterTypeTweak.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case Action_Tags.Notify: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case Action_Tags.SetTweak: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterTypeTweak.write(inner.value, into);
                    return;
                }
                default:
                    // Throwing from here means that Action_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case Action_Tags.Notify: {
                    return ordinalConverter.allocationSize(1);
                }
                case Action_Tags.SetTweak: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterTypeTweak.allocationSize(inner.value);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: AllowRule
export var AllowRule_Tags;
(function (AllowRule_Tags) {
    AllowRule_Tags["RoomMembership"] = "RoomMembership";
    AllowRule_Tags["Custom"] = "Custom";
})(AllowRule_Tags || (AllowRule_Tags = {}));
/**
 * An allow rule which defines a condition that allows joining a room.
 */
export const AllowRule = (() => {
    /**
     * Only a member of the `room_id` Room can join the one this rule is used
     * in.
     */
    class RoomMembership_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "AllowRule";
        tag = AllowRule_Tags.RoomMembership;
        inner;
        constructor(inner) {
            super("AllowRule", "RoomMembership");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new RoomMembership_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === AllowRule_Tags.RoomMembership;
        }
    }
    /**
     * A custom allow rule implementation, containing its JSON representation
     * as a `String`.
     */
    class Custom_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "AllowRule";
        tag = AllowRule_Tags.Custom;
        inner;
        constructor(inner) {
            super("AllowRule", "Custom");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Custom_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === AllowRule_Tags.Custom;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "AllowRule";
    }
    return Object.freeze({
        instanceOf,
        RoomMembership: RoomMembership_,
        Custom: Custom_
    });
})();
// FfiConverter for enum AllowRule
const FfiConverterTypeAllowRule = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new AllowRule.RoomMembership({ roomId: FfiConverterString.read(from) });
                case 2: return new AllowRule.Custom({ json: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case AllowRule_Tags.RoomMembership: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.roomId, into);
                    return;
                }
                case AllowRule_Tags.Custom: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.json, into);
                    return;
                }
                default:
                    // Throwing from here means that AllowRule_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case AllowRule_Tags.RoomMembership: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterString.allocationSize(inner.roomId);
                    return size;
                }
                case AllowRule_Tags.Custom: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterString.allocationSize(inner.json);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
export var AssetType;
(function (AssetType) {
    AssetType[AssetType["Sender"] = 0] = "Sender";
    AssetType[AssetType["Pin"] = 1] = "Pin";
})(AssetType || (AssetType = {}));
const FfiConverterTypeAssetType = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return AssetType.Sender;
                case 2: return AssetType.Pin;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case AssetType.Sender: return ordinalConverter.write(1, into);
                case AssetType.Pin: return ordinalConverter.write(2, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Enum: AuthData
export var AuthData_Tags;
(function (AuthData_Tags) {
    AuthData_Tags["Password"] = "Password";
})(AuthData_Tags || (AuthData_Tags = {}));
export const AuthData = (() => {
    /**
     * Password-based authentication (`m.login.password`).
     */
    class Password_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "AuthData";
        tag = AuthData_Tags.Password;
        inner;
        constructor(inner) {
            super("AuthData", "Password");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Password_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === AuthData_Tags.Password;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "AuthData";
    }
    return Object.freeze({
        instanceOf,
        Password: Password_
    });
})();
// FfiConverter for enum AuthData
const FfiConverterTypeAuthData = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new AuthData.Password({ passwordDetails: FfiConverterTypeAuthDataPasswordDetails.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case AuthData_Tags.Password: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterTypeAuthDataPasswordDetails.write(inner.passwordDetails, into);
                    return;
                }
                default:
                    // Throwing from here means that AuthData_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case AuthData_Tags.Password: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterTypeAuthDataPasswordDetails.allocationSize(inner.passwordDetails);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
export var BackupState;
(function (BackupState) {
    BackupState[BackupState["Unknown"] = 0] = "Unknown";
    BackupState[BackupState["Creating"] = 1] = "Creating";
    BackupState[BackupState["Enabling"] = 2] = "Enabling";
    BackupState[BackupState["Resuming"] = 3] = "Resuming";
    BackupState[BackupState["Enabled"] = 4] = "Enabled";
    BackupState[BackupState["Downloading"] = 5] = "Downloading";
    BackupState[BackupState["Disabling"] = 6] = "Disabling";
})(BackupState || (BackupState = {}));
const FfiConverterTypeBackupState = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return BackupState.Unknown;
                case 2: return BackupState.Creating;
                case 3: return BackupState.Enabling;
                case 4: return BackupState.Resuming;
                case 5: return BackupState.Enabled;
                case 6: return BackupState.Downloading;
                case 7: return BackupState.Disabling;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case BackupState.Unknown: return ordinalConverter.write(1, into);
                case BackupState.Creating: return ordinalConverter.write(2, into);
                case BackupState.Enabling: return ordinalConverter.write(3, into);
                case BackupState.Resuming: return ordinalConverter.write(4, into);
                case BackupState.Enabled: return ordinalConverter.write(5, into);
                case BackupState.Downloading: return ordinalConverter.write(6, into);
                case BackupState.Disabling: return ordinalConverter.write(7, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Enum: BackupUploadState
export var BackupUploadState_Tags;
(function (BackupUploadState_Tags) {
    BackupUploadState_Tags["Waiting"] = "Waiting";
    BackupUploadState_Tags["Uploading"] = "Uploading";
    BackupUploadState_Tags["Error"] = "Error";
    BackupUploadState_Tags["Done"] = "Done";
})(BackupUploadState_Tags || (BackupUploadState_Tags = {}));
export const BackupUploadState = (() => {
    class Waiting_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "BackupUploadState";
        tag = BackupUploadState_Tags.Waiting;
        constructor() {
            super("BackupUploadState", "Waiting");
        }
        static new() {
            return new Waiting_();
        }
        static instanceOf(obj) {
            return obj.tag === BackupUploadState_Tags.Waiting;
        }
    }
    class Uploading_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "BackupUploadState";
        tag = BackupUploadState_Tags.Uploading;
        inner;
        constructor(inner) {
            super("BackupUploadState", "Uploading");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Uploading_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === BackupUploadState_Tags.Uploading;
        }
    }
    class Error_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "BackupUploadState";
        tag = BackupUploadState_Tags.Error;
        constructor() {
            super("BackupUploadState", "Error");
        }
        static new() {
            return new Error_();
        }
        static instanceOf(obj) {
            return obj.tag === BackupUploadState_Tags.Error;
        }
    }
    class Done_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "BackupUploadState";
        tag = BackupUploadState_Tags.Done;
        constructor() {
            super("BackupUploadState", "Done");
        }
        static new() {
            return new Done_();
        }
        static instanceOf(obj) {
            return obj.tag === BackupUploadState_Tags.Done;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "BackupUploadState";
    }
    return Object.freeze({
        instanceOf,
        Waiting: Waiting_,
        Uploading: Uploading_,
        Error: Error_,
        Done: Done_
    });
})();
// FfiConverter for enum BackupUploadState
const FfiConverterTypeBackupUploadState = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new BackupUploadState.Waiting();
                case 2: return new BackupUploadState.Uploading({ backedUpCount: FfiConverterUInt32.read(from), totalCount: FfiConverterUInt32.read(from) });
                case 3: return new BackupUploadState.Error();
                case 4: return new BackupUploadState.Done();
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case BackupUploadState_Tags.Waiting: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case BackupUploadState_Tags.Uploading: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterUInt32.write(inner.backedUpCount, into);
                    FfiConverterUInt32.write(inner.totalCount, into);
                    return;
                }
                case BackupUploadState_Tags.Error: {
                    ordinalConverter.write(3, into);
                    return;
                }
                case BackupUploadState_Tags.Done: {
                    ordinalConverter.write(4, into);
                    return;
                }
                default:
                    // Throwing from here means that BackupUploadState_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case BackupUploadState_Tags.Waiting: {
                    return ordinalConverter.allocationSize(1);
                }
                case BackupUploadState_Tags.Uploading: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterUInt32.allocationSize(inner.backedUpCount);
                    size += FfiConverterUInt32.allocationSize(inner.totalCount);
                    return size;
                }
                case BackupUploadState_Tags.Error: {
                    return ordinalConverter.allocationSize(3);
                }
                case BackupUploadState_Tags.Done: {
                    return ordinalConverter.allocationSize(4);
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: BatchNotificationResult
export var BatchNotificationResult_Tags;
(function (BatchNotificationResult_Tags) {
    BatchNotificationResult_Tags["Ok"] = "Ok";
    BatchNotificationResult_Tags["Error"] = "Error";
})(BatchNotificationResult_Tags || (BatchNotificationResult_Tags = {}));
export const BatchNotificationResult = (() => {
    /**
     * We have more detailed information about the notification.
     */
    class Ok_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "BatchNotificationResult";
        tag = BatchNotificationResult_Tags.Ok;
        inner;
        constructor(inner) {
            super("BatchNotificationResult", "Ok");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Ok_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === BatchNotificationResult_Tags.Ok;
        }
    }
    /**
     * An error occurred while trying to fetch the notification.
     */
    class Error_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "BatchNotificationResult";
        tag = BatchNotificationResult_Tags.Error;
        inner;
        constructor(inner) {
            super("BatchNotificationResult", "Error");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Error_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === BatchNotificationResult_Tags.Error;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "BatchNotificationResult";
    }
    return Object.freeze({
        instanceOf,
        Ok: Ok_,
        Error: Error_
    });
})();
// FfiConverter for enum BatchNotificationResult
const FfiConverterTypeBatchNotificationResult = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new BatchNotificationResult.Ok({ status: FfiConverterTypeNotificationStatus.read(from) });
                case 2: return new BatchNotificationResult.Error({ message: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case BatchNotificationResult_Tags.Ok: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterTypeNotificationStatus.write(inner.status, into);
                    return;
                }
                case BatchNotificationResult_Tags.Error: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.message, into);
                    return;
                }
                default:
                    // Throwing from here means that BatchNotificationResult_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case BatchNotificationResult_Tags.Ok: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterTypeNotificationStatus.allocationSize(inner.status);
                    return size;
                }
                case BatchNotificationResult_Tags.Error: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterString.allocationSize(inner.message);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Flat error type: ClientBuildError
export var ClientBuildError_Tags;
(function (ClientBuildError_Tags) {
    ClientBuildError_Tags["InvalidServerName"] = "InvalidServerName";
    ClientBuildError_Tags["ServerUnreachable"] = "ServerUnreachable";
    ClientBuildError_Tags["WellKnownLookupFailed"] = "WellKnownLookupFailed";
    ClientBuildError_Tags["WellKnownDeserializationError"] = "WellKnownDeserializationError";
    ClientBuildError_Tags["SlidingSync"] = "SlidingSync";
    ClientBuildError_Tags["SlidingSyncVersion"] = "SlidingSyncVersion";
    ClientBuildError_Tags["Sdk"] = "Sdk";
    ClientBuildError_Tags["EventCache"] = "EventCache";
    ClientBuildError_Tags["Generic"] = "Generic";
})(ClientBuildError_Tags || (ClientBuildError_Tags = {}));
export const ClientBuildError = (() => {
    class InvalidServerName extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "ClientBuildError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 1;
        tag = ClientBuildError_Tags.InvalidServerName;
        constructor(message) {
            super("ClientBuildError", "InvalidServerName", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 1);
        }
    }
    class ServerUnreachable extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "ClientBuildError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 2;
        tag = ClientBuildError_Tags.ServerUnreachable;
        constructor(message) {
            super("ClientBuildError", "ServerUnreachable", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 2);
        }
    }
    class WellKnownLookupFailed extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "ClientBuildError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 3;
        tag = ClientBuildError_Tags.WellKnownLookupFailed;
        constructor(message) {
            super("ClientBuildError", "WellKnownLookupFailed", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 3);
        }
    }
    class WellKnownDeserializationError extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "ClientBuildError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 4;
        tag = ClientBuildError_Tags.WellKnownDeserializationError;
        constructor(message) {
            super("ClientBuildError", "WellKnownDeserializationError", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 4);
        }
    }
    class SlidingSync extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "ClientBuildError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 5;
        tag = ClientBuildError_Tags.SlidingSync;
        constructor(message) {
            super("ClientBuildError", "SlidingSync", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 5);
        }
    }
    class SlidingSyncVersion extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "ClientBuildError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 6;
        tag = ClientBuildError_Tags.SlidingSyncVersion;
        constructor(message) {
            super("ClientBuildError", "SlidingSyncVersion", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 6);
        }
    }
    class Sdk extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "ClientBuildError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 7;
        tag = ClientBuildError_Tags.Sdk;
        constructor(message) {
            super("ClientBuildError", "Sdk", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 7);
        }
    }
    class EventCache extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "ClientBuildError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 8;
        tag = ClientBuildError_Tags.EventCache;
        constructor(message) {
            super("ClientBuildError", "EventCache", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 8);
        }
    }
    class Generic extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "ClientBuildError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 9;
        tag = ClientBuildError_Tags.Generic;
        constructor(message) {
            super("ClientBuildError", "Generic", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 9);
        }
    }
    // Utility function which does not rely on instanceof.
    function instanceOf(e) {
        return e[uniffiTypeNameSymbol] === "ClientBuildError";
    }
    return {
        InvalidServerName,
        ServerUnreachable,
        WellKnownLookupFailed,
        WellKnownDeserializationError,
        SlidingSync,
        SlidingSyncVersion,
        Sdk,
        EventCache,
        Generic,
        instanceOf,
    };
})();
const FfiConverterTypeClientBuildError = (() => {
    const intConverter = FfiConverterInt32;
    class FfiConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (intConverter.read(from)) {
                case 1: return new ClientBuildError.InvalidServerName(FfiConverterString.read(from));
                case 2: return new ClientBuildError.ServerUnreachable(FfiConverterString.read(from));
                case 3: return new ClientBuildError.WellKnownLookupFailed(FfiConverterString.read(from));
                case 4: return new ClientBuildError.WellKnownDeserializationError(FfiConverterString.read(from));
                case 5: return new ClientBuildError.SlidingSync(FfiConverterString.read(from));
                case 6: return new ClientBuildError.SlidingSyncVersion(FfiConverterString.read(from));
                case 7: return new ClientBuildError.Sdk(FfiConverterString.read(from));
                case 8: return new ClientBuildError.EventCache(FfiConverterString.read(from));
                case 9: return new ClientBuildError.Generic(FfiConverterString.read(from));
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            const obj = value;
            const index = obj[variantOrdinalSymbol];
            intConverter.write(index, into);
        }
        allocationSize(value) {
            return intConverter.allocationSize(0);
        }
    }
    return new FfiConverter();
})();
// Error type: ClientError
// Enum: ClientError
export var ClientError_Tags;
(function (ClientError_Tags) {
    ClientError_Tags["Generic"] = "Generic";
    ClientError_Tags["MatrixApi"] = "MatrixApi";
})(ClientError_Tags || (ClientError_Tags = {}));
export const ClientError = (() => {
    class Generic_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ClientError";
        tag = ClientError_Tags.Generic;
        inner;
        constructor(inner) {
            super("ClientError", "Generic");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Generic_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === ClientError_Tags.Generic;
        }
        static hasInner(obj) {
            return Generic_.instanceOf(obj);
        }
        static getInner(obj) {
            return obj.inner;
        }
    }
    class MatrixApi_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ClientError";
        tag = ClientError_Tags.MatrixApi;
        inner;
        constructor(inner) {
            super("ClientError", "MatrixApi");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new MatrixApi_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === ClientError_Tags.MatrixApi;
        }
        static hasInner(obj) {
            return MatrixApi_.instanceOf(obj);
        }
        static getInner(obj) {
            return obj.inner;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "ClientError";
    }
    return Object.freeze({
        instanceOf,
        Generic: Generic_,
        MatrixApi: MatrixApi_
    });
})();
// FfiConverter for enum ClientError
const FfiConverterTypeClientError = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new ClientError.Generic({ msg: FfiConverterString.read(from), details: FfiConverterOptionalString.read(from) });
                case 2: return new ClientError.MatrixApi({ kind: FfiConverterTypeErrorKind.read(from), code: FfiConverterString.read(from), msg: FfiConverterString.read(from), details: FfiConverterOptionalString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case ClientError_Tags.Generic: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.msg, into);
                    FfiConverterOptionalString.write(inner.details, into);
                    return;
                }
                case ClientError_Tags.MatrixApi: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterTypeErrorKind.write(inner.kind, into);
                    FfiConverterString.write(inner.code, into);
                    FfiConverterString.write(inner.msg, into);
                    FfiConverterOptionalString.write(inner.details, into);
                    return;
                }
                default:
                    // Throwing from here means that ClientError_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case ClientError_Tags.Generic: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterString.allocationSize(inner.msg);
                    size += FfiConverterOptionalString.allocationSize(inner.details);
                    return size;
                }
                case ClientError_Tags.MatrixApi: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterTypeErrorKind.allocationSize(inner.kind);
                    size += FfiConverterString.allocationSize(inner.code);
                    size += FfiConverterString.allocationSize(inner.msg);
                    size += FfiConverterOptionalString.allocationSize(inner.details);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
export var ComparisonOperator;
(function (ComparisonOperator) {
    /**
     * Equals
     */
    ComparisonOperator[ComparisonOperator["Eq"] = 0] = "Eq";
    /**
     * Less than
     */
    ComparisonOperator[ComparisonOperator["Lt"] = 1] = "Lt";
    /**
     * Greater than
     */
    ComparisonOperator[ComparisonOperator["Gt"] = 2] = "Gt";
    /**
     * Greater or equal
     */
    ComparisonOperator[ComparisonOperator["Ge"] = 3] = "Ge";
    /**
     * Less or equal
     */
    ComparisonOperator[ComparisonOperator["Le"] = 4] = "Le";
})(ComparisonOperator || (ComparisonOperator = {}));
const FfiConverterTypeComparisonOperator = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return ComparisonOperator.Eq;
                case 2: return ComparisonOperator.Lt;
                case 3: return ComparisonOperator.Gt;
                case 4: return ComparisonOperator.Ge;
                case 5: return ComparisonOperator.Le;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case ComparisonOperator.Eq: return ordinalConverter.write(1, into);
                case ComparisonOperator.Lt: return ordinalConverter.write(2, into);
                case ComparisonOperator.Gt: return ordinalConverter.write(3, into);
                case ComparisonOperator.Ge: return ordinalConverter.write(4, into);
                case ComparisonOperator.Le: return ordinalConverter.write(5, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Enum: ComposerDraftType
export var ComposerDraftType_Tags;
(function (ComposerDraftType_Tags) {
    ComposerDraftType_Tags["NewMessage"] = "NewMessage";
    ComposerDraftType_Tags["Reply"] = "Reply";
    ComposerDraftType_Tags["Edit"] = "Edit";
})(ComposerDraftType_Tags || (ComposerDraftType_Tags = {}));
/**
 * The type of draft of the composer.
 */
export const ComposerDraftType = (() => {
    /**
     * The draft is a new message.
     */
    class NewMessage_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ComposerDraftType";
        tag = ComposerDraftType_Tags.NewMessage;
        constructor() {
            super("ComposerDraftType", "NewMessage");
        }
        static new() {
            return new NewMessage_();
        }
        static instanceOf(obj) {
            return obj.tag === ComposerDraftType_Tags.NewMessage;
        }
    }
    /**
     * The draft is a reply to an event.
     */
    class Reply_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ComposerDraftType";
        tag = ComposerDraftType_Tags.Reply;
        inner;
        constructor(inner) {
            super("ComposerDraftType", "Reply");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Reply_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === ComposerDraftType_Tags.Reply;
        }
    }
    /**
     * The draft is an edit of an event.
     */
    class Edit_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ComposerDraftType";
        tag = ComposerDraftType_Tags.Edit;
        inner;
        constructor(inner) {
            super("ComposerDraftType", "Edit");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Edit_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === ComposerDraftType_Tags.Edit;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "ComposerDraftType";
    }
    return Object.freeze({
        instanceOf,
        NewMessage: NewMessage_,
        Reply: Reply_,
        Edit: Edit_
    });
})();
// FfiConverter for enum ComposerDraftType
const FfiConverterTypeComposerDraftType = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new ComposerDraftType.NewMessage();
                case 2: return new ComposerDraftType.Reply({ eventId: FfiConverterString.read(from) });
                case 3: return new ComposerDraftType.Edit({ eventId: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case ComposerDraftType_Tags.NewMessage: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case ComposerDraftType_Tags.Reply: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.eventId, into);
                    return;
                }
                case ComposerDraftType_Tags.Edit: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.eventId, into);
                    return;
                }
                default:
                    // Throwing from here means that ComposerDraftType_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case ComposerDraftType_Tags.NewMessage: {
                    return ordinalConverter.allocationSize(1);
                }
                case ComposerDraftType_Tags.Reply: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterString.allocationSize(inner.eventId);
                    return size;
                }
                case ComposerDraftType_Tags.Edit: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterString.allocationSize(inner.eventId);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: CrossSigningResetAuthType
export var CrossSigningResetAuthType_Tags;
(function (CrossSigningResetAuthType_Tags) {
    CrossSigningResetAuthType_Tags["Uiaa"] = "Uiaa";
    CrossSigningResetAuthType_Tags["Oidc"] = "Oidc";
})(CrossSigningResetAuthType_Tags || (CrossSigningResetAuthType_Tags = {}));
export const CrossSigningResetAuthType = (() => {
    /**
     * The homeserver requires user-interactive authentication.
     */
    class Uiaa_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "CrossSigningResetAuthType";
        tag = CrossSigningResetAuthType_Tags.Uiaa;
        constructor() {
            super("CrossSigningResetAuthType", "Uiaa");
        }
        static new() {
            return new Uiaa_();
        }
        static instanceOf(obj) {
            return obj.tag === CrossSigningResetAuthType_Tags.Uiaa;
        }
    }
    class Oidc_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "CrossSigningResetAuthType";
        tag = CrossSigningResetAuthType_Tags.Oidc;
        inner;
        constructor(inner) {
            super("CrossSigningResetAuthType", "Oidc");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Oidc_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === CrossSigningResetAuthType_Tags.Oidc;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "CrossSigningResetAuthType";
    }
    return Object.freeze({
        instanceOf,
        Uiaa: Uiaa_,
        Oidc: Oidc_
    });
})();
// FfiConverter for enum CrossSigningResetAuthType
const FfiConverterTypeCrossSigningResetAuthType = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new CrossSigningResetAuthType.Uiaa();
                case 2: return new CrossSigningResetAuthType.Oidc({ info: FfiConverterTypeOidcCrossSigningResetInfo.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case CrossSigningResetAuthType_Tags.Uiaa: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case CrossSigningResetAuthType_Tags.Oidc: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterTypeOidcCrossSigningResetInfo.write(inner.info, into);
                    return;
                }
                default:
                    // Throwing from here means that CrossSigningResetAuthType_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case CrossSigningResetAuthType_Tags.Uiaa: {
                    return ordinalConverter.allocationSize(1);
                }
                case CrossSigningResetAuthType_Tags.Oidc: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterTypeOidcCrossSigningResetInfo.allocationSize(inner.info);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
/**
 * Changes how date dividers get inserted, either in between each day or in
 * between each month
 */
export var DateDividerMode;
(function (DateDividerMode) {
    DateDividerMode[DateDividerMode["Daily"] = 0] = "Daily";
    DateDividerMode[DateDividerMode["Monthly"] = 1] = "Monthly";
})(DateDividerMode || (DateDividerMode = {}));
const FfiConverterTypeDateDividerMode = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return DateDividerMode.Daily;
                case 2: return DateDividerMode.Monthly;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case DateDividerMode.Daily: return ordinalConverter.write(1, into);
                case DateDividerMode.Monthly: return ordinalConverter.write(2, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Enum: DraftAttachment
export var DraftAttachment_Tags;
(function (DraftAttachment_Tags) {
    DraftAttachment_Tags["Audio"] = "Audio";
    DraftAttachment_Tags["File"] = "File";
    DraftAttachment_Tags["Image"] = "Image";
    DraftAttachment_Tags["Video"] = "Video";
})(DraftAttachment_Tags || (DraftAttachment_Tags = {}));
/**
 * An attachment stored with a composer draft.
 */
export const DraftAttachment = (() => {
    class Audio_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "DraftAttachment";
        tag = DraftAttachment_Tags.Audio;
        inner;
        constructor(inner) {
            super("DraftAttachment", "Audio");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Audio_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === DraftAttachment_Tags.Audio;
        }
    }
    class File_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "DraftAttachment";
        tag = DraftAttachment_Tags.File;
        inner;
        constructor(inner) {
            super("DraftAttachment", "File");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new File_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === DraftAttachment_Tags.File;
        }
    }
    class Image_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "DraftAttachment";
        tag = DraftAttachment_Tags.Image;
        inner;
        constructor(inner) {
            super("DraftAttachment", "Image");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Image_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === DraftAttachment_Tags.Image;
        }
    }
    class Video_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "DraftAttachment";
        tag = DraftAttachment_Tags.Video;
        inner;
        constructor(inner) {
            super("DraftAttachment", "Video");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Video_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === DraftAttachment_Tags.Video;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "DraftAttachment";
    }
    return Object.freeze({
        instanceOf,
        Audio: Audio_,
        File: File_,
        Image: Image_,
        Video: Video_
    });
})();
// FfiConverter for enum DraftAttachment
const FfiConverterTypeDraftAttachment = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new DraftAttachment.Audio({ audioInfo: FfiConverterTypeAudioInfo.read(from), source: FfiConverterTypeUploadSource.read(from) });
                case 2: return new DraftAttachment.File({ fileInfo: FfiConverterTypeFileInfo.read(from), source: FfiConverterTypeUploadSource.read(from) });
                case 3: return new DraftAttachment.Image({ imageInfo: FfiConverterTypeImageInfo.read(from), source: FfiConverterTypeUploadSource.read(from), thumbnailSource: FfiConverterOptionalTypeUploadSource.read(from) });
                case 4: return new DraftAttachment.Video({ videoInfo: FfiConverterTypeVideoInfo.read(from), source: FfiConverterTypeUploadSource.read(from), thumbnailSource: FfiConverterOptionalTypeUploadSource.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case DraftAttachment_Tags.Audio: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterTypeAudioInfo.write(inner.audioInfo, into);
                    FfiConverterTypeUploadSource.write(inner.source, into);
                    return;
                }
                case DraftAttachment_Tags.File: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterTypeFileInfo.write(inner.fileInfo, into);
                    FfiConverterTypeUploadSource.write(inner.source, into);
                    return;
                }
                case DraftAttachment_Tags.Image: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterTypeImageInfo.write(inner.imageInfo, into);
                    FfiConverterTypeUploadSource.write(inner.source, into);
                    FfiConverterOptionalTypeUploadSource.write(inner.thumbnailSource, into);
                    return;
                }
                case DraftAttachment_Tags.Video: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterTypeVideoInfo.write(inner.videoInfo, into);
                    FfiConverterTypeUploadSource.write(inner.source, into);
                    FfiConverterOptionalTypeUploadSource.write(inner.thumbnailSource, into);
                    return;
                }
                default:
                    // Throwing from here means that DraftAttachment_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case DraftAttachment_Tags.Audio: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterTypeAudioInfo.allocationSize(inner.audioInfo);
                    size += FfiConverterTypeUploadSource.allocationSize(inner.source);
                    return size;
                }
                case DraftAttachment_Tags.File: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterTypeFileInfo.allocationSize(inner.fileInfo);
                    size += FfiConverterTypeUploadSource.allocationSize(inner.source);
                    return size;
                }
                case DraftAttachment_Tags.Image: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterTypeImageInfo.allocationSize(inner.imageInfo);
                    size += FfiConverterTypeUploadSource.allocationSize(inner.source);
                    size += FfiConverterOptionalTypeUploadSource.allocationSize(inner.thumbnailSource);
                    return size;
                }
                case DraftAttachment_Tags.Video: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterTypeVideoInfo.allocationSize(inner.videoInfo);
                    size += FfiConverterTypeUploadSource.allocationSize(inner.source);
                    size += FfiConverterOptionalTypeUploadSource.allocationSize(inner.thumbnailSource);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: EditedContent
export var EditedContent_Tags;
(function (EditedContent_Tags) {
    EditedContent_Tags["RoomMessage"] = "RoomMessage";
    EditedContent_Tags["MediaCaption"] = "MediaCaption";
    EditedContent_Tags["PollStart"] = "PollStart";
})(EditedContent_Tags || (EditedContent_Tags = {}));
export const EditedContent = (() => {
    class RoomMessage_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "EditedContent";
        tag = EditedContent_Tags.RoomMessage;
        inner;
        constructor(inner) {
            super("EditedContent", "RoomMessage");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new RoomMessage_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === EditedContent_Tags.RoomMessage;
        }
    }
    class MediaCaption_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "EditedContent";
        tag = EditedContent_Tags.MediaCaption;
        inner;
        constructor(inner) {
            super("EditedContent", "MediaCaption");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new MediaCaption_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === EditedContent_Tags.MediaCaption;
        }
    }
    class PollStart_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "EditedContent";
        tag = EditedContent_Tags.PollStart;
        inner;
        constructor(inner) {
            super("EditedContent", "PollStart");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new PollStart_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === EditedContent_Tags.PollStart;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "EditedContent";
    }
    return Object.freeze({
        instanceOf,
        RoomMessage: RoomMessage_,
        MediaCaption: MediaCaption_,
        PollStart: PollStart_
    });
})();
// FfiConverter for enum EditedContent
const FfiConverterTypeEditedContent = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new EditedContent.RoomMessage({ content: FfiConverterTypeRoomMessageEventContentWithoutRelation.read(from) });
                case 2: return new EditedContent.MediaCaption({ caption: FfiConverterOptionalString.read(from), formattedCaption: FfiConverterOptionalTypeFormattedBody.read(from), mentions: FfiConverterOptionalTypeMentions.read(from) });
                case 3: return new EditedContent.PollStart({ pollData: FfiConverterTypePollData.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case EditedContent_Tags.RoomMessage: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterTypeRoomMessageEventContentWithoutRelation.write(inner.content, into);
                    return;
                }
                case EditedContent_Tags.MediaCaption: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterOptionalString.write(inner.caption, into);
                    FfiConverterOptionalTypeFormattedBody.write(inner.formattedCaption, into);
                    FfiConverterOptionalTypeMentions.write(inner.mentions, into);
                    return;
                }
                case EditedContent_Tags.PollStart: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterTypePollData.write(inner.pollData, into);
                    return;
                }
                default:
                    // Throwing from here means that EditedContent_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case EditedContent_Tags.RoomMessage: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterTypeRoomMessageEventContentWithoutRelation.allocationSize(inner.content);
                    return size;
                }
                case EditedContent_Tags.MediaCaption: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterOptionalString.allocationSize(inner.caption);
                    size += FfiConverterOptionalTypeFormattedBody.allocationSize(inner.formattedCaption);
                    size += FfiConverterOptionalTypeMentions.allocationSize(inner.mentions);
                    return size;
                }
                case EditedContent_Tags.PollStart: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterTypePollData.allocationSize(inner.pollData);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: EmbeddedEventDetails
export var EmbeddedEventDetails_Tags;
(function (EmbeddedEventDetails_Tags) {
    EmbeddedEventDetails_Tags["Unavailable"] = "Unavailable";
    EmbeddedEventDetails_Tags["Pending"] = "Pending";
    EmbeddedEventDetails_Tags["Ready"] = "Ready";
    EmbeddedEventDetails_Tags["Error"] = "Error";
})(EmbeddedEventDetails_Tags || (EmbeddedEventDetails_Tags = {}));
export const EmbeddedEventDetails = (() => {
    class Unavailable_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "EmbeddedEventDetails";
        tag = EmbeddedEventDetails_Tags.Unavailable;
        constructor() {
            super("EmbeddedEventDetails", "Unavailable");
        }
        static new() {
            return new Unavailable_();
        }
        static instanceOf(obj) {
            return obj.tag === EmbeddedEventDetails_Tags.Unavailable;
        }
    }
    class Pending_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "EmbeddedEventDetails";
        tag = EmbeddedEventDetails_Tags.Pending;
        constructor() {
            super("EmbeddedEventDetails", "Pending");
        }
        static new() {
            return new Pending_();
        }
        static instanceOf(obj) {
            return obj.tag === EmbeddedEventDetails_Tags.Pending;
        }
    }
    class Ready_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "EmbeddedEventDetails";
        tag = EmbeddedEventDetails_Tags.Ready;
        inner;
        constructor(inner) {
            super("EmbeddedEventDetails", "Ready");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Ready_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === EmbeddedEventDetails_Tags.Ready;
        }
    }
    class Error_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "EmbeddedEventDetails";
        tag = EmbeddedEventDetails_Tags.Error;
        inner;
        constructor(inner) {
            super("EmbeddedEventDetails", "Error");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Error_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === EmbeddedEventDetails_Tags.Error;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "EmbeddedEventDetails";
    }
    return Object.freeze({
        instanceOf,
        Unavailable: Unavailable_,
        Pending: Pending_,
        Ready: Ready_,
        Error: Error_
    });
})();
// FfiConverter for enum EmbeddedEventDetails
const FfiConverterTypeEmbeddedEventDetails = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new EmbeddedEventDetails.Unavailable();
                case 2: return new EmbeddedEventDetails.Pending();
                case 3: return new EmbeddedEventDetails.Ready({ content: FfiConverterTypeTimelineItemContent.read(from), sender: FfiConverterString.read(from), senderProfile: FfiConverterTypeProfileDetails.read(from), timestamp: FfiConverterTypeTimestamp.read(from), eventOrTransactionId: FfiConverterTypeEventOrTransactionId.read(from) });
                case 4: return new EmbeddedEventDetails.Error({ message: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case EmbeddedEventDetails_Tags.Unavailable: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case EmbeddedEventDetails_Tags.Pending: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case EmbeddedEventDetails_Tags.Ready: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterTypeTimelineItemContent.write(inner.content, into);
                    FfiConverterString.write(inner.sender, into);
                    FfiConverterTypeProfileDetails.write(inner.senderProfile, into);
                    FfiConverterTypeTimestamp.write(inner.timestamp, into);
                    FfiConverterTypeEventOrTransactionId.write(inner.eventOrTransactionId, into);
                    return;
                }
                case EmbeddedEventDetails_Tags.Error: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.message, into);
                    return;
                }
                default:
                    // Throwing from here means that EmbeddedEventDetails_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case EmbeddedEventDetails_Tags.Unavailable: {
                    return ordinalConverter.allocationSize(1);
                }
                case EmbeddedEventDetails_Tags.Pending: {
                    return ordinalConverter.allocationSize(2);
                }
                case EmbeddedEventDetails_Tags.Ready: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterTypeTimelineItemContent.allocationSize(inner.content);
                    size += FfiConverterString.allocationSize(inner.sender);
                    size += FfiConverterTypeProfileDetails.allocationSize(inner.senderProfile);
                    size += FfiConverterTypeTimestamp.allocationSize(inner.timestamp);
                    size += FfiConverterTypeEventOrTransactionId.allocationSize(inner.eventOrTransactionId);
                    return size;
                }
                case EmbeddedEventDetails_Tags.Error: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterString.allocationSize(inner.message);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: EnableRecoveryProgress
export var EnableRecoveryProgress_Tags;
(function (EnableRecoveryProgress_Tags) {
    EnableRecoveryProgress_Tags["Starting"] = "Starting";
    EnableRecoveryProgress_Tags["CreatingBackup"] = "CreatingBackup";
    EnableRecoveryProgress_Tags["CreatingRecoveryKey"] = "CreatingRecoveryKey";
    EnableRecoveryProgress_Tags["BackingUp"] = "BackingUp";
    EnableRecoveryProgress_Tags["RoomKeyUploadError"] = "RoomKeyUploadError";
    EnableRecoveryProgress_Tags["Done"] = "Done";
})(EnableRecoveryProgress_Tags || (EnableRecoveryProgress_Tags = {}));
export const EnableRecoveryProgress = (() => {
    class Starting_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "EnableRecoveryProgress";
        tag = EnableRecoveryProgress_Tags.Starting;
        constructor() {
            super("EnableRecoveryProgress", "Starting");
        }
        static new() {
            return new Starting_();
        }
        static instanceOf(obj) {
            return obj.tag === EnableRecoveryProgress_Tags.Starting;
        }
    }
    class CreatingBackup_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "EnableRecoveryProgress";
        tag = EnableRecoveryProgress_Tags.CreatingBackup;
        constructor() {
            super("EnableRecoveryProgress", "CreatingBackup");
        }
        static new() {
            return new CreatingBackup_();
        }
        static instanceOf(obj) {
            return obj.tag === EnableRecoveryProgress_Tags.CreatingBackup;
        }
    }
    class CreatingRecoveryKey_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "EnableRecoveryProgress";
        tag = EnableRecoveryProgress_Tags.CreatingRecoveryKey;
        constructor() {
            super("EnableRecoveryProgress", "CreatingRecoveryKey");
        }
        static new() {
            return new CreatingRecoveryKey_();
        }
        static instanceOf(obj) {
            return obj.tag === EnableRecoveryProgress_Tags.CreatingRecoveryKey;
        }
    }
    class BackingUp_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "EnableRecoveryProgress";
        tag = EnableRecoveryProgress_Tags.BackingUp;
        inner;
        constructor(inner) {
            super("EnableRecoveryProgress", "BackingUp");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new BackingUp_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === EnableRecoveryProgress_Tags.BackingUp;
        }
    }
    class RoomKeyUploadError_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "EnableRecoveryProgress";
        tag = EnableRecoveryProgress_Tags.RoomKeyUploadError;
        constructor() {
            super("EnableRecoveryProgress", "RoomKeyUploadError");
        }
        static new() {
            return new RoomKeyUploadError_();
        }
        static instanceOf(obj) {
            return obj.tag === EnableRecoveryProgress_Tags.RoomKeyUploadError;
        }
    }
    class Done_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "EnableRecoveryProgress";
        tag = EnableRecoveryProgress_Tags.Done;
        inner;
        constructor(inner) {
            super("EnableRecoveryProgress", "Done");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Done_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === EnableRecoveryProgress_Tags.Done;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "EnableRecoveryProgress";
    }
    return Object.freeze({
        instanceOf,
        Starting: Starting_,
        CreatingBackup: CreatingBackup_,
        CreatingRecoveryKey: CreatingRecoveryKey_,
        BackingUp: BackingUp_,
        RoomKeyUploadError: RoomKeyUploadError_,
        Done: Done_
    });
})();
// FfiConverter for enum EnableRecoveryProgress
const FfiConverterTypeEnableRecoveryProgress = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new EnableRecoveryProgress.Starting();
                case 2: return new EnableRecoveryProgress.CreatingBackup();
                case 3: return new EnableRecoveryProgress.CreatingRecoveryKey();
                case 4: return new EnableRecoveryProgress.BackingUp({ backedUpCount: FfiConverterUInt32.read(from), totalCount: FfiConverterUInt32.read(from) });
                case 5: return new EnableRecoveryProgress.RoomKeyUploadError();
                case 6: return new EnableRecoveryProgress.Done({ recoveryKey: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case EnableRecoveryProgress_Tags.Starting: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case EnableRecoveryProgress_Tags.CreatingBackup: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case EnableRecoveryProgress_Tags.CreatingRecoveryKey: {
                    ordinalConverter.write(3, into);
                    return;
                }
                case EnableRecoveryProgress_Tags.BackingUp: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterUInt32.write(inner.backedUpCount, into);
                    FfiConverterUInt32.write(inner.totalCount, into);
                    return;
                }
                case EnableRecoveryProgress_Tags.RoomKeyUploadError: {
                    ordinalConverter.write(5, into);
                    return;
                }
                case EnableRecoveryProgress_Tags.Done: {
                    ordinalConverter.write(6, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.recoveryKey, into);
                    return;
                }
                default:
                    // Throwing from here means that EnableRecoveryProgress_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case EnableRecoveryProgress_Tags.Starting: {
                    return ordinalConverter.allocationSize(1);
                }
                case EnableRecoveryProgress_Tags.CreatingBackup: {
                    return ordinalConverter.allocationSize(2);
                }
                case EnableRecoveryProgress_Tags.CreatingRecoveryKey: {
                    return ordinalConverter.allocationSize(3);
                }
                case EnableRecoveryProgress_Tags.BackingUp: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterUInt32.allocationSize(inner.backedUpCount);
                    size += FfiConverterUInt32.allocationSize(inner.totalCount);
                    return size;
                }
                case EnableRecoveryProgress_Tags.RoomKeyUploadError: {
                    return ordinalConverter.allocationSize(5);
                }
                case EnableRecoveryProgress_Tags.Done: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(6);
                    size += FfiConverterString.allocationSize(inner.recoveryKey);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: EncryptedMessage
export var EncryptedMessage_Tags;
(function (EncryptedMessage_Tags) {
    EncryptedMessage_Tags["OlmV1Curve25519AesSha2"] = "OlmV1Curve25519AesSha2";
    EncryptedMessage_Tags["MegolmV1AesSha2"] = "MegolmV1AesSha2";
    EncryptedMessage_Tags["Unknown"] = "Unknown";
})(EncryptedMessage_Tags || (EncryptedMessage_Tags = {}));
export const EncryptedMessage = (() => {
    class OlmV1Curve25519AesSha2_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "EncryptedMessage";
        tag = EncryptedMessage_Tags.OlmV1Curve25519AesSha2;
        inner;
        constructor(inner) {
            super("EncryptedMessage", "OlmV1Curve25519AesSha2");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new OlmV1Curve25519AesSha2_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === EncryptedMessage_Tags.OlmV1Curve25519AesSha2;
        }
    }
    class MegolmV1AesSha2_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "EncryptedMessage";
        tag = EncryptedMessage_Tags.MegolmV1AesSha2;
        inner;
        constructor(inner) {
            super("EncryptedMessage", "MegolmV1AesSha2");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new MegolmV1AesSha2_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === EncryptedMessage_Tags.MegolmV1AesSha2;
        }
    }
    class Unknown_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "EncryptedMessage";
        tag = EncryptedMessage_Tags.Unknown;
        constructor() {
            super("EncryptedMessage", "Unknown");
        }
        static new() {
            return new Unknown_();
        }
        static instanceOf(obj) {
            return obj.tag === EncryptedMessage_Tags.Unknown;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "EncryptedMessage";
    }
    return Object.freeze({
        instanceOf,
        OlmV1Curve25519AesSha2: OlmV1Curve25519AesSha2_,
        MegolmV1AesSha2: MegolmV1AesSha2_,
        Unknown: Unknown_
    });
})();
// FfiConverter for enum EncryptedMessage
const FfiConverterTypeEncryptedMessage = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new EncryptedMessage.OlmV1Curve25519AesSha2({ senderKey: FfiConverterString.read(from) });
                case 2: return new EncryptedMessage.MegolmV1AesSha2({ sessionId: FfiConverterString.read(from), cause: FfiConverterTypeUtdCause.read(from) });
                case 3: return new EncryptedMessage.Unknown();
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case EncryptedMessage_Tags.OlmV1Curve25519AesSha2: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.senderKey, into);
                    return;
                }
                case EncryptedMessage_Tags.MegolmV1AesSha2: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.sessionId, into);
                    FfiConverterTypeUtdCause.write(inner.cause, into);
                    return;
                }
                case EncryptedMessage_Tags.Unknown: {
                    ordinalConverter.write(3, into);
                    return;
                }
                default:
                    // Throwing from here means that EncryptedMessage_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case EncryptedMessage_Tags.OlmV1Curve25519AesSha2: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterString.allocationSize(inner.senderKey);
                    return size;
                }
                case EncryptedMessage_Tags.MegolmV1AesSha2: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterString.allocationSize(inner.sessionId);
                    size += FfiConverterTypeUtdCause.allocationSize(inner.cause);
                    return size;
                }
                case EncryptedMessage_Tags.Unknown: {
                    return ordinalConverter.allocationSize(3);
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: ErrorKind
export var ErrorKind_Tags;
(function (ErrorKind_Tags) {
    ErrorKind_Tags["BadAlias"] = "BadAlias";
    ErrorKind_Tags["BadJson"] = "BadJson";
    ErrorKind_Tags["BadState"] = "BadState";
    ErrorKind_Tags["BadStatus"] = "BadStatus";
    ErrorKind_Tags["CannotLeaveServerNoticeRoom"] = "CannotLeaveServerNoticeRoom";
    ErrorKind_Tags["CannotOverwriteMedia"] = "CannotOverwriteMedia";
    ErrorKind_Tags["CaptchaInvalid"] = "CaptchaInvalid";
    ErrorKind_Tags["CaptchaNeeded"] = "CaptchaNeeded";
    ErrorKind_Tags["ConnectionFailed"] = "ConnectionFailed";
    ErrorKind_Tags["ConnectionTimeout"] = "ConnectionTimeout";
    ErrorKind_Tags["DuplicateAnnotation"] = "DuplicateAnnotation";
    ErrorKind_Tags["Exclusive"] = "Exclusive";
    ErrorKind_Tags["Forbidden"] = "Forbidden";
    ErrorKind_Tags["GuestAccessForbidden"] = "GuestAccessForbidden";
    ErrorKind_Tags["IncompatibleRoomVersion"] = "IncompatibleRoomVersion";
    ErrorKind_Tags["InvalidParam"] = "InvalidParam";
    ErrorKind_Tags["InvalidRoomState"] = "InvalidRoomState";
    ErrorKind_Tags["InvalidUsername"] = "InvalidUsername";
    ErrorKind_Tags["LimitExceeded"] = "LimitExceeded";
    ErrorKind_Tags["MissingParam"] = "MissingParam";
    ErrorKind_Tags["MissingToken"] = "MissingToken";
    ErrorKind_Tags["NotFound"] = "NotFound";
    ErrorKind_Tags["NotJson"] = "NotJson";
    ErrorKind_Tags["NotYetUploaded"] = "NotYetUploaded";
    ErrorKind_Tags["ResourceLimitExceeded"] = "ResourceLimitExceeded";
    ErrorKind_Tags["RoomInUse"] = "RoomInUse";
    ErrorKind_Tags["ServerNotTrusted"] = "ServerNotTrusted";
    ErrorKind_Tags["ThreepidAuthFailed"] = "ThreepidAuthFailed";
    ErrorKind_Tags["ThreepidDenied"] = "ThreepidDenied";
    ErrorKind_Tags["ThreepidInUse"] = "ThreepidInUse";
    ErrorKind_Tags["ThreepidMediumNotSupported"] = "ThreepidMediumNotSupported";
    ErrorKind_Tags["ThreepidNotFound"] = "ThreepidNotFound";
    ErrorKind_Tags["TooLarge"] = "TooLarge";
    ErrorKind_Tags["UnableToAuthorizeJoin"] = "UnableToAuthorizeJoin";
    ErrorKind_Tags["UnableToGrantJoin"] = "UnableToGrantJoin";
    ErrorKind_Tags["Unauthorized"] = "Unauthorized";
    ErrorKind_Tags["Unknown"] = "Unknown";
    ErrorKind_Tags["UnknownToken"] = "UnknownToken";
    ErrorKind_Tags["Unrecognized"] = "Unrecognized";
    ErrorKind_Tags["UnsupportedRoomVersion"] = "UnsupportedRoomVersion";
    ErrorKind_Tags["UrlNotSet"] = "UrlNotSet";
    ErrorKind_Tags["UserDeactivated"] = "UserDeactivated";
    ErrorKind_Tags["UserInUse"] = "UserInUse";
    ErrorKind_Tags["UserLocked"] = "UserLocked";
    ErrorKind_Tags["UserSuspended"] = "UserSuspended";
    ErrorKind_Tags["WeakPassword"] = "WeakPassword";
    ErrorKind_Tags["WrongRoomKeysVersion"] = "WrongRoomKeysVersion";
    ErrorKind_Tags["Custom"] = "Custom";
})(ErrorKind_Tags || (ErrorKind_Tags = {}));
export const ErrorKind = (() => {
    /**
     * `M_BAD_ALIAS`
     *
     * One or more [room aliases] within the `m.room.canonical_alias` event do
     * not point to the room ID for which the state event is to be sent to.
     *
     * [room aliases]: https://spec.matrix.org/latest/client-server-api/#room-aliases
     */
    class BadAlias_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.BadAlias;
        constructor() {
            super("ErrorKind", "BadAlias");
        }
        static new() {
            return new BadAlias_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.BadAlias;
        }
    }
    /**
     * `M_BAD_JSON`
     *
     * The request contained valid JSON, but it was malformed in some way, e.g.
     * missing required keys, invalid values for keys.
     */
    class BadJson_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.BadJson;
        constructor() {
            super("ErrorKind", "BadJson");
        }
        static new() {
            return new BadJson_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.BadJson;
        }
    }
    /**
     * `M_BAD_STATE`
     *
     * The state change requested cannot be performed, such as attempting to
     * unban a user who is not banned.
     */
    class BadState_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.BadState;
        constructor() {
            super("ErrorKind", "BadState");
        }
        static new() {
            return new BadState_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.BadState;
        }
    }
    /**
     * `M_BAD_STATUS`
     *
     * The application service returned a bad status.
     */
    class BadStatus_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.BadStatus;
        inner;
        constructor(inner) {
            super("ErrorKind", "BadStatus");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new BadStatus_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.BadStatus;
        }
    }
    /**
     * `M_CANNOT_LEAVE_SERVER_NOTICE_ROOM`
     *
     * The user is unable to reject an invite to join the [server notices]
     * room.
     *
     * [server notices]: https://spec.matrix.org/latest/client-server-api/#server-notices
     */
    class CannotLeaveServerNoticeRoom_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.CannotLeaveServerNoticeRoom;
        constructor() {
            super("ErrorKind", "CannotLeaveServerNoticeRoom");
        }
        static new() {
            return new CannotLeaveServerNoticeRoom_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.CannotLeaveServerNoticeRoom;
        }
    }
    /**
     * `M_CANNOT_OVERWRITE_MEDIA`
     *
     * The [`create_content_async`] endpoint was called with a media ID that
     * already has content.
     *
     * [`create_content_async`]: crate::media::create_content_async
     */
    class CannotOverwriteMedia_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.CannotOverwriteMedia;
        constructor() {
            super("ErrorKind", "CannotOverwriteMedia");
        }
        static new() {
            return new CannotOverwriteMedia_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.CannotOverwriteMedia;
        }
    }
    /**
     * `M_CAPTCHA_INVALID`
     *
     * The Captcha provided did not match what was expected.
     */
    class CaptchaInvalid_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.CaptchaInvalid;
        constructor() {
            super("ErrorKind", "CaptchaInvalid");
        }
        static new() {
            return new CaptchaInvalid_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.CaptchaInvalid;
        }
    }
    /**
     * `M_CAPTCHA_NEEDED`
     *
     * A Captcha is required to complete the request.
     */
    class CaptchaNeeded_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.CaptchaNeeded;
        constructor() {
            super("ErrorKind", "CaptchaNeeded");
        }
        static new() {
            return new CaptchaNeeded_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.CaptchaNeeded;
        }
    }
    /**
     * `M_CONNECTION_FAILED`
     *
     * The connection to the application service failed.
     */
    class ConnectionFailed_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.ConnectionFailed;
        constructor() {
            super("ErrorKind", "ConnectionFailed");
        }
        static new() {
            return new ConnectionFailed_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.ConnectionFailed;
        }
    }
    /**
     * `M_CONNECTION_TIMEOUT`
     *
     * The connection to the application service timed out.
     */
    class ConnectionTimeout_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.ConnectionTimeout;
        constructor() {
            super("ErrorKind", "ConnectionTimeout");
        }
        static new() {
            return new ConnectionTimeout_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.ConnectionTimeout;
        }
    }
    /**
     * `M_DUPLICATE_ANNOTATION`
     *
     * The request is an attempt to send a [duplicate annotation].
     *
     * [duplicate annotation]: https://spec.matrix.org/latest/client-server-api/#avoiding-duplicate-annotations
     */
    class DuplicateAnnotation_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.DuplicateAnnotation;
        constructor() {
            super("ErrorKind", "DuplicateAnnotation");
        }
        static new() {
            return new DuplicateAnnotation_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.DuplicateAnnotation;
        }
    }
    /**
     * `M_EXCLUSIVE`
     *
     * The resource being requested is reserved by an application service, or
     * the application service making the request has not created the
     * resource.
     */
    class Exclusive_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.Exclusive;
        constructor() {
            super("ErrorKind", "Exclusive");
        }
        static new() {
            return new Exclusive_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.Exclusive;
        }
    }
    /**
     * `M_FORBIDDEN`
     *
     * Forbidden access, e.g. joining a room without permission, failed login.
     */
    class Forbidden_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.Forbidden;
        constructor() {
            super("ErrorKind", "Forbidden");
        }
        static new() {
            return new Forbidden_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.Forbidden;
        }
    }
    /**
     * `M_GUEST_ACCESS_FORBIDDEN`
     *
     * The room or resource does not permit [guests] to access it.
     *
     * [guests]: https://spec.matrix.org/latest/client-server-api/#guest-access
     */
    class GuestAccessForbidden_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.GuestAccessForbidden;
        constructor() {
            super("ErrorKind", "GuestAccessForbidden");
        }
        static new() {
            return new GuestAccessForbidden_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.GuestAccessForbidden;
        }
    }
    /**
     * `M_INCOMPATIBLE_ROOM_VERSION`
     *
     * The client attempted to join a room that has a version the server does
     * not support.
     */
    class IncompatibleRoomVersion_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.IncompatibleRoomVersion;
        inner;
        constructor(inner) {
            super("ErrorKind", "IncompatibleRoomVersion");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new IncompatibleRoomVersion_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.IncompatibleRoomVersion;
        }
    }
    /**
     * `M_INVALID_PARAM`
     *
     * A parameter that was specified has the wrong value. For example, the
     * server expected an integer and instead received a string.
     */
    class InvalidParam_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.InvalidParam;
        constructor() {
            super("ErrorKind", "InvalidParam");
        }
        static new() {
            return new InvalidParam_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.InvalidParam;
        }
    }
    /**
     * `M_INVALID_ROOM_STATE`
     *
     * The initial state implied by the parameters to the [`create_room`]
     * request is invalid, e.g. the user's `power_level` is set below that
     * necessary to set the room name.
     *
     * [`create_room`]: crate::room::create_room
     */
    class InvalidRoomState_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.InvalidRoomState;
        constructor() {
            super("ErrorKind", "InvalidRoomState");
        }
        static new() {
            return new InvalidRoomState_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.InvalidRoomState;
        }
    }
    /**
     * `M_INVALID_USERNAME`
     *
     * The desired user name is not valid.
     */
    class InvalidUsername_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.InvalidUsername;
        constructor() {
            super("ErrorKind", "InvalidUsername");
        }
        static new() {
            return new InvalidUsername_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.InvalidUsername;
        }
    }
    /**
     * `M_LIMIT_EXCEEDED`
     *
     * The request has been refused due to [rate limiting]: too many requests
     * have been sent in a short period of time.
     *
     * [rate limiting]: https://spec.matrix.org/latest/client-server-api/#rate-limiting
     */
    class LimitExceeded_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.LimitExceeded;
        inner;
        constructor(inner) {
            super("ErrorKind", "LimitExceeded");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new LimitExceeded_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.LimitExceeded;
        }
    }
    /**
     * `M_MISSING_PARAM`
     *
     * A required parameter was missing from the request.
     */
    class MissingParam_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.MissingParam;
        constructor() {
            super("ErrorKind", "MissingParam");
        }
        static new() {
            return new MissingParam_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.MissingParam;
        }
    }
    /**
     * `M_MISSING_TOKEN`
     *
     * No [access token] was specified for the request, but one is required.
     *
     * [access token]: https://spec.matrix.org/latest/client-server-api/#client-authentication
     */
    class MissingToken_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.MissingToken;
        constructor() {
            super("ErrorKind", "MissingToken");
        }
        static new() {
            return new MissingToken_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.MissingToken;
        }
    }
    /**
     * `M_NOT_FOUND`
     *
     * No resource was found for this request.
     */
    class NotFound_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.NotFound;
        constructor() {
            super("ErrorKind", "NotFound");
        }
        static new() {
            return new NotFound_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.NotFound;
        }
    }
    /**
     * `M_NOT_JSON`
     *
     * The request did not contain valid JSON.
     */
    class NotJson_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.NotJson;
        constructor() {
            super("ErrorKind", "NotJson");
        }
        static new() {
            return new NotJson_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.NotJson;
        }
    }
    /**
     * `M_NOT_YET_UPLOADED`
     *
     * An `mxc:` URI generated with the [`create_mxc_uri`] endpoint was used
     * and the content is not yet available.
     *
     * [`create_mxc_uri`]: crate::media::create_mxc_uri
     */
    class NotYetUploaded_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.NotYetUploaded;
        constructor() {
            super("ErrorKind", "NotYetUploaded");
        }
        static new() {
            return new NotYetUploaded_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.NotYetUploaded;
        }
    }
    /**
     * `M_RESOURCE_LIMIT_EXCEEDED`
     *
     * The request cannot be completed because the homeserver has reached a
     * resource limit imposed on it. For example, a homeserver held in a
     * shared hosting environment may reach a resource limit if it starts
     * using too much memory or disk space.
     */
    class ResourceLimitExceeded_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.ResourceLimitExceeded;
        inner;
        constructor(inner) {
            super("ErrorKind", "ResourceLimitExceeded");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new ResourceLimitExceeded_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.ResourceLimitExceeded;
        }
    }
    /**
     * `M_ROOM_IN_USE`
     *
     * The [room alias] specified in the [`create_room`] request is already
     * taken.
     *
     * [`create_room`]: crate::room::create_room
     * [room alias]: https://spec.matrix.org/latest/client-server-api/#room-aliases
     */
    class RoomInUse_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.RoomInUse;
        constructor() {
            super("ErrorKind", "RoomInUse");
        }
        static new() {
            return new RoomInUse_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.RoomInUse;
        }
    }
    /**
     * `M_SERVER_NOT_TRUSTED`
     *
     * The client's request used a third-party server, e.g. identity server,
     * that this server does not trust.
     */
    class ServerNotTrusted_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.ServerNotTrusted;
        constructor() {
            super("ErrorKind", "ServerNotTrusted");
        }
        static new() {
            return new ServerNotTrusted_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.ServerNotTrusted;
        }
    }
    /**
     * `M_THREEPID_AUTH_FAILED`
     *
     * Authentication could not be performed on the [third-party identifier].
     *
     * [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
     */
    class ThreepidAuthFailed_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.ThreepidAuthFailed;
        constructor() {
            super("ErrorKind", "ThreepidAuthFailed");
        }
        static new() {
            return new ThreepidAuthFailed_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.ThreepidAuthFailed;
        }
    }
    /**
     * `M_THREEPID_DENIED`
     *
     * The server does not permit this [third-party identifier]. This may
     * happen if the server only permits, for example, email addresses from
     * a particular domain.
     *
     * [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
     */
    class ThreepidDenied_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.ThreepidDenied;
        constructor() {
            super("ErrorKind", "ThreepidDenied");
        }
        static new() {
            return new ThreepidDenied_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.ThreepidDenied;
        }
    }
    /**
     * `M_THREEPID_IN_USE`
     *
     * The [third-party identifier] is already in use by another user.
     *
     * [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
     */
    class ThreepidInUse_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.ThreepidInUse;
        constructor() {
            super("ErrorKind", "ThreepidInUse");
        }
        static new() {
            return new ThreepidInUse_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.ThreepidInUse;
        }
    }
    /**
     * `M_THREEPID_MEDIUM_NOT_SUPPORTED`
     *
     * The homeserver does not support adding a [third-party identifier] of the
     * given medium.
     *
     * [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
     */
    class ThreepidMediumNotSupported_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.ThreepidMediumNotSupported;
        constructor() {
            super("ErrorKind", "ThreepidMediumNotSupported");
        }
        static new() {
            return new ThreepidMediumNotSupported_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.ThreepidMediumNotSupported;
        }
    }
    /**
     * `M_THREEPID_NOT_FOUND`
     *
     * No account matching the given [third-party identifier] could be found.
     *
     * [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
     */
    class ThreepidNotFound_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.ThreepidNotFound;
        constructor() {
            super("ErrorKind", "ThreepidNotFound");
        }
        static new() {
            return new ThreepidNotFound_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.ThreepidNotFound;
        }
    }
    /**
     * `M_TOO_LARGE`
     *
     * The request or entity was too large.
     */
    class TooLarge_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.TooLarge;
        constructor() {
            super("ErrorKind", "TooLarge");
        }
        static new() {
            return new TooLarge_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.TooLarge;
        }
    }
    /**
     * `M_UNABLE_TO_AUTHORISE_JOIN`
     *
     * The room is [restricted] and none of the conditions can be validated by
     * the homeserver. This can happen if the homeserver does not know
     * about any of the rooms listed as conditions, for example.
     *
     * [restricted]: https://spec.matrix.org/latest/client-server-api/#restricted-rooms
     */
    class UnableToAuthorizeJoin_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.UnableToAuthorizeJoin;
        constructor() {
            super("ErrorKind", "UnableToAuthorizeJoin");
        }
        static new() {
            return new UnableToAuthorizeJoin_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.UnableToAuthorizeJoin;
        }
    }
    /**
     * `M_UNABLE_TO_GRANT_JOIN`
     *
     * A different server should be attempted for the join. This is typically
     * because the resident server can see that the joining user satisfies
     * one or more conditions, such as in the case of [restricted rooms],
     * but the resident server would be unable to meet the authorization
     * rules.
     *
     * [restricted rooms]: https://spec.matrix.org/latest/client-server-api/#restricted-rooms
     */
    class UnableToGrantJoin_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.UnableToGrantJoin;
        constructor() {
            super("ErrorKind", "UnableToGrantJoin");
        }
        static new() {
            return new UnableToGrantJoin_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.UnableToGrantJoin;
        }
    }
    /**
     * `M_UNAUTHORIZED`
     *
     * The request was not correctly authorized. Usually due to login failures.
     */
    class Unauthorized_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.Unauthorized;
        constructor() {
            super("ErrorKind", "Unauthorized");
        }
        static new() {
            return new Unauthorized_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.Unauthorized;
        }
    }
    /**
     * `M_UNKNOWN`
     *
     * An unknown error has occurred.
     */
    class Unknown_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.Unknown;
        constructor() {
            super("ErrorKind", "Unknown");
        }
        static new() {
            return new Unknown_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.Unknown;
        }
    }
    /**
     * `M_UNKNOWN_TOKEN`
     *
     * The [access or refresh token] specified was not recognized.
     *
     * [access or refresh token]: https://spec.matrix.org/latest/client-server-api/#client-authentication
     */
    class UnknownToken_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.UnknownToken;
        inner;
        constructor(inner) {
            super("ErrorKind", "UnknownToken");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new UnknownToken_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.UnknownToken;
        }
    }
    /**
     * `M_UNRECOGNIZED`
     *
     * The server did not understand the request.
     *
     * This is expected to be returned with a 404 HTTP status code if the
     * endpoint is not implemented or a 405 HTTP status code if the
     * endpoint is implemented, but the incorrect HTTP method is used.
     */
    class Unrecognized_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.Unrecognized;
        constructor() {
            super("ErrorKind", "Unrecognized");
        }
        static new() {
            return new Unrecognized_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.Unrecognized;
        }
    }
    /**
     * `M_UNSUPPORTED_ROOM_VERSION`
     *
     * The request to [`create_room`] used a room version that the server does
     * not support.
     *
     * [`create_room`]: crate::room::create_room
     */
    class UnsupportedRoomVersion_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.UnsupportedRoomVersion;
        constructor() {
            super("ErrorKind", "UnsupportedRoomVersion");
        }
        static new() {
            return new UnsupportedRoomVersion_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.UnsupportedRoomVersion;
        }
    }
    /**
     * `M_URL_NOT_SET`
     *
     * The application service doesn't have a URL configured.
     */
    class UrlNotSet_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.UrlNotSet;
        constructor() {
            super("ErrorKind", "UrlNotSet");
        }
        static new() {
            return new UrlNotSet_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.UrlNotSet;
        }
    }
    /**
     * `M_USER_DEACTIVATED`
     *
     * The user ID associated with the request has been deactivated.
     */
    class UserDeactivated_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.UserDeactivated;
        constructor() {
            super("ErrorKind", "UserDeactivated");
        }
        static new() {
            return new UserDeactivated_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.UserDeactivated;
        }
    }
    /**
     * `M_USER_IN_USE`
     *
     * The desired user ID is already taken.
     */
    class UserInUse_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.UserInUse;
        constructor() {
            super("ErrorKind", "UserInUse");
        }
        static new() {
            return new UserInUse_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.UserInUse;
        }
    }
    /**
     * `M_USER_LOCKED`
     *
     * The account has been [locked] and cannot be used at this time.
     *
     * [locked]: https://spec.matrix.org/latest/client-server-api/#account-locking
     */
    class UserLocked_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.UserLocked;
        constructor() {
            super("ErrorKind", "UserLocked");
        }
        static new() {
            return new UserLocked_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.UserLocked;
        }
    }
    /**
     * `M_USER_SUSPENDED`
     *
     * The account has been [suspended] and can only be used for limited
     * actions at this time.
     *
     * [suspended]: https://spec.matrix.org/latest/client-server-api/#account-suspension
     */
    class UserSuspended_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.UserSuspended;
        constructor() {
            super("ErrorKind", "UserSuspended");
        }
        static new() {
            return new UserSuspended_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.UserSuspended;
        }
    }
    /**
     * `M_WEAK_PASSWORD`
     *
     * The password was [rejected] by the server for being too weak.
     *
     * [rejected]: https://spec.matrix.org/latest/client-server-api/#notes-on-password-management
     */
    class WeakPassword_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.WeakPassword;
        constructor() {
            super("ErrorKind", "WeakPassword");
        }
        static new() {
            return new WeakPassword_();
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.WeakPassword;
        }
    }
    /**
     * `M_WRONG_ROOM_KEYS_VERSION`
     *
     * The version of the [room keys backup] provided in the request does not
     * match the current backup version.
     *
     * [room keys backup]: https://spec.matrix.org/latest/client-server-api/#server-side-key-backups
     */
    class WrongRoomKeysVersion_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.WrongRoomKeysVersion;
        inner;
        constructor(inner) {
            super("ErrorKind", "WrongRoomKeysVersion");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new WrongRoomKeysVersion_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.WrongRoomKeysVersion;
        }
    }
    /**
     * A custom API error.
     */
    class Custom_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ErrorKind";
        tag = ErrorKind_Tags.Custom;
        inner;
        constructor(inner) {
            super("ErrorKind", "Custom");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Custom_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === ErrorKind_Tags.Custom;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "ErrorKind";
    }
    return Object.freeze({
        instanceOf,
        BadAlias: BadAlias_,
        BadJson: BadJson_,
        BadState: BadState_,
        BadStatus: BadStatus_,
        CannotLeaveServerNoticeRoom: CannotLeaveServerNoticeRoom_,
        CannotOverwriteMedia: CannotOverwriteMedia_,
        CaptchaInvalid: CaptchaInvalid_,
        CaptchaNeeded: CaptchaNeeded_,
        ConnectionFailed: ConnectionFailed_,
        ConnectionTimeout: ConnectionTimeout_,
        DuplicateAnnotation: DuplicateAnnotation_,
        Exclusive: Exclusive_,
        Forbidden: Forbidden_,
        GuestAccessForbidden: GuestAccessForbidden_,
        IncompatibleRoomVersion: IncompatibleRoomVersion_,
        InvalidParam: InvalidParam_,
        InvalidRoomState: InvalidRoomState_,
        InvalidUsername: InvalidUsername_,
        LimitExceeded: LimitExceeded_,
        MissingParam: MissingParam_,
        MissingToken: MissingToken_,
        NotFound: NotFound_,
        NotJson: NotJson_,
        NotYetUploaded: NotYetUploaded_,
        ResourceLimitExceeded: ResourceLimitExceeded_,
        RoomInUse: RoomInUse_,
        ServerNotTrusted: ServerNotTrusted_,
        ThreepidAuthFailed: ThreepidAuthFailed_,
        ThreepidDenied: ThreepidDenied_,
        ThreepidInUse: ThreepidInUse_,
        ThreepidMediumNotSupported: ThreepidMediumNotSupported_,
        ThreepidNotFound: ThreepidNotFound_,
        TooLarge: TooLarge_,
        UnableToAuthorizeJoin: UnableToAuthorizeJoin_,
        UnableToGrantJoin: UnableToGrantJoin_,
        Unauthorized: Unauthorized_,
        Unknown: Unknown_,
        UnknownToken: UnknownToken_,
        Unrecognized: Unrecognized_,
        UnsupportedRoomVersion: UnsupportedRoomVersion_,
        UrlNotSet: UrlNotSet_,
        UserDeactivated: UserDeactivated_,
        UserInUse: UserInUse_,
        UserLocked: UserLocked_,
        UserSuspended: UserSuspended_,
        WeakPassword: WeakPassword_,
        WrongRoomKeysVersion: WrongRoomKeysVersion_,
        Custom: Custom_
    });
})();
// FfiConverter for enum ErrorKind
const FfiConverterTypeErrorKind = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new ErrorKind.BadAlias();
                case 2: return new ErrorKind.BadJson();
                case 3: return new ErrorKind.BadState();
                case 4: return new ErrorKind.BadStatus({ status: FfiConverterOptionalUInt16.read(from), body: FfiConverterOptionalString.read(from) });
                case 5: return new ErrorKind.CannotLeaveServerNoticeRoom();
                case 6: return new ErrorKind.CannotOverwriteMedia();
                case 7: return new ErrorKind.CaptchaInvalid();
                case 8: return new ErrorKind.CaptchaNeeded();
                case 9: return new ErrorKind.ConnectionFailed();
                case 10: return new ErrorKind.ConnectionTimeout();
                case 11: return new ErrorKind.DuplicateAnnotation();
                case 12: return new ErrorKind.Exclusive();
                case 13: return new ErrorKind.Forbidden();
                case 14: return new ErrorKind.GuestAccessForbidden();
                case 15: return new ErrorKind.IncompatibleRoomVersion({ roomVersion: FfiConverterString.read(from) });
                case 16: return new ErrorKind.InvalidParam();
                case 17: return new ErrorKind.InvalidRoomState();
                case 18: return new ErrorKind.InvalidUsername();
                case 19: return new ErrorKind.LimitExceeded({ retryAfterMs: FfiConverterOptionalUInt64.read(from) });
                case 20: return new ErrorKind.MissingParam();
                case 21: return new ErrorKind.MissingToken();
                case 22: return new ErrorKind.NotFound();
                case 23: return new ErrorKind.NotJson();
                case 24: return new ErrorKind.NotYetUploaded();
                case 25: return new ErrorKind.ResourceLimitExceeded({ adminContact: FfiConverterString.read(from) });
                case 26: return new ErrorKind.RoomInUse();
                case 27: return new ErrorKind.ServerNotTrusted();
                case 28: return new ErrorKind.ThreepidAuthFailed();
                case 29: return new ErrorKind.ThreepidDenied();
                case 30: return new ErrorKind.ThreepidInUse();
                case 31: return new ErrorKind.ThreepidMediumNotSupported();
                case 32: return new ErrorKind.ThreepidNotFound();
                case 33: return new ErrorKind.TooLarge();
                case 34: return new ErrorKind.UnableToAuthorizeJoin();
                case 35: return new ErrorKind.UnableToGrantJoin();
                case 36: return new ErrorKind.Unauthorized();
                case 37: return new ErrorKind.Unknown();
                case 38: return new ErrorKind.UnknownToken({ softLogout: FfiConverterBool.read(from) });
                case 39: return new ErrorKind.Unrecognized();
                case 40: return new ErrorKind.UnsupportedRoomVersion();
                case 41: return new ErrorKind.UrlNotSet();
                case 42: return new ErrorKind.UserDeactivated();
                case 43: return new ErrorKind.UserInUse();
                case 44: return new ErrorKind.UserLocked();
                case 45: return new ErrorKind.UserSuspended();
                case 46: return new ErrorKind.WeakPassword();
                case 47: return new ErrorKind.WrongRoomKeysVersion({ currentVersion: FfiConverterOptionalString.read(from) });
                case 48: return new ErrorKind.Custom({ errcode: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case ErrorKind_Tags.BadAlias: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case ErrorKind_Tags.BadJson: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case ErrorKind_Tags.BadState: {
                    ordinalConverter.write(3, into);
                    return;
                }
                case ErrorKind_Tags.BadStatus: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterOptionalUInt16.write(inner.status, into);
                    FfiConverterOptionalString.write(inner.body, into);
                    return;
                }
                case ErrorKind_Tags.CannotLeaveServerNoticeRoom: {
                    ordinalConverter.write(5, into);
                    return;
                }
                case ErrorKind_Tags.CannotOverwriteMedia: {
                    ordinalConverter.write(6, into);
                    return;
                }
                case ErrorKind_Tags.CaptchaInvalid: {
                    ordinalConverter.write(7, into);
                    return;
                }
                case ErrorKind_Tags.CaptchaNeeded: {
                    ordinalConverter.write(8, into);
                    return;
                }
                case ErrorKind_Tags.ConnectionFailed: {
                    ordinalConverter.write(9, into);
                    return;
                }
                case ErrorKind_Tags.ConnectionTimeout: {
                    ordinalConverter.write(10, into);
                    return;
                }
                case ErrorKind_Tags.DuplicateAnnotation: {
                    ordinalConverter.write(11, into);
                    return;
                }
                case ErrorKind_Tags.Exclusive: {
                    ordinalConverter.write(12, into);
                    return;
                }
                case ErrorKind_Tags.Forbidden: {
                    ordinalConverter.write(13, into);
                    return;
                }
                case ErrorKind_Tags.GuestAccessForbidden: {
                    ordinalConverter.write(14, into);
                    return;
                }
                case ErrorKind_Tags.IncompatibleRoomVersion: {
                    ordinalConverter.write(15, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.roomVersion, into);
                    return;
                }
                case ErrorKind_Tags.InvalidParam: {
                    ordinalConverter.write(16, into);
                    return;
                }
                case ErrorKind_Tags.InvalidRoomState: {
                    ordinalConverter.write(17, into);
                    return;
                }
                case ErrorKind_Tags.InvalidUsername: {
                    ordinalConverter.write(18, into);
                    return;
                }
                case ErrorKind_Tags.LimitExceeded: {
                    ordinalConverter.write(19, into);
                    const inner = value.inner;
                    FfiConverterOptionalUInt64.write(inner.retryAfterMs, into);
                    return;
                }
                case ErrorKind_Tags.MissingParam: {
                    ordinalConverter.write(20, into);
                    return;
                }
                case ErrorKind_Tags.MissingToken: {
                    ordinalConverter.write(21, into);
                    return;
                }
                case ErrorKind_Tags.NotFound: {
                    ordinalConverter.write(22, into);
                    return;
                }
                case ErrorKind_Tags.NotJson: {
                    ordinalConverter.write(23, into);
                    return;
                }
                case ErrorKind_Tags.NotYetUploaded: {
                    ordinalConverter.write(24, into);
                    return;
                }
                case ErrorKind_Tags.ResourceLimitExceeded: {
                    ordinalConverter.write(25, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.adminContact, into);
                    return;
                }
                case ErrorKind_Tags.RoomInUse: {
                    ordinalConverter.write(26, into);
                    return;
                }
                case ErrorKind_Tags.ServerNotTrusted: {
                    ordinalConverter.write(27, into);
                    return;
                }
                case ErrorKind_Tags.ThreepidAuthFailed: {
                    ordinalConverter.write(28, into);
                    return;
                }
                case ErrorKind_Tags.ThreepidDenied: {
                    ordinalConverter.write(29, into);
                    return;
                }
                case ErrorKind_Tags.ThreepidInUse: {
                    ordinalConverter.write(30, into);
                    return;
                }
                case ErrorKind_Tags.ThreepidMediumNotSupported: {
                    ordinalConverter.write(31, into);
                    return;
                }
                case ErrorKind_Tags.ThreepidNotFound: {
                    ordinalConverter.write(32, into);
                    return;
                }
                case ErrorKind_Tags.TooLarge: {
                    ordinalConverter.write(33, into);
                    return;
                }
                case ErrorKind_Tags.UnableToAuthorizeJoin: {
                    ordinalConverter.write(34, into);
                    return;
                }
                case ErrorKind_Tags.UnableToGrantJoin: {
                    ordinalConverter.write(35, into);
                    return;
                }
                case ErrorKind_Tags.Unauthorized: {
                    ordinalConverter.write(36, into);
                    return;
                }
                case ErrorKind_Tags.Unknown: {
                    ordinalConverter.write(37, into);
                    return;
                }
                case ErrorKind_Tags.UnknownToken: {
                    ordinalConverter.write(38, into);
                    const inner = value.inner;
                    FfiConverterBool.write(inner.softLogout, into);
                    return;
                }
                case ErrorKind_Tags.Unrecognized: {
                    ordinalConverter.write(39, into);
                    return;
                }
                case ErrorKind_Tags.UnsupportedRoomVersion: {
                    ordinalConverter.write(40, into);
                    return;
                }
                case ErrorKind_Tags.UrlNotSet: {
                    ordinalConverter.write(41, into);
                    return;
                }
                case ErrorKind_Tags.UserDeactivated: {
                    ordinalConverter.write(42, into);
                    return;
                }
                case ErrorKind_Tags.UserInUse: {
                    ordinalConverter.write(43, into);
                    return;
                }
                case ErrorKind_Tags.UserLocked: {
                    ordinalConverter.write(44, into);
                    return;
                }
                case ErrorKind_Tags.UserSuspended: {
                    ordinalConverter.write(45, into);
                    return;
                }
                case ErrorKind_Tags.WeakPassword: {
                    ordinalConverter.write(46, into);
                    return;
                }
                case ErrorKind_Tags.WrongRoomKeysVersion: {
                    ordinalConverter.write(47, into);
                    const inner = value.inner;
                    FfiConverterOptionalString.write(inner.currentVersion, into);
                    return;
                }
                case ErrorKind_Tags.Custom: {
                    ordinalConverter.write(48, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.errcode, into);
                    return;
                }
                default:
                    // Throwing from here means that ErrorKind_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case ErrorKind_Tags.BadAlias: {
                    return ordinalConverter.allocationSize(1);
                }
                case ErrorKind_Tags.BadJson: {
                    return ordinalConverter.allocationSize(2);
                }
                case ErrorKind_Tags.BadState: {
                    return ordinalConverter.allocationSize(3);
                }
                case ErrorKind_Tags.BadStatus: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterOptionalUInt16.allocationSize(inner.status);
                    size += FfiConverterOptionalString.allocationSize(inner.body);
                    return size;
                }
                case ErrorKind_Tags.CannotLeaveServerNoticeRoom: {
                    return ordinalConverter.allocationSize(5);
                }
                case ErrorKind_Tags.CannotOverwriteMedia: {
                    return ordinalConverter.allocationSize(6);
                }
                case ErrorKind_Tags.CaptchaInvalid: {
                    return ordinalConverter.allocationSize(7);
                }
                case ErrorKind_Tags.CaptchaNeeded: {
                    return ordinalConverter.allocationSize(8);
                }
                case ErrorKind_Tags.ConnectionFailed: {
                    return ordinalConverter.allocationSize(9);
                }
                case ErrorKind_Tags.ConnectionTimeout: {
                    return ordinalConverter.allocationSize(10);
                }
                case ErrorKind_Tags.DuplicateAnnotation: {
                    return ordinalConverter.allocationSize(11);
                }
                case ErrorKind_Tags.Exclusive: {
                    return ordinalConverter.allocationSize(12);
                }
                case ErrorKind_Tags.Forbidden: {
                    return ordinalConverter.allocationSize(13);
                }
                case ErrorKind_Tags.GuestAccessForbidden: {
                    return ordinalConverter.allocationSize(14);
                }
                case ErrorKind_Tags.IncompatibleRoomVersion: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(15);
                    size += FfiConverterString.allocationSize(inner.roomVersion);
                    return size;
                }
                case ErrorKind_Tags.InvalidParam: {
                    return ordinalConverter.allocationSize(16);
                }
                case ErrorKind_Tags.InvalidRoomState: {
                    return ordinalConverter.allocationSize(17);
                }
                case ErrorKind_Tags.InvalidUsername: {
                    return ordinalConverter.allocationSize(18);
                }
                case ErrorKind_Tags.LimitExceeded: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(19);
                    size += FfiConverterOptionalUInt64.allocationSize(inner.retryAfterMs);
                    return size;
                }
                case ErrorKind_Tags.MissingParam: {
                    return ordinalConverter.allocationSize(20);
                }
                case ErrorKind_Tags.MissingToken: {
                    return ordinalConverter.allocationSize(21);
                }
                case ErrorKind_Tags.NotFound: {
                    return ordinalConverter.allocationSize(22);
                }
                case ErrorKind_Tags.NotJson: {
                    return ordinalConverter.allocationSize(23);
                }
                case ErrorKind_Tags.NotYetUploaded: {
                    return ordinalConverter.allocationSize(24);
                }
                case ErrorKind_Tags.ResourceLimitExceeded: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(25);
                    size += FfiConverterString.allocationSize(inner.adminContact);
                    return size;
                }
                case ErrorKind_Tags.RoomInUse: {
                    return ordinalConverter.allocationSize(26);
                }
                case ErrorKind_Tags.ServerNotTrusted: {
                    return ordinalConverter.allocationSize(27);
                }
                case ErrorKind_Tags.ThreepidAuthFailed: {
                    return ordinalConverter.allocationSize(28);
                }
                case ErrorKind_Tags.ThreepidDenied: {
                    return ordinalConverter.allocationSize(29);
                }
                case ErrorKind_Tags.ThreepidInUse: {
                    return ordinalConverter.allocationSize(30);
                }
                case ErrorKind_Tags.ThreepidMediumNotSupported: {
                    return ordinalConverter.allocationSize(31);
                }
                case ErrorKind_Tags.ThreepidNotFound: {
                    return ordinalConverter.allocationSize(32);
                }
                case ErrorKind_Tags.TooLarge: {
                    return ordinalConverter.allocationSize(33);
                }
                case ErrorKind_Tags.UnableToAuthorizeJoin: {
                    return ordinalConverter.allocationSize(34);
                }
                case ErrorKind_Tags.UnableToGrantJoin: {
                    return ordinalConverter.allocationSize(35);
                }
                case ErrorKind_Tags.Unauthorized: {
                    return ordinalConverter.allocationSize(36);
                }
                case ErrorKind_Tags.Unknown: {
                    return ordinalConverter.allocationSize(37);
                }
                case ErrorKind_Tags.UnknownToken: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(38);
                    size += FfiConverterBool.allocationSize(inner.softLogout);
                    return size;
                }
                case ErrorKind_Tags.Unrecognized: {
                    return ordinalConverter.allocationSize(39);
                }
                case ErrorKind_Tags.UnsupportedRoomVersion: {
                    return ordinalConverter.allocationSize(40);
                }
                case ErrorKind_Tags.UrlNotSet: {
                    return ordinalConverter.allocationSize(41);
                }
                case ErrorKind_Tags.UserDeactivated: {
                    return ordinalConverter.allocationSize(42);
                }
                case ErrorKind_Tags.UserInUse: {
                    return ordinalConverter.allocationSize(43);
                }
                case ErrorKind_Tags.UserLocked: {
                    return ordinalConverter.allocationSize(44);
                }
                case ErrorKind_Tags.UserSuspended: {
                    return ordinalConverter.allocationSize(45);
                }
                case ErrorKind_Tags.WeakPassword: {
                    return ordinalConverter.allocationSize(46);
                }
                case ErrorKind_Tags.WrongRoomKeysVersion: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(47);
                    size += FfiConverterOptionalString.allocationSize(inner.currentVersion);
                    return size;
                }
                case ErrorKind_Tags.Custom: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(48);
                    size += FfiConverterString.allocationSize(inner.errcode);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: EventOrTransactionId
export var EventOrTransactionId_Tags;
(function (EventOrTransactionId_Tags) {
    EventOrTransactionId_Tags["EventId"] = "EventId";
    EventOrTransactionId_Tags["TransactionId"] = "TransactionId";
})(EventOrTransactionId_Tags || (EventOrTransactionId_Tags = {}));
/**
 * Contains the 2 possible identifiers of an event, either it has a remote
 * event id or a local transaction id, never both or none.
 */
export const EventOrTransactionId = (() => {
    class EventId_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "EventOrTransactionId";
        tag = EventOrTransactionId_Tags.EventId;
        inner;
        constructor(inner) {
            super("EventOrTransactionId", "EventId");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new EventId_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === EventOrTransactionId_Tags.EventId;
        }
    }
    class TransactionId_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "EventOrTransactionId";
        tag = EventOrTransactionId_Tags.TransactionId;
        inner;
        constructor(inner) {
            super("EventOrTransactionId", "TransactionId");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new TransactionId_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === EventOrTransactionId_Tags.TransactionId;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "EventOrTransactionId";
    }
    return Object.freeze({
        instanceOf,
        EventId: EventId_,
        TransactionId: TransactionId_
    });
})();
// FfiConverter for enum EventOrTransactionId
const FfiConverterTypeEventOrTransactionId = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new EventOrTransactionId.EventId({ eventId: FfiConverterString.read(from) });
                case 2: return new EventOrTransactionId.TransactionId({ transactionId: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case EventOrTransactionId_Tags.EventId: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.eventId, into);
                    return;
                }
                case EventOrTransactionId_Tags.TransactionId: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.transactionId, into);
                    return;
                }
                default:
                    // Throwing from here means that EventOrTransactionId_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case EventOrTransactionId_Tags.EventId: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterString.allocationSize(inner.eventId);
                    return size;
                }
                case EventOrTransactionId_Tags.TransactionId: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterString.allocationSize(inner.transactionId);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: EventSendState
export var EventSendState_Tags;
(function (EventSendState_Tags) {
    EventSendState_Tags["NotSentYet"] = "NotSentYet";
    EventSendState_Tags["SendingFailed"] = "SendingFailed";
    EventSendState_Tags["Sent"] = "Sent";
})(EventSendState_Tags || (EventSendState_Tags = {}));
/**
 * This type represents the send state of a local event timeline item.
 */
export const EventSendState = (() => {
    /**
     * The local event has not been sent yet.
     */
    class NotSentYet_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "EventSendState";
        tag = EventSendState_Tags.NotSentYet;
        inner;
        constructor(inner) {
            super("EventSendState", "NotSentYet");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new NotSentYet_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === EventSendState_Tags.NotSentYet;
        }
    }
    /**
     * The local event has been sent to the server, but unsuccessfully: The
     * sending has failed.
     */
    class SendingFailed_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "EventSendState";
        tag = EventSendState_Tags.SendingFailed;
        inner;
        constructor(inner) {
            super("EventSendState", "SendingFailed");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new SendingFailed_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === EventSendState_Tags.SendingFailed;
        }
    }
    /**
     * The local event has been sent successfully to the server.
     */
    class Sent_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "EventSendState";
        tag = EventSendState_Tags.Sent;
        inner;
        constructor(inner) {
            super("EventSendState", "Sent");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Sent_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === EventSendState_Tags.Sent;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "EventSendState";
    }
    return Object.freeze({
        instanceOf,
        NotSentYet: NotSentYet_,
        SendingFailed: SendingFailed_,
        Sent: Sent_
    });
})();
// FfiConverter for enum EventSendState
const FfiConverterTypeEventSendState = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new EventSendState.NotSentYet({ progress: FfiConverterOptionalTypeMediaUploadProgress.read(from) });
                case 2: return new EventSendState.SendingFailed({ error: FfiConverterTypeQueueWedgeError.read(from), isRecoverable: FfiConverterBool.read(from) });
                case 3: return new EventSendState.Sent({ eventId: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case EventSendState_Tags.NotSentYet: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterOptionalTypeMediaUploadProgress.write(inner.progress, into);
                    return;
                }
                case EventSendState_Tags.SendingFailed: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterTypeQueueWedgeError.write(inner.error, into);
                    FfiConverterBool.write(inner.isRecoverable, into);
                    return;
                }
                case EventSendState_Tags.Sent: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.eventId, into);
                    return;
                }
                default:
                    // Throwing from here means that EventSendState_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case EventSendState_Tags.NotSentYet: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterOptionalTypeMediaUploadProgress.allocationSize(inner.progress);
                    return size;
                }
                case EventSendState_Tags.SendingFailed: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterTypeQueueWedgeError.allocationSize(inner.error);
                    size += FfiConverterBool.allocationSize(inner.isRecoverable);
                    return size;
                }
                case EventSendState_Tags.Sent: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterString.allocationSize(inner.eventId);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: FilterTimelineEventType
export var FilterTimelineEventType_Tags;
(function (FilterTimelineEventType_Tags) {
    FilterTimelineEventType_Tags["MessageLike"] = "MessageLike";
    FilterTimelineEventType_Tags["State"] = "State";
})(FilterTimelineEventType_Tags || (FilterTimelineEventType_Tags = {}));
export const FilterTimelineEventType = (() => {
    class MessageLike_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "FilterTimelineEventType";
        tag = FilterTimelineEventType_Tags.MessageLike;
        inner;
        constructor(inner) {
            super("FilterTimelineEventType", "MessageLike");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new MessageLike_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === FilterTimelineEventType_Tags.MessageLike;
        }
    }
    class State_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "FilterTimelineEventType";
        tag = FilterTimelineEventType_Tags.State;
        inner;
        constructor(inner) {
            super("FilterTimelineEventType", "State");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new State_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === FilterTimelineEventType_Tags.State;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "FilterTimelineEventType";
    }
    return Object.freeze({
        instanceOf,
        MessageLike: MessageLike_,
        State: State_
    });
})();
// FfiConverter for enum FilterTimelineEventType
const FfiConverterTypeFilterTimelineEventType = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new FilterTimelineEventType.MessageLike({ eventType: FfiConverterTypeMessageLikeEventType.read(from) });
                case 2: return new FilterTimelineEventType.State({ eventType: FfiConverterTypeStateEventType.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case FilterTimelineEventType_Tags.MessageLike: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterTypeMessageLikeEventType.write(inner.eventType, into);
                    return;
                }
                case FilterTimelineEventType_Tags.State: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterTypeStateEventType.write(inner.eventType, into);
                    return;
                }
                default:
                    // Throwing from here means that FilterTimelineEventType_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case FilterTimelineEventType_Tags.MessageLike: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterTypeMessageLikeEventType.allocationSize(inner.eventType);
                    return size;
                }
                case FilterTimelineEventType_Tags.State: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterTypeStateEventType.allocationSize(inner.eventType);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Error type: FocusEventError
// Enum: FocusEventError
export var FocusEventError_Tags;
(function (FocusEventError_Tags) {
    FocusEventError_Tags["InvalidEventId"] = "InvalidEventId";
    FocusEventError_Tags["EventNotFound"] = "EventNotFound";
    FocusEventError_Tags["Other"] = "Other";
})(FocusEventError_Tags || (FocusEventError_Tags = {}));
export const FocusEventError = (() => {
    class InvalidEventId_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "FocusEventError";
        tag = FocusEventError_Tags.InvalidEventId;
        inner;
        constructor(inner) {
            super("FocusEventError", "InvalidEventId");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new InvalidEventId_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === FocusEventError_Tags.InvalidEventId;
        }
        static hasInner(obj) {
            return InvalidEventId_.instanceOf(obj);
        }
        static getInner(obj) {
            return obj.inner;
        }
    }
    class EventNotFound_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "FocusEventError";
        tag = FocusEventError_Tags.EventNotFound;
        inner;
        constructor(inner) {
            super("FocusEventError", "EventNotFound");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new EventNotFound_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === FocusEventError_Tags.EventNotFound;
        }
        static hasInner(obj) {
            return EventNotFound_.instanceOf(obj);
        }
        static getInner(obj) {
            return obj.inner;
        }
    }
    class Other_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "FocusEventError";
        tag = FocusEventError_Tags.Other;
        inner;
        constructor(inner) {
            super("FocusEventError", "Other");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Other_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === FocusEventError_Tags.Other;
        }
        static hasInner(obj) {
            return Other_.instanceOf(obj);
        }
        static getInner(obj) {
            return obj.inner;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "FocusEventError";
    }
    return Object.freeze({
        instanceOf,
        InvalidEventId: InvalidEventId_,
        EventNotFound: EventNotFound_,
        Other: Other_
    });
})();
// FfiConverter for enum FocusEventError
const FfiConverterTypeFocusEventError = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new FocusEventError.InvalidEventId({ eventId: FfiConverterString.read(from), err: FfiConverterString.read(from) });
                case 2: return new FocusEventError.EventNotFound({ eventId: FfiConverterString.read(from) });
                case 3: return new FocusEventError.Other({ msg: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case FocusEventError_Tags.InvalidEventId: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.eventId, into);
                    FfiConverterString.write(inner.err, into);
                    return;
                }
                case FocusEventError_Tags.EventNotFound: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.eventId, into);
                    return;
                }
                case FocusEventError_Tags.Other: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.msg, into);
                    return;
                }
                default:
                    // Throwing from here means that FocusEventError_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case FocusEventError_Tags.InvalidEventId: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterString.allocationSize(inner.eventId);
                    size += FfiConverterString.allocationSize(inner.err);
                    return size;
                }
                case FocusEventError_Tags.EventNotFound: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterString.allocationSize(inner.eventId);
                    return size;
                }
                case FocusEventError_Tags.Other: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterString.allocationSize(inner.msg);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: GeneratedQrLoginProgress
export var GeneratedQrLoginProgress_Tags;
(function (GeneratedQrLoginProgress_Tags) {
    GeneratedQrLoginProgress_Tags["Starting"] = "Starting";
    GeneratedQrLoginProgress_Tags["QrReady"] = "QrReady";
    GeneratedQrLoginProgress_Tags["QrScanned"] = "QrScanned";
    GeneratedQrLoginProgress_Tags["WaitingForToken"] = "WaitingForToken";
    GeneratedQrLoginProgress_Tags["SyncingSecrets"] = "SyncingSecrets";
    GeneratedQrLoginProgress_Tags["Done"] = "Done";
})(GeneratedQrLoginProgress_Tags || (GeneratedQrLoginProgress_Tags = {}));
/**
 * Enum describing the progress of logging in by generating a QR code and
 * having an existing device scan it.
 */
export const GeneratedQrLoginProgress = (() => {
    /**
     * The login process is starting.
     */
    class Starting_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "GeneratedQrLoginProgress";
        tag = GeneratedQrLoginProgress_Tags.Starting;
        constructor() {
            super("GeneratedQrLoginProgress", "Starting");
        }
        static new() {
            return new Starting_();
        }
        static instanceOf(obj) {
            return obj.tag === GeneratedQrLoginProgress_Tags.Starting;
        }
    }
    /**
     * We have established the secure channel and now need to display the
     * QR code so that the existing device can scan it.
     */
    class QrReady_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "GeneratedQrLoginProgress";
        tag = GeneratedQrLoginProgress_Tags.QrReady;
        inner;
        constructor(inner) {
            super("GeneratedQrLoginProgress", "QrReady");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new QrReady_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === GeneratedQrLoginProgress_Tags.QrReady;
        }
    }
    /**
     * The existing device has scanned the QR code and is displaying the
     * checkcode. We now need to ask the user to enter the checkcode so that
     * we can verify that the channel is indeed secure.
     */
    class QrScanned_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "GeneratedQrLoginProgress";
        tag = GeneratedQrLoginProgress_Tags.QrScanned;
        inner;
        constructor(inner) {
            super("GeneratedQrLoginProgress", "QrScanned");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new QrScanned_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === GeneratedQrLoginProgress_Tags.QrScanned;
        }
    }
    /**
     * We are waiting for the login and for the OAuth 2.0 authorization server
     * to give us an access token.
     */
    class WaitingForToken_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "GeneratedQrLoginProgress";
        tag = GeneratedQrLoginProgress_Tags.WaitingForToken;
        inner;
        constructor(inner) {
            super("GeneratedQrLoginProgress", "WaitingForToken");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new WaitingForToken_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === GeneratedQrLoginProgress_Tags.WaitingForToken;
        }
    }
    /**
     * We are syncing secrets.
     */
    class SyncingSecrets_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "GeneratedQrLoginProgress";
        tag = GeneratedQrLoginProgress_Tags.SyncingSecrets;
        constructor() {
            super("GeneratedQrLoginProgress", "SyncingSecrets");
        }
        static new() {
            return new SyncingSecrets_();
        }
        static instanceOf(obj) {
            return obj.tag === GeneratedQrLoginProgress_Tags.SyncingSecrets;
        }
    }
    /**
     * The login has successfully finished.
     */
    class Done_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "GeneratedQrLoginProgress";
        tag = GeneratedQrLoginProgress_Tags.Done;
        constructor() {
            super("GeneratedQrLoginProgress", "Done");
        }
        static new() {
            return new Done_();
        }
        static instanceOf(obj) {
            return obj.tag === GeneratedQrLoginProgress_Tags.Done;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "GeneratedQrLoginProgress";
    }
    return Object.freeze({
        instanceOf,
        Starting: Starting_,
        QrReady: QrReady_,
        QrScanned: QrScanned_,
        WaitingForToken: WaitingForToken_,
        SyncingSecrets: SyncingSecrets_,
        Done: Done_
    });
})();
// FfiConverter for enum GeneratedQrLoginProgress
const FfiConverterTypeGeneratedQrLoginProgress = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new GeneratedQrLoginProgress.Starting();
                case 2: return new GeneratedQrLoginProgress.QrReady({ qrCode: FfiConverterTypeQrCodeData.read(from) });
                case 3: return new GeneratedQrLoginProgress.QrScanned({ checkCodeSender: FfiConverterTypeCheckCodeSender.read(from) });
                case 4: return new GeneratedQrLoginProgress.WaitingForToken({ userCode: FfiConverterString.read(from) });
                case 5: return new GeneratedQrLoginProgress.SyncingSecrets();
                case 6: return new GeneratedQrLoginProgress.Done();
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case GeneratedQrLoginProgress_Tags.Starting: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case GeneratedQrLoginProgress_Tags.QrReady: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterTypeQrCodeData.write(inner.qrCode, into);
                    return;
                }
                case GeneratedQrLoginProgress_Tags.QrScanned: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterTypeCheckCodeSender.write(inner.checkCodeSender, into);
                    return;
                }
                case GeneratedQrLoginProgress_Tags.WaitingForToken: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.userCode, into);
                    return;
                }
                case GeneratedQrLoginProgress_Tags.SyncingSecrets: {
                    ordinalConverter.write(5, into);
                    return;
                }
                case GeneratedQrLoginProgress_Tags.Done: {
                    ordinalConverter.write(6, into);
                    return;
                }
                default:
                    // Throwing from here means that GeneratedQrLoginProgress_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case GeneratedQrLoginProgress_Tags.Starting: {
                    return ordinalConverter.allocationSize(1);
                }
                case GeneratedQrLoginProgress_Tags.QrReady: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterTypeQrCodeData.allocationSize(inner.qrCode);
                    return size;
                }
                case GeneratedQrLoginProgress_Tags.QrScanned: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterTypeCheckCodeSender.allocationSize(inner.checkCodeSender);
                    return size;
                }
                case GeneratedQrLoginProgress_Tags.WaitingForToken: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterString.allocationSize(inner.userCode);
                    return size;
                }
                case GeneratedQrLoginProgress_Tags.SyncingSecrets: {
                    return ordinalConverter.allocationSize(5);
                }
                case GeneratedQrLoginProgress_Tags.Done: {
                    return ordinalConverter.allocationSize(6);
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: GrantGeneratedQrLoginProgress
export var GrantGeneratedQrLoginProgress_Tags;
(function (GrantGeneratedQrLoginProgress_Tags) {
    GrantGeneratedQrLoginProgress_Tags["Starting"] = "Starting";
    GrantGeneratedQrLoginProgress_Tags["QrReady"] = "QrReady";
    GrantGeneratedQrLoginProgress_Tags["QrScanned"] = "QrScanned";
    GrantGeneratedQrLoginProgress_Tags["WaitingForAuth"] = "WaitingForAuth";
    GrantGeneratedQrLoginProgress_Tags["SyncingSecrets"] = "SyncingSecrets";
    GrantGeneratedQrLoginProgress_Tags["Done"] = "Done";
})(GrantGeneratedQrLoginProgress_Tags || (GrantGeneratedQrLoginProgress_Tags = {}));
/**
 * Enum describing the progress of granting login by generating a QR code to
 * be scanned on the new device.
 */
export const GrantGeneratedQrLoginProgress = (() => {
    /**
     * The login process is starting.
     */
    class Starting_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "GrantGeneratedQrLoginProgress";
        tag = GrantGeneratedQrLoginProgress_Tags.Starting;
        constructor() {
            super("GrantGeneratedQrLoginProgress", "Starting");
        }
        static new() {
            return new Starting_();
        }
        static instanceOf(obj) {
            return obj.tag === GrantGeneratedQrLoginProgress_Tags.Starting;
        }
    }
    /**
     * We have established the secure channel and now need to display the
     * QR code so that the existing device can scan it.
     */
    class QrReady_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "GrantGeneratedQrLoginProgress";
        tag = GrantGeneratedQrLoginProgress_Tags.QrReady;
        inner;
        constructor(inner) {
            super("GrantGeneratedQrLoginProgress", "QrReady");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new QrReady_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === GrantGeneratedQrLoginProgress_Tags.QrReady;
        }
    }
    /**
     * The existing device has scanned the QR code and is displaying the
     * checkcode. We now need to ask the user to enter the checkcode so that
     * we can verify that the channel is indeed secure.
     */
    class QrScanned_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "GrantGeneratedQrLoginProgress";
        tag = GrantGeneratedQrLoginProgress_Tags.QrScanned;
        inner;
        constructor(inner) {
            super("GrantGeneratedQrLoginProgress", "QrScanned");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new QrScanned_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === GrantGeneratedQrLoginProgress_Tags.QrScanned;
        }
    }
    /**
     * The secure channel has been confirmed using the [`CheckCode`] and this
     * device is waiting for the authorization to complete.
     */
    class WaitingForAuth_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "GrantGeneratedQrLoginProgress";
        tag = GrantGeneratedQrLoginProgress_Tags.WaitingForAuth;
        inner;
        constructor(inner) {
            super("GrantGeneratedQrLoginProgress", "WaitingForAuth");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new WaitingForAuth_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === GrantGeneratedQrLoginProgress_Tags.WaitingForAuth;
        }
    }
    /**
     * We are syncing secrets.
     */
    class SyncingSecrets_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "GrantGeneratedQrLoginProgress";
        tag = GrantGeneratedQrLoginProgress_Tags.SyncingSecrets;
        constructor() {
            super("GrantGeneratedQrLoginProgress", "SyncingSecrets");
        }
        static new() {
            return new SyncingSecrets_();
        }
        static instanceOf(obj) {
            return obj.tag === GrantGeneratedQrLoginProgress_Tags.SyncingSecrets;
        }
    }
    /**
     * The login has successfully finished.
     */
    class Done_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "GrantGeneratedQrLoginProgress";
        tag = GrantGeneratedQrLoginProgress_Tags.Done;
        constructor() {
            super("GrantGeneratedQrLoginProgress", "Done");
        }
        static new() {
            return new Done_();
        }
        static instanceOf(obj) {
            return obj.tag === GrantGeneratedQrLoginProgress_Tags.Done;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "GrantGeneratedQrLoginProgress";
    }
    return Object.freeze({
        instanceOf,
        Starting: Starting_,
        QrReady: QrReady_,
        QrScanned: QrScanned_,
        WaitingForAuth: WaitingForAuth_,
        SyncingSecrets: SyncingSecrets_,
        Done: Done_
    });
})();
// FfiConverter for enum GrantGeneratedQrLoginProgress
const FfiConverterTypeGrantGeneratedQrLoginProgress = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new GrantGeneratedQrLoginProgress.Starting();
                case 2: return new GrantGeneratedQrLoginProgress.QrReady({ qrCode: FfiConverterTypeQrCodeData.read(from) });
                case 3: return new GrantGeneratedQrLoginProgress.QrScanned({ checkCodeSender: FfiConverterTypeCheckCodeSender.read(from) });
                case 4: return new GrantGeneratedQrLoginProgress.WaitingForAuth({ verificationUri: FfiConverterString.read(from) });
                case 5: return new GrantGeneratedQrLoginProgress.SyncingSecrets();
                case 6: return new GrantGeneratedQrLoginProgress.Done();
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case GrantGeneratedQrLoginProgress_Tags.Starting: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case GrantGeneratedQrLoginProgress_Tags.QrReady: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterTypeQrCodeData.write(inner.qrCode, into);
                    return;
                }
                case GrantGeneratedQrLoginProgress_Tags.QrScanned: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterTypeCheckCodeSender.write(inner.checkCodeSender, into);
                    return;
                }
                case GrantGeneratedQrLoginProgress_Tags.WaitingForAuth: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.verificationUri, into);
                    return;
                }
                case GrantGeneratedQrLoginProgress_Tags.SyncingSecrets: {
                    ordinalConverter.write(5, into);
                    return;
                }
                case GrantGeneratedQrLoginProgress_Tags.Done: {
                    ordinalConverter.write(6, into);
                    return;
                }
                default:
                    // Throwing from here means that GrantGeneratedQrLoginProgress_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case GrantGeneratedQrLoginProgress_Tags.Starting: {
                    return ordinalConverter.allocationSize(1);
                }
                case GrantGeneratedQrLoginProgress_Tags.QrReady: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterTypeQrCodeData.allocationSize(inner.qrCode);
                    return size;
                }
                case GrantGeneratedQrLoginProgress_Tags.QrScanned: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterTypeCheckCodeSender.allocationSize(inner.checkCodeSender);
                    return size;
                }
                case GrantGeneratedQrLoginProgress_Tags.WaitingForAuth: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterString.allocationSize(inner.verificationUri);
                    return size;
                }
                case GrantGeneratedQrLoginProgress_Tags.SyncingSecrets: {
                    return ordinalConverter.allocationSize(5);
                }
                case GrantGeneratedQrLoginProgress_Tags.Done: {
                    return ordinalConverter.allocationSize(6);
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: GrantQrLoginProgress
export var GrantQrLoginProgress_Tags;
(function (GrantQrLoginProgress_Tags) {
    GrantQrLoginProgress_Tags["Starting"] = "Starting";
    GrantQrLoginProgress_Tags["EstablishingSecureChannel"] = "EstablishingSecureChannel";
    GrantQrLoginProgress_Tags["WaitingForAuth"] = "WaitingForAuth";
    GrantQrLoginProgress_Tags["SyncingSecrets"] = "SyncingSecrets";
    GrantQrLoginProgress_Tags["Done"] = "Done";
})(GrantQrLoginProgress_Tags || (GrantQrLoginProgress_Tags = {}));
/**
 * Enum describing the progress of granting login in by scanning a QR code that
 * was generated on a new device.
 */
export const GrantQrLoginProgress = (() => {
    /**
     * The login process is starting.
     */
    class Starting_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "GrantQrLoginProgress";
        tag = GrantQrLoginProgress_Tags.Starting;
        constructor() {
            super("GrantQrLoginProgress", "Starting");
        }
        static new() {
            return new Starting_();
        }
        static instanceOf(obj) {
            return obj.tag === GrantQrLoginProgress_Tags.Starting;
        }
    }
    /**
     * We established a secure channel with the other device.
     */
    class EstablishingSecureChannel_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "GrantQrLoginProgress";
        tag = GrantQrLoginProgress_Tags.EstablishingSecureChannel;
        inner;
        constructor(inner) {
            super("GrantQrLoginProgress", "EstablishingSecureChannel");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new EstablishingSecureChannel_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === GrantQrLoginProgress_Tags.EstablishingSecureChannel;
        }
    }
    /**
     * The secure channel has been confirmed using the [`CheckCode`] and this
     * device is waiting for the authorization to complete.
     */
    class WaitingForAuth_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "GrantQrLoginProgress";
        tag = GrantQrLoginProgress_Tags.WaitingForAuth;
        inner;
        constructor(inner) {
            super("GrantQrLoginProgress", "WaitingForAuth");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new WaitingForAuth_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === GrantQrLoginProgress_Tags.WaitingForAuth;
        }
    }
    /**
     * We are syncing secrets.
     */
    class SyncingSecrets_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "GrantQrLoginProgress";
        tag = GrantQrLoginProgress_Tags.SyncingSecrets;
        constructor() {
            super("GrantQrLoginProgress", "SyncingSecrets");
        }
        static new() {
            return new SyncingSecrets_();
        }
        static instanceOf(obj) {
            return obj.tag === GrantQrLoginProgress_Tags.SyncingSecrets;
        }
    }
    /**
     * The login has successfully finished.
     */
    class Done_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "GrantQrLoginProgress";
        tag = GrantQrLoginProgress_Tags.Done;
        constructor() {
            super("GrantQrLoginProgress", "Done");
        }
        static new() {
            return new Done_();
        }
        static instanceOf(obj) {
            return obj.tag === GrantQrLoginProgress_Tags.Done;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "GrantQrLoginProgress";
    }
    return Object.freeze({
        instanceOf,
        Starting: Starting_,
        EstablishingSecureChannel: EstablishingSecureChannel_,
        WaitingForAuth: WaitingForAuth_,
        SyncingSecrets: SyncingSecrets_,
        Done: Done_
    });
})();
// FfiConverter for enum GrantQrLoginProgress
const FfiConverterTypeGrantQrLoginProgress = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new GrantQrLoginProgress.Starting();
                case 2: return new GrantQrLoginProgress.EstablishingSecureChannel({ checkCode: FfiConverterUInt8.read(from), checkCodeString: FfiConverterString.read(from) });
                case 3: return new GrantQrLoginProgress.WaitingForAuth({ verificationUri: FfiConverterString.read(from) });
                case 4: return new GrantQrLoginProgress.SyncingSecrets();
                case 5: return new GrantQrLoginProgress.Done();
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case GrantQrLoginProgress_Tags.Starting: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case GrantQrLoginProgress_Tags.EstablishingSecureChannel: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterUInt8.write(inner.checkCode, into);
                    FfiConverterString.write(inner.checkCodeString, into);
                    return;
                }
                case GrantQrLoginProgress_Tags.WaitingForAuth: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.verificationUri, into);
                    return;
                }
                case GrantQrLoginProgress_Tags.SyncingSecrets: {
                    ordinalConverter.write(4, into);
                    return;
                }
                case GrantQrLoginProgress_Tags.Done: {
                    ordinalConverter.write(5, into);
                    return;
                }
                default:
                    // Throwing from here means that GrantQrLoginProgress_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case GrantQrLoginProgress_Tags.Starting: {
                    return ordinalConverter.allocationSize(1);
                }
                case GrantQrLoginProgress_Tags.EstablishingSecureChannel: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterUInt8.allocationSize(inner.checkCode);
                    size += FfiConverterString.allocationSize(inner.checkCodeString);
                    return size;
                }
                case GrantQrLoginProgress_Tags.WaitingForAuth: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterString.allocationSize(inner.verificationUri);
                    return size;
                }
                case GrantQrLoginProgress_Tags.SyncingSecrets: {
                    return ordinalConverter.allocationSize(4);
                }
                case GrantQrLoginProgress_Tags.Done: {
                    return ordinalConverter.allocationSize(5);
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: HistoryVisibility
export var HistoryVisibility_Tags;
(function (HistoryVisibility_Tags) {
    HistoryVisibility_Tags["Invited"] = "Invited";
    HistoryVisibility_Tags["Joined"] = "Joined";
    HistoryVisibility_Tags["Shared"] = "Shared";
    HistoryVisibility_Tags["WorldReadable"] = "WorldReadable";
    HistoryVisibility_Tags["Custom"] = "Custom";
})(HistoryVisibility_Tags || (HistoryVisibility_Tags = {}));
export const HistoryVisibility = (() => {
    /**
     * Previous events are accessible to newly joined members from the point
     * they were invited onwards.
     *
     * Events stop being accessible when the member' state changes to
     * something other than *invite* or *join*.
     */
    class Invited_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "HistoryVisibility";
        tag = HistoryVisibility_Tags.Invited;
        constructor() {
            super("HistoryVisibility", "Invited");
        }
        static new() {
            return new Invited_();
        }
        static instanceOf(obj) {
            return obj.tag === HistoryVisibility_Tags.Invited;
        }
    }
    /**
     * Previous events are accessible to newly joined members from the point
     * they joined the room onwards.
     * Events stop being accessible when the member' state changes to
     * something other than *join*.
     */
    class Joined_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "HistoryVisibility";
        tag = HistoryVisibility_Tags.Joined;
        constructor() {
            super("HistoryVisibility", "Joined");
        }
        static new() {
            return new Joined_();
        }
        static instanceOf(obj) {
            return obj.tag === HistoryVisibility_Tags.Joined;
        }
    }
    /**
     * Previous events are always accessible to newly joined members.
     *
     * All events in the room are accessible, even those sent when the member
     * was not a part of the room.
     */
    class Shared_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "HistoryVisibility";
        tag = HistoryVisibility_Tags.Shared;
        constructor() {
            super("HistoryVisibility", "Shared");
        }
        static new() {
            return new Shared_();
        }
        static instanceOf(obj) {
            return obj.tag === HistoryVisibility_Tags.Shared;
        }
    }
    /**
     * All events while this is the `HistoryVisibility` value may be shared by
     * any participating homeserver with anyone, regardless of whether they
     * have ever joined the room.
     */
    class WorldReadable_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "HistoryVisibility";
        tag = HistoryVisibility_Tags.WorldReadable;
        constructor() {
            super("HistoryVisibility", "WorldReadable");
        }
        static new() {
            return new WorldReadable_();
        }
        static instanceOf(obj) {
            return obj.tag === HistoryVisibility_Tags.WorldReadable;
        }
    }
    /**
     * A custom history visibility, up for interpretation by the consumer.
     */
    class Custom_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "HistoryVisibility";
        tag = HistoryVisibility_Tags.Custom;
        inner;
        constructor(inner) {
            super("HistoryVisibility", "Custom");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Custom_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === HistoryVisibility_Tags.Custom;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "HistoryVisibility";
    }
    return Object.freeze({
        instanceOf,
        Invited: Invited_,
        Joined: Joined_,
        Shared: Shared_,
        WorldReadable: WorldReadable_,
        Custom: Custom_
    });
})();
// FfiConverter for enum HistoryVisibility
const FfiConverterTypeHistoryVisibility = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new HistoryVisibility.Invited();
                case 2: return new HistoryVisibility.Joined();
                case 3: return new HistoryVisibility.Shared();
                case 4: return new HistoryVisibility.WorldReadable();
                case 5: return new HistoryVisibility.Custom({ repr: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case HistoryVisibility_Tags.Invited: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case HistoryVisibility_Tags.Joined: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case HistoryVisibility_Tags.Shared: {
                    ordinalConverter.write(3, into);
                    return;
                }
                case HistoryVisibility_Tags.WorldReadable: {
                    ordinalConverter.write(4, into);
                    return;
                }
                case HistoryVisibility_Tags.Custom: {
                    ordinalConverter.write(5, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.repr, into);
                    return;
                }
                default:
                    // Throwing from here means that HistoryVisibility_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case HistoryVisibility_Tags.Invited: {
                    return ordinalConverter.allocationSize(1);
                }
                case HistoryVisibility_Tags.Joined: {
                    return ordinalConverter.allocationSize(2);
                }
                case HistoryVisibility_Tags.Shared: {
                    return ordinalConverter.allocationSize(3);
                }
                case HistoryVisibility_Tags.WorldReadable: {
                    return ordinalConverter.allocationSize(4);
                }
                case HistoryVisibility_Tags.Custom: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(5);
                    size += FfiConverterString.allocationSize(inner.repr);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Flat error type: HumanQrGrantLoginError
export var HumanQrGrantLoginError_Tags;
(function (HumanQrGrantLoginError_Tags) {
    HumanQrGrantLoginError_Tags["DeviceIdAlreadyInUse"] = "DeviceIDAlreadyInUse";
    HumanQrGrantLoginError_Tags["InvalidCheckCode"] = "InvalidCheckCode";
    HumanQrGrantLoginError_Tags["UnsupportedProtocol"] = "UnsupportedProtocol";
    HumanQrGrantLoginError_Tags["MissingSecretsBackup"] = "MissingSecretsBackup";
    HumanQrGrantLoginError_Tags["NotFound"] = "NotFound";
    HumanQrGrantLoginError_Tags["UnableToCreateDevice"] = "UnableToCreateDevice";
    HumanQrGrantLoginError_Tags["Unknown"] = "Unknown";
})(HumanQrGrantLoginError_Tags || (HumanQrGrantLoginError_Tags = {}));
export const HumanQrGrantLoginError = (() => {
    /**
     * The requested device ID is already in use.
     */
    class DeviceIdAlreadyInUse extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "HumanQrGrantLoginError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 1;
        tag = HumanQrGrantLoginError_Tags.DeviceIdAlreadyInUse;
        constructor(message) {
            super("HumanQrGrantLoginError", "DeviceIdAlreadyInUse", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 1);
        }
    }
    /**
     * The check code was incorrect.
     */
    class InvalidCheckCode extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "HumanQrGrantLoginError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 2;
        tag = HumanQrGrantLoginError_Tags.InvalidCheckCode;
        constructor(message) {
            super("HumanQrGrantLoginError", "InvalidCheckCode", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 2);
        }
    }
    /**
     * The other client proposed an unsupported protocol.
     */
    class UnsupportedProtocol extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "HumanQrGrantLoginError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 3;
        tag = HumanQrGrantLoginError_Tags.UnsupportedProtocol;
        constructor(message) {
            super("HumanQrGrantLoginError", "UnsupportedProtocol", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 3);
        }
    }
    /**
     * Secrets backup not set up properly.
     */
    class MissingSecretsBackup extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "HumanQrGrantLoginError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 4;
        tag = HumanQrGrantLoginError_Tags.MissingSecretsBackup;
        constructor(message) {
            super("HumanQrGrantLoginError", "MissingSecretsBackup", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 4);
        }
    }
    /**
     * The rendezvous session was not found and might have expired.
     */
    class NotFound extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "HumanQrGrantLoginError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 5;
        tag = HumanQrGrantLoginError_Tags.NotFound;
        constructor(message) {
            super("HumanQrGrantLoginError", "NotFound", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 5);
        }
    }
    /**
     * The device could not be created.
     */
    class UnableToCreateDevice extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "HumanQrGrantLoginError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 6;
        tag = HumanQrGrantLoginError_Tags.UnableToCreateDevice;
        constructor(message) {
            super("HumanQrGrantLoginError", "UnableToCreateDevice", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 6);
        }
    }
    /**
     * An unknown error has happened.
     */
    class Unknown extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "HumanQrGrantLoginError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 7;
        tag = HumanQrGrantLoginError_Tags.Unknown;
        constructor(message) {
            super("HumanQrGrantLoginError", "Unknown", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 7);
        }
    }
    // Utility function which does not rely on instanceof.
    function instanceOf(e) {
        return e[uniffiTypeNameSymbol] === "HumanQrGrantLoginError";
    }
    return {
        DeviceIdAlreadyInUse,
        InvalidCheckCode,
        UnsupportedProtocol,
        MissingSecretsBackup,
        NotFound,
        UnableToCreateDevice,
        Unknown,
        instanceOf,
    };
})();
const FfiConverterTypeHumanQrGrantLoginError = (() => {
    const intConverter = FfiConverterInt32;
    class FfiConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (intConverter.read(from)) {
                case 1: return new HumanQrGrantLoginError.DeviceIdAlreadyInUse(FfiConverterString.read(from));
                case 2: return new HumanQrGrantLoginError.InvalidCheckCode(FfiConverterString.read(from));
                case 3: return new HumanQrGrantLoginError.UnsupportedProtocol(FfiConverterString.read(from));
                case 4: return new HumanQrGrantLoginError.MissingSecretsBackup(FfiConverterString.read(from));
                case 5: return new HumanQrGrantLoginError.NotFound(FfiConverterString.read(from));
                case 6: return new HumanQrGrantLoginError.UnableToCreateDevice(FfiConverterString.read(from));
                case 7: return new HumanQrGrantLoginError.Unknown(FfiConverterString.read(from));
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            const obj = value;
            const index = obj[variantOrdinalSymbol];
            intConverter.write(index, into);
        }
        allocationSize(value) {
            return intConverter.allocationSize(0);
        }
    }
    return new FfiConverter();
})();
// Error type: HumanQrLoginError
// Enum: HumanQrLoginError
export var HumanQrLoginError_Tags;
(function (HumanQrLoginError_Tags) {
    HumanQrLoginError_Tags["LinkingNotSupported"] = "LinkingNotSupported";
    HumanQrLoginError_Tags["Cancelled"] = "Cancelled";
    HumanQrLoginError_Tags["Expired"] = "Expired";
    HumanQrLoginError_Tags["ConnectionInsecure"] = "ConnectionInsecure";
    HumanQrLoginError_Tags["Declined"] = "Declined";
    HumanQrLoginError_Tags["Unknown"] = "Unknown";
    HumanQrLoginError_Tags["SlidingSyncNotAvailable"] = "SlidingSyncNotAvailable";
    HumanQrLoginError_Tags["OidcMetadataInvalid"] = "OidcMetadataInvalid";
    HumanQrLoginError_Tags["OtherDeviceNotSignedIn"] = "OtherDeviceNotSignedIn";
    HumanQrLoginError_Tags["CheckCodeAlreadySent"] = "CheckCodeAlreadySent";
    HumanQrLoginError_Tags["CheckCodeCannotBeSent"] = "CheckCodeCannotBeSent";
    HumanQrLoginError_Tags["NotFound"] = "NotFound";
})(HumanQrLoginError_Tags || (HumanQrLoginError_Tags = {}));
export const HumanQrLoginError = (() => {
    class LinkingNotSupported_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "HumanQrLoginError";
        tag = HumanQrLoginError_Tags.LinkingNotSupported;
        constructor() {
            super("HumanQrLoginError", "LinkingNotSupported");
        }
        static new() {
            return new LinkingNotSupported_();
        }
        static instanceOf(obj) {
            return obj.tag === HumanQrLoginError_Tags.LinkingNotSupported;
        }
        static hasInner(obj) {
            return false;
        }
    }
    class Cancelled_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "HumanQrLoginError";
        tag = HumanQrLoginError_Tags.Cancelled;
        constructor() {
            super("HumanQrLoginError", "Cancelled");
        }
        static new() {
            return new Cancelled_();
        }
        static instanceOf(obj) {
            return obj.tag === HumanQrLoginError_Tags.Cancelled;
        }
        static hasInner(obj) {
            return false;
        }
    }
    class Expired_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "HumanQrLoginError";
        tag = HumanQrLoginError_Tags.Expired;
        constructor() {
            super("HumanQrLoginError", "Expired");
        }
        static new() {
            return new Expired_();
        }
        static instanceOf(obj) {
            return obj.tag === HumanQrLoginError_Tags.Expired;
        }
        static hasInner(obj) {
            return false;
        }
    }
    class ConnectionInsecure_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "HumanQrLoginError";
        tag = HumanQrLoginError_Tags.ConnectionInsecure;
        constructor() {
            super("HumanQrLoginError", "ConnectionInsecure");
        }
        static new() {
            return new ConnectionInsecure_();
        }
        static instanceOf(obj) {
            return obj.tag === HumanQrLoginError_Tags.ConnectionInsecure;
        }
        static hasInner(obj) {
            return false;
        }
    }
    class Declined_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "HumanQrLoginError";
        tag = HumanQrLoginError_Tags.Declined;
        constructor() {
            super("HumanQrLoginError", "Declined");
        }
        static new() {
            return new Declined_();
        }
        static instanceOf(obj) {
            return obj.tag === HumanQrLoginError_Tags.Declined;
        }
        static hasInner(obj) {
            return false;
        }
    }
    class Unknown_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "HumanQrLoginError";
        tag = HumanQrLoginError_Tags.Unknown;
        constructor() {
            super("HumanQrLoginError", "Unknown");
        }
        static new() {
            return new Unknown_();
        }
        static instanceOf(obj) {
            return obj.tag === HumanQrLoginError_Tags.Unknown;
        }
        static hasInner(obj) {
            return false;
        }
    }
    class SlidingSyncNotAvailable_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "HumanQrLoginError";
        tag = HumanQrLoginError_Tags.SlidingSyncNotAvailable;
        constructor() {
            super("HumanQrLoginError", "SlidingSyncNotAvailable");
        }
        static new() {
            return new SlidingSyncNotAvailable_();
        }
        static instanceOf(obj) {
            return obj.tag === HumanQrLoginError_Tags.SlidingSyncNotAvailable;
        }
        static hasInner(obj) {
            return false;
        }
    }
    class OidcMetadataInvalid_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "HumanQrLoginError";
        tag = HumanQrLoginError_Tags.OidcMetadataInvalid;
        constructor() {
            super("HumanQrLoginError", "OidcMetadataInvalid");
        }
        static new() {
            return new OidcMetadataInvalid_();
        }
        static instanceOf(obj) {
            return obj.tag === HumanQrLoginError_Tags.OidcMetadataInvalid;
        }
        static hasInner(obj) {
            return false;
        }
    }
    class OtherDeviceNotSignedIn_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "HumanQrLoginError";
        tag = HumanQrLoginError_Tags.OtherDeviceNotSignedIn;
        constructor() {
            super("HumanQrLoginError", "OtherDeviceNotSignedIn");
        }
        static new() {
            return new OtherDeviceNotSignedIn_();
        }
        static instanceOf(obj) {
            return obj.tag === HumanQrLoginError_Tags.OtherDeviceNotSignedIn;
        }
        static hasInner(obj) {
            return false;
        }
    }
    class CheckCodeAlreadySent_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "HumanQrLoginError";
        tag = HumanQrLoginError_Tags.CheckCodeAlreadySent;
        constructor() {
            super("HumanQrLoginError", "CheckCodeAlreadySent");
        }
        static new() {
            return new CheckCodeAlreadySent_();
        }
        static instanceOf(obj) {
            return obj.tag === HumanQrLoginError_Tags.CheckCodeAlreadySent;
        }
        static hasInner(obj) {
            return false;
        }
    }
    class CheckCodeCannotBeSent_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "HumanQrLoginError";
        tag = HumanQrLoginError_Tags.CheckCodeCannotBeSent;
        constructor() {
            super("HumanQrLoginError", "CheckCodeCannotBeSent");
        }
        static new() {
            return new CheckCodeCannotBeSent_();
        }
        static instanceOf(obj) {
            return obj.tag === HumanQrLoginError_Tags.CheckCodeCannotBeSent;
        }
        static hasInner(obj) {
            return false;
        }
    }
    class NotFound_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "HumanQrLoginError";
        tag = HumanQrLoginError_Tags.NotFound;
        constructor() {
            super("HumanQrLoginError", "NotFound");
        }
        static new() {
            return new NotFound_();
        }
        static instanceOf(obj) {
            return obj.tag === HumanQrLoginError_Tags.NotFound;
        }
        static hasInner(obj) {
            return false;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "HumanQrLoginError";
    }
    return Object.freeze({
        instanceOf,
        LinkingNotSupported: LinkingNotSupported_,
        Cancelled: Cancelled_,
        Expired: Expired_,
        ConnectionInsecure: ConnectionInsecure_,
        Declined: Declined_,
        Unknown: Unknown_,
        SlidingSyncNotAvailable: SlidingSyncNotAvailable_,
        OidcMetadataInvalid: OidcMetadataInvalid_,
        OtherDeviceNotSignedIn: OtherDeviceNotSignedIn_,
        CheckCodeAlreadySent: CheckCodeAlreadySent_,
        CheckCodeCannotBeSent: CheckCodeCannotBeSent_,
        NotFound: NotFound_
    });
})();
// FfiConverter for enum HumanQrLoginError
const FfiConverterTypeHumanQrLoginError = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new HumanQrLoginError.LinkingNotSupported();
                case 2: return new HumanQrLoginError.Cancelled();
                case 3: return new HumanQrLoginError.Expired();
                case 4: return new HumanQrLoginError.ConnectionInsecure();
                case 5: return new HumanQrLoginError.Declined();
                case 6: return new HumanQrLoginError.Unknown();
                case 7: return new HumanQrLoginError.SlidingSyncNotAvailable();
                case 8: return new HumanQrLoginError.OidcMetadataInvalid();
                case 9: return new HumanQrLoginError.OtherDeviceNotSignedIn();
                case 10: return new HumanQrLoginError.CheckCodeAlreadySent();
                case 11: return new HumanQrLoginError.CheckCodeCannotBeSent();
                case 12: return new HumanQrLoginError.NotFound();
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case HumanQrLoginError_Tags.LinkingNotSupported: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case HumanQrLoginError_Tags.Cancelled: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case HumanQrLoginError_Tags.Expired: {
                    ordinalConverter.write(3, into);
                    return;
                }
                case HumanQrLoginError_Tags.ConnectionInsecure: {
                    ordinalConverter.write(4, into);
                    return;
                }
                case HumanQrLoginError_Tags.Declined: {
                    ordinalConverter.write(5, into);
                    return;
                }
                case HumanQrLoginError_Tags.Unknown: {
                    ordinalConverter.write(6, into);
                    return;
                }
                case HumanQrLoginError_Tags.SlidingSyncNotAvailable: {
                    ordinalConverter.write(7, into);
                    return;
                }
                case HumanQrLoginError_Tags.OidcMetadataInvalid: {
                    ordinalConverter.write(8, into);
                    return;
                }
                case HumanQrLoginError_Tags.OtherDeviceNotSignedIn: {
                    ordinalConverter.write(9, into);
                    return;
                }
                case HumanQrLoginError_Tags.CheckCodeAlreadySent: {
                    ordinalConverter.write(10, into);
                    return;
                }
                case HumanQrLoginError_Tags.CheckCodeCannotBeSent: {
                    ordinalConverter.write(11, into);
                    return;
                }
                case HumanQrLoginError_Tags.NotFound: {
                    ordinalConverter.write(12, into);
                    return;
                }
                default:
                    // Throwing from here means that HumanQrLoginError_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case HumanQrLoginError_Tags.LinkingNotSupported: {
                    return ordinalConverter.allocationSize(1);
                }
                case HumanQrLoginError_Tags.Cancelled: {
                    return ordinalConverter.allocationSize(2);
                }
                case HumanQrLoginError_Tags.Expired: {
                    return ordinalConverter.allocationSize(3);
                }
                case HumanQrLoginError_Tags.ConnectionInsecure: {
                    return ordinalConverter.allocationSize(4);
                }
                case HumanQrLoginError_Tags.Declined: {
                    return ordinalConverter.allocationSize(5);
                }
                case HumanQrLoginError_Tags.Unknown: {
                    return ordinalConverter.allocationSize(6);
                }
                case HumanQrLoginError_Tags.SlidingSyncNotAvailable: {
                    return ordinalConverter.allocationSize(7);
                }
                case HumanQrLoginError_Tags.OidcMetadataInvalid: {
                    return ordinalConverter.allocationSize(8);
                }
                case HumanQrLoginError_Tags.OtherDeviceNotSignedIn: {
                    return ordinalConverter.allocationSize(9);
                }
                case HumanQrLoginError_Tags.CheckCodeAlreadySent: {
                    return ordinalConverter.allocationSize(10);
                }
                case HumanQrLoginError_Tags.CheckCodeCannotBeSent: {
                    return ordinalConverter.allocationSize(11);
                }
                case HumanQrLoginError_Tags.NotFound: {
                    return ordinalConverter.allocationSize(12);
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
/**
 * The policy that decides if avatars should be shown in invite requests.
 */
export var InviteAvatars;
(function (InviteAvatars) {
    /**
     * Always show avatars in invite requests.
     */
    InviteAvatars[InviteAvatars["On"] = 0] = "On";
    /**
     * Never show avatars in invite requests.
     */
    InviteAvatars[InviteAvatars["Off"] = 1] = "Off";
})(InviteAvatars || (InviteAvatars = {}));
const FfiConverterTypeInviteAvatars = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return InviteAvatars.On;
                case 2: return InviteAvatars.Off;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case InviteAvatars.On: return ordinalConverter.write(1, into);
                case InviteAvatars.Off: return ordinalConverter.write(2, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Enum: JoinRule
export var JoinRule_Tags;
(function (JoinRule_Tags) {
    JoinRule_Tags["Public"] = "Public";
    JoinRule_Tags["Invite"] = "Invite";
    JoinRule_Tags["Knock"] = "Knock";
    JoinRule_Tags["Private"] = "Private";
    JoinRule_Tags["Restricted"] = "Restricted";
    JoinRule_Tags["KnockRestricted"] = "KnockRestricted";
    JoinRule_Tags["Custom"] = "Custom";
})(JoinRule_Tags || (JoinRule_Tags = {}));
/**
 * The rule used for users wishing to join this room.
 */
export const JoinRule = (() => {
    /**
     * Anyone can join the room without any prior action.
     */
    class Public_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "JoinRule";
        tag = JoinRule_Tags.Public;
        constructor() {
            super("JoinRule", "Public");
        }
        static new() {
            return new Public_();
        }
        static instanceOf(obj) {
            return obj.tag === JoinRule_Tags.Public;
        }
    }
    /**
     * A user who wishes to join the room must first receive an invite to the
     * room from someone already inside of the room.
     */
    class Invite_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "JoinRule";
        tag = JoinRule_Tags.Invite;
        constructor() {
            super("JoinRule", "Invite");
        }
        static new() {
            return new Invite_();
        }
        static instanceOf(obj) {
            return obj.tag === JoinRule_Tags.Invite;
        }
    }
    /**
     * Users can join the room if they are invited, or they can request an
     * invite to the room.
     *
     * They can be allowed (invited) or denied (kicked/banned) access.
     */
    class Knock_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "JoinRule";
        tag = JoinRule_Tags.Knock;
        constructor() {
            super("JoinRule", "Knock");
        }
        static new() {
            return new Knock_();
        }
        static instanceOf(obj) {
            return obj.tag === JoinRule_Tags.Knock;
        }
    }
    /**
     * Reserved but not yet implemented by the Matrix specification.
     */
    class Private_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "JoinRule";
        tag = JoinRule_Tags.Private;
        constructor() {
            super("JoinRule", "Private");
        }
        static new() {
            return new Private_();
        }
        static instanceOf(obj) {
            return obj.tag === JoinRule_Tags.Private;
        }
    }
    /**
     * Users can join the room if they are invited, or if they meet any of the
     * conditions described in a set of [`AllowRule`]s.
     */
    class Restricted_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "JoinRule";
        tag = JoinRule_Tags.Restricted;
        inner;
        constructor(inner) {
            super("JoinRule", "Restricted");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Restricted_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === JoinRule_Tags.Restricted;
        }
    }
    /**
     * Users can join the room if they are invited, or if they meet any of the
     * conditions described in a set of [`AllowRule`]s, or they can request
     * an invite to the room.
     */
    class KnockRestricted_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "JoinRule";
        tag = JoinRule_Tags.KnockRestricted;
        inner;
        constructor(inner) {
            super("JoinRule", "KnockRestricted");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new KnockRestricted_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === JoinRule_Tags.KnockRestricted;
        }
    }
    /**
     * A custom join rule, up for interpretation by the consumer.
     */
    class Custom_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "JoinRule";
        tag = JoinRule_Tags.Custom;
        inner;
        constructor(inner) {
            super("JoinRule", "Custom");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Custom_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === JoinRule_Tags.Custom;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "JoinRule";
    }
    return Object.freeze({
        instanceOf,
        Public: Public_,
        Invite: Invite_,
        Knock: Knock_,
        Private: Private_,
        Restricted: Restricted_,
        KnockRestricted: KnockRestricted_,
        Custom: Custom_
    });
})();
// FfiConverter for enum JoinRule
const FfiConverterTypeJoinRule = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new JoinRule.Public();
                case 2: return new JoinRule.Invite();
                case 3: return new JoinRule.Knock();
                case 4: return new JoinRule.Private();
                case 5: return new JoinRule.Restricted({ rules: FfiConverterArrayTypeAllowRule.read(from) });
                case 6: return new JoinRule.KnockRestricted({ rules: FfiConverterArrayTypeAllowRule.read(from) });
                case 7: return new JoinRule.Custom({ repr: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case JoinRule_Tags.Public: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case JoinRule_Tags.Invite: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case JoinRule_Tags.Knock: {
                    ordinalConverter.write(3, into);
                    return;
                }
                case JoinRule_Tags.Private: {
                    ordinalConverter.write(4, into);
                    return;
                }
                case JoinRule_Tags.Restricted: {
                    ordinalConverter.write(5, into);
                    const inner = value.inner;
                    FfiConverterArrayTypeAllowRule.write(inner.rules, into);
                    return;
                }
                case JoinRule_Tags.KnockRestricted: {
                    ordinalConverter.write(6, into);
                    const inner = value.inner;
                    FfiConverterArrayTypeAllowRule.write(inner.rules, into);
                    return;
                }
                case JoinRule_Tags.Custom: {
                    ordinalConverter.write(7, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.repr, into);
                    return;
                }
                default:
                    // Throwing from here means that JoinRule_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case JoinRule_Tags.Public: {
                    return ordinalConverter.allocationSize(1);
                }
                case JoinRule_Tags.Invite: {
                    return ordinalConverter.allocationSize(2);
                }
                case JoinRule_Tags.Knock: {
                    return ordinalConverter.allocationSize(3);
                }
                case JoinRule_Tags.Private: {
                    return ordinalConverter.allocationSize(4);
                }
                case JoinRule_Tags.Restricted: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(5);
                    size += FfiConverterArrayTypeAllowRule.allocationSize(inner.rules);
                    return size;
                }
                case JoinRule_Tags.KnockRestricted: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(6);
                    size += FfiConverterArrayTypeAllowRule.allocationSize(inner.rules);
                    return size;
                }
                case JoinRule_Tags.Custom: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(7);
                    size += FfiConverterString.allocationSize(inner.repr);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: JsonValue
export var JsonValue_Tags;
(function (JsonValue_Tags) {
    JsonValue_Tags["Null"] = "Null";
    JsonValue_Tags["Bool"] = "Bool";
    JsonValue_Tags["Integer"] = "Integer";
    JsonValue_Tags["String"] = "String";
})(JsonValue_Tags || (JsonValue_Tags = {}));
export const JsonValue = (() => {
    /**
     * Represents a `null` value.
     */
    class Null_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "JsonValue";
        tag = JsonValue_Tags.Null;
        constructor() {
            super("JsonValue", "Null");
        }
        static new() {
            return new Null_();
        }
        static instanceOf(obj) {
            return obj.tag === JsonValue_Tags.Null;
        }
    }
    /**
     * Represents a boolean.
     */
    class Bool_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "JsonValue";
        tag = JsonValue_Tags.Bool;
        inner;
        constructor(inner) {
            super("JsonValue", "Bool");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Bool_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === JsonValue_Tags.Bool;
        }
    }
    /**
     * Represents an integer.
     */
    class Integer_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "JsonValue";
        tag = JsonValue_Tags.Integer;
        inner;
        constructor(inner) {
            super("JsonValue", "Integer");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Integer_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === JsonValue_Tags.Integer;
        }
    }
    /**
     * Represents a string.
     */
    class String_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "JsonValue";
        tag = JsonValue_Tags.String;
        inner;
        constructor(inner) {
            super("JsonValue", "String");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new String_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === JsonValue_Tags.String;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "JsonValue";
    }
    return Object.freeze({
        instanceOf,
        Null: Null_,
        Bool: Bool_,
        Integer: Integer_,
        String: String_
    });
})();
// FfiConverter for enum JsonValue
const FfiConverterTypeJsonValue = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new JsonValue.Null();
                case 2: return new JsonValue.Bool({ value: FfiConverterBool.read(from) });
                case 3: return new JsonValue.Integer({ value: FfiConverterInt64.read(from) });
                case 4: return new JsonValue.String({ value: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case JsonValue_Tags.Null: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case JsonValue_Tags.Bool: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterBool.write(inner.value, into);
                    return;
                }
                case JsonValue_Tags.Integer: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterInt64.write(inner.value, into);
                    return;
                }
                case JsonValue_Tags.String: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.value, into);
                    return;
                }
                default:
                    // Throwing from here means that JsonValue_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case JsonValue_Tags.Null: {
                    return ordinalConverter.allocationSize(1);
                }
                case JsonValue_Tags.Bool: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterBool.allocationSize(inner.value);
                    return size;
                }
                case JsonValue_Tags.Integer: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterInt64.allocationSize(inner.value);
                    return size;
                }
                case JsonValue_Tags.String: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterString.allocationSize(inner.value);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
/**
 * A key algorithm to be used to generate a key from a passphrase.
 */
export var KeyDerivationAlgorithm;
(function (KeyDerivationAlgorithm) {
    /**
     * PBKDF2
     */
    KeyDerivationAlgorithm[KeyDerivationAlgorithm["Pbkfd2"] = 0] = "Pbkfd2";
})(KeyDerivationAlgorithm || (KeyDerivationAlgorithm = {}));
const FfiConverterTypeKeyDerivationAlgorithm = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return KeyDerivationAlgorithm.Pbkfd2;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case KeyDerivationAlgorithm.Pbkfd2: return ordinalConverter.write(1, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Enum: LatestEventValue
export var LatestEventValue_Tags;
(function (LatestEventValue_Tags) {
    LatestEventValue_Tags["None"] = "None";
    LatestEventValue_Tags["Remote"] = "Remote";
    LatestEventValue_Tags["Local"] = "Local";
})(LatestEventValue_Tags || (LatestEventValue_Tags = {}));
/**
 * Mimic the [`UiLatestEventValue`] type.
 */
export const LatestEventValue = (() => {
    class None_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "LatestEventValue";
        tag = LatestEventValue_Tags.None;
        constructor() {
            super("LatestEventValue", "None");
        }
        static new() {
            return new None_();
        }
        static instanceOf(obj) {
            return obj.tag === LatestEventValue_Tags.None;
        }
    }
    class Remote_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "LatestEventValue";
        tag = LatestEventValue_Tags.Remote;
        inner;
        constructor(inner) {
            super("LatestEventValue", "Remote");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Remote_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === LatestEventValue_Tags.Remote;
        }
    }
    class Local_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "LatestEventValue";
        tag = LatestEventValue_Tags.Local;
        inner;
        constructor(inner) {
            super("LatestEventValue", "Local");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Local_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === LatestEventValue_Tags.Local;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "LatestEventValue";
    }
    return Object.freeze({
        instanceOf,
        None: None_,
        Remote: Remote_,
        Local: Local_
    });
})();
// FfiConverter for enum LatestEventValue
const FfiConverterTypeLatestEventValue = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new LatestEventValue.None();
                case 2: return new LatestEventValue.Remote({ timestamp: FfiConverterTypeTimestamp.read(from), sender: FfiConverterString.read(from), isOwn: FfiConverterBool.read(from), profile: FfiConverterTypeProfileDetails.read(from), content: FfiConverterTypeTimelineItemContent.read(from) });
                case 3: return new LatestEventValue.Local({ timestamp: FfiConverterTypeTimestamp.read(from), sender: FfiConverterString.read(from), profile: FfiConverterTypeProfileDetails.read(from), content: FfiConverterTypeTimelineItemContent.read(from), isSending: FfiConverterBool.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case LatestEventValue_Tags.None: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case LatestEventValue_Tags.Remote: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterTypeTimestamp.write(inner.timestamp, into);
                    FfiConverterString.write(inner.sender, into);
                    FfiConverterBool.write(inner.isOwn, into);
                    FfiConverterTypeProfileDetails.write(inner.profile, into);
                    FfiConverterTypeTimelineItemContent.write(inner.content, into);
                    return;
                }
                case LatestEventValue_Tags.Local: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterTypeTimestamp.write(inner.timestamp, into);
                    FfiConverterString.write(inner.sender, into);
                    FfiConverterTypeProfileDetails.write(inner.profile, into);
                    FfiConverterTypeTimelineItemContent.write(inner.content, into);
                    FfiConverterBool.write(inner.isSending, into);
                    return;
                }
                default:
                    // Throwing from here means that LatestEventValue_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case LatestEventValue_Tags.None: {
                    return ordinalConverter.allocationSize(1);
                }
                case LatestEventValue_Tags.Remote: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterTypeTimestamp.allocationSize(inner.timestamp);
                    size += FfiConverterString.allocationSize(inner.sender);
                    size += FfiConverterBool.allocationSize(inner.isOwn);
                    size += FfiConverterTypeProfileDetails.allocationSize(inner.profile);
                    size += FfiConverterTypeTimelineItemContent.allocationSize(inner.content);
                    return size;
                }
                case LatestEventValue_Tags.Local: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterTypeTimestamp.allocationSize(inner.timestamp);
                    size += FfiConverterString.allocationSize(inner.sender);
                    size += FfiConverterTypeProfileDetails.allocationSize(inner.profile);
                    size += FfiConverterTypeTimelineItemContent.allocationSize(inner.content);
                    size += FfiConverterBool.allocationSize(inner.isSending);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
export var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Error"] = 0] = "Error";
    LogLevel[LogLevel["Warn"] = 1] = "Warn";
    LogLevel[LogLevel["Info"] = 2] = "Info";
    LogLevel[LogLevel["Debug"] = 3] = "Debug";
    LogLevel[LogLevel["Trace"] = 4] = "Trace";
})(LogLevel || (LogLevel = {}));
const FfiConverterTypeLogLevel = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return LogLevel.Error;
                case 2: return LogLevel.Warn;
                case 3: return LogLevel.Info;
                case 4: return LogLevel.Debug;
                case 5: return LogLevel.Trace;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case LogLevel.Error: return ordinalConverter.write(1, into);
                case LogLevel.Warn: return ordinalConverter.write(2, into);
                case LogLevel.Info: return ordinalConverter.write(3, into);
                case LogLevel.Debug: return ordinalConverter.write(4, into);
                case LogLevel.Trace: return ordinalConverter.write(5, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Enum: MatrixId
export var MatrixId_Tags;
(function (MatrixId_Tags) {
    MatrixId_Tags["Room"] = "Room";
    MatrixId_Tags["RoomAlias"] = "RoomAlias";
    MatrixId_Tags["User"] = "User";
    MatrixId_Tags["EventOnRoomId"] = "EventOnRoomId";
    MatrixId_Tags["EventOnRoomAlias"] = "EventOnRoomAlias";
})(MatrixId_Tags || (MatrixId_Tags = {}));
/**
 * A Matrix ID that can be a room, room alias, user, or event.
 */
export const MatrixId = (() => {
    class Room_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MatrixId";
        tag = MatrixId_Tags.Room;
        inner;
        constructor(inner) {
            super("MatrixId", "Room");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Room_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MatrixId_Tags.Room;
        }
    }
    class RoomAlias_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MatrixId";
        tag = MatrixId_Tags.RoomAlias;
        inner;
        constructor(inner) {
            super("MatrixId", "RoomAlias");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new RoomAlias_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MatrixId_Tags.RoomAlias;
        }
    }
    class User_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MatrixId";
        tag = MatrixId_Tags.User;
        inner;
        constructor(inner) {
            super("MatrixId", "User");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new User_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MatrixId_Tags.User;
        }
    }
    class EventOnRoomId_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MatrixId";
        tag = MatrixId_Tags.EventOnRoomId;
        inner;
        constructor(inner) {
            super("MatrixId", "EventOnRoomId");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new EventOnRoomId_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MatrixId_Tags.EventOnRoomId;
        }
    }
    class EventOnRoomAlias_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MatrixId";
        tag = MatrixId_Tags.EventOnRoomAlias;
        inner;
        constructor(inner) {
            super("MatrixId", "EventOnRoomAlias");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new EventOnRoomAlias_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MatrixId_Tags.EventOnRoomAlias;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "MatrixId";
    }
    return Object.freeze({
        instanceOf,
        Room: Room_,
        RoomAlias: RoomAlias_,
        User: User_,
        EventOnRoomId: EventOnRoomId_,
        EventOnRoomAlias: EventOnRoomAlias_
    });
})();
// FfiConverter for enum MatrixId
const FfiConverterTypeMatrixId = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new MatrixId.Room({ id: FfiConverterString.read(from) });
                case 2: return new MatrixId.RoomAlias({ alias: FfiConverterString.read(from) });
                case 3: return new MatrixId.User({ id: FfiConverterString.read(from) });
                case 4: return new MatrixId.EventOnRoomId({ roomId: FfiConverterString.read(from), eventId: FfiConverterString.read(from) });
                case 5: return new MatrixId.EventOnRoomAlias({ alias: FfiConverterString.read(from), eventId: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case MatrixId_Tags.Room: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.id, into);
                    return;
                }
                case MatrixId_Tags.RoomAlias: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.alias, into);
                    return;
                }
                case MatrixId_Tags.User: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.id, into);
                    return;
                }
                case MatrixId_Tags.EventOnRoomId: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.roomId, into);
                    FfiConverterString.write(inner.eventId, into);
                    return;
                }
                case MatrixId_Tags.EventOnRoomAlias: {
                    ordinalConverter.write(5, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.alias, into);
                    FfiConverterString.write(inner.eventId, into);
                    return;
                }
                default:
                    // Throwing from here means that MatrixId_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case MatrixId_Tags.Room: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterString.allocationSize(inner.id);
                    return size;
                }
                case MatrixId_Tags.RoomAlias: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterString.allocationSize(inner.alias);
                    return size;
                }
                case MatrixId_Tags.User: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterString.allocationSize(inner.id);
                    return size;
                }
                case MatrixId_Tags.EventOnRoomId: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterString.allocationSize(inner.roomId);
                    size += FfiConverterString.allocationSize(inner.eventId);
                    return size;
                }
                case MatrixId_Tags.EventOnRoomAlias: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(5);
                    size += FfiConverterString.allocationSize(inner.alias);
                    size += FfiConverterString.allocationSize(inner.eventId);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Flat error type: MediaInfoError
export var MediaInfoError_Tags;
(function (MediaInfoError_Tags) {
    MediaInfoError_Tags["MissingField"] = "MissingField";
    MediaInfoError_Tags["InvalidField"] = "InvalidField";
})(MediaInfoError_Tags || (MediaInfoError_Tags = {}));
export const MediaInfoError = (() => {
    class MissingField extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "MediaInfoError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 1;
        tag = MediaInfoError_Tags.MissingField;
        constructor(message) {
            super("MediaInfoError", "MissingField", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 1);
        }
    }
    class InvalidField extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "MediaInfoError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 2;
        tag = MediaInfoError_Tags.InvalidField;
        constructor(message) {
            super("MediaInfoError", "InvalidField", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 2);
        }
    }
    // Utility function which does not rely on instanceof.
    function instanceOf(e) {
        return e[uniffiTypeNameSymbol] === "MediaInfoError";
    }
    return {
        MissingField,
        InvalidField,
        instanceOf,
    };
})();
const FfiConverterTypeMediaInfoError = (() => {
    const intConverter = FfiConverterInt32;
    class FfiConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (intConverter.read(from)) {
                case 1: return new MediaInfoError.MissingField(FfiConverterString.read(from));
                case 2: return new MediaInfoError.InvalidField(FfiConverterString.read(from));
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            const obj = value;
            const index = obj[variantOrdinalSymbol];
            intConverter.write(index, into);
        }
        allocationSize(value) {
            return intConverter.allocationSize(0);
        }
    }
    return new FfiConverter();
})();
/**
 * The policy that decides if media previews should be shown in the timeline.
 */
export var MediaPreviews;
(function (MediaPreviews) {
    /**
     * Always show media previews in the timeline.
     */
    MediaPreviews[MediaPreviews["On"] = 0] = "On";
    /**
     * Show media previews in the timeline only if the room is private.
     */
    MediaPreviews[MediaPreviews["Private"] = 1] = "Private";
    /**
     * Never show media previews in the timeline.
     */
    MediaPreviews[MediaPreviews["Off"] = 2] = "Off";
})(MediaPreviews || (MediaPreviews = {}));
const FfiConverterTypeMediaPreviews = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return MediaPreviews.On;
                case 2: return MediaPreviews.Private;
                case 3: return MediaPreviews.Off;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case MediaPreviews.On: return ordinalConverter.write(1, into);
                case MediaPreviews.Private: return ordinalConverter.write(2, into);
                case MediaPreviews.Off: return ordinalConverter.write(3, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
export var Membership;
(function (Membership) {
    Membership[Membership["Invited"] = 0] = "Invited";
    Membership[Membership["Joined"] = 1] = "Joined";
    Membership[Membership["Left"] = 2] = "Left";
    Membership[Membership["Knocked"] = 3] = "Knocked";
    Membership[Membership["Banned"] = 4] = "Banned";
})(Membership || (Membership = {}));
const FfiConverterTypeMembership = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return Membership.Invited;
                case 2: return Membership.Joined;
                case 3: return Membership.Left;
                case 4: return Membership.Knocked;
                case 5: return Membership.Banned;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case Membership.Invited: return ordinalConverter.write(1, into);
                case Membership.Joined: return ordinalConverter.write(2, into);
                case Membership.Left: return ordinalConverter.write(3, into);
                case Membership.Knocked: return ordinalConverter.write(4, into);
                case Membership.Banned: return ordinalConverter.write(5, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
export var MembershipChange;
(function (MembershipChange) {
    MembershipChange[MembershipChange["None"] = 0] = "None";
    MembershipChange[MembershipChange["Error"] = 1] = "Error";
    MembershipChange[MembershipChange["Joined"] = 2] = "Joined";
    MembershipChange[MembershipChange["Left"] = 3] = "Left";
    MembershipChange[MembershipChange["Banned"] = 4] = "Banned";
    MembershipChange[MembershipChange["Unbanned"] = 5] = "Unbanned";
    MembershipChange[MembershipChange["Kicked"] = 6] = "Kicked";
    MembershipChange[MembershipChange["Invited"] = 7] = "Invited";
    MembershipChange[MembershipChange["KickedAndBanned"] = 8] = "KickedAndBanned";
    MembershipChange[MembershipChange["InvitationAccepted"] = 9] = "InvitationAccepted";
    MembershipChange[MembershipChange["InvitationRejected"] = 10] = "InvitationRejected";
    MembershipChange[MembershipChange["InvitationRevoked"] = 11] = "InvitationRevoked";
    MembershipChange[MembershipChange["Knocked"] = 12] = "Knocked";
    MembershipChange[MembershipChange["KnockAccepted"] = 13] = "KnockAccepted";
    MembershipChange[MembershipChange["KnockRetracted"] = 14] = "KnockRetracted";
    MembershipChange[MembershipChange["KnockDenied"] = 15] = "KnockDenied";
    MembershipChange[MembershipChange["NotImplemented"] = 16] = "NotImplemented";
})(MembershipChange || (MembershipChange = {}));
const FfiConverterTypeMembershipChange = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return MembershipChange.None;
                case 2: return MembershipChange.Error;
                case 3: return MembershipChange.Joined;
                case 4: return MembershipChange.Left;
                case 5: return MembershipChange.Banned;
                case 6: return MembershipChange.Unbanned;
                case 7: return MembershipChange.Kicked;
                case 8: return MembershipChange.Invited;
                case 9: return MembershipChange.KickedAndBanned;
                case 10: return MembershipChange.InvitationAccepted;
                case 11: return MembershipChange.InvitationRejected;
                case 12: return MembershipChange.InvitationRevoked;
                case 13: return MembershipChange.Knocked;
                case 14: return MembershipChange.KnockAccepted;
                case 15: return MembershipChange.KnockRetracted;
                case 16: return MembershipChange.KnockDenied;
                case 17: return MembershipChange.NotImplemented;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case MembershipChange.None: return ordinalConverter.write(1, into);
                case MembershipChange.Error: return ordinalConverter.write(2, into);
                case MembershipChange.Joined: return ordinalConverter.write(3, into);
                case MembershipChange.Left: return ordinalConverter.write(4, into);
                case MembershipChange.Banned: return ordinalConverter.write(5, into);
                case MembershipChange.Unbanned: return ordinalConverter.write(6, into);
                case MembershipChange.Kicked: return ordinalConverter.write(7, into);
                case MembershipChange.Invited: return ordinalConverter.write(8, into);
                case MembershipChange.KickedAndBanned: return ordinalConverter.write(9, into);
                case MembershipChange.InvitationAccepted: return ordinalConverter.write(10, into);
                case MembershipChange.InvitationRejected: return ordinalConverter.write(11, into);
                case MembershipChange.InvitationRevoked: return ordinalConverter.write(12, into);
                case MembershipChange.Knocked: return ordinalConverter.write(13, into);
                case MembershipChange.KnockAccepted: return ordinalConverter.write(14, into);
                case MembershipChange.KnockRetracted: return ordinalConverter.write(15, into);
                case MembershipChange.KnockDenied: return ordinalConverter.write(16, into);
                case MembershipChange.NotImplemented: return ordinalConverter.write(17, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Enum: MembershipState
export var MembershipState_Tags;
(function (MembershipState_Tags) {
    MembershipState_Tags["Ban"] = "Ban";
    MembershipState_Tags["Invite"] = "Invite";
    MembershipState_Tags["Join"] = "Join";
    MembershipState_Tags["Knock"] = "Knock";
    MembershipState_Tags["Leave"] = "Leave";
    MembershipState_Tags["Custom"] = "Custom";
})(MembershipState_Tags || (MembershipState_Tags = {}));
export const MembershipState = (() => {
    /**
     * The user is banned.
     */
    class Ban_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MembershipState";
        tag = MembershipState_Tags.Ban;
        constructor() {
            super("MembershipState", "Ban");
        }
        static new() {
            return new Ban_();
        }
        static instanceOf(obj) {
            return obj.tag === MembershipState_Tags.Ban;
        }
    }
    /**
     * The user has been invited.
     */
    class Invite_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MembershipState";
        tag = MembershipState_Tags.Invite;
        constructor() {
            super("MembershipState", "Invite");
        }
        static new() {
            return new Invite_();
        }
        static instanceOf(obj) {
            return obj.tag === MembershipState_Tags.Invite;
        }
    }
    /**
     * The user has joined.
     */
    class Join_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MembershipState";
        tag = MembershipState_Tags.Join;
        constructor() {
            super("MembershipState", "Join");
        }
        static new() {
            return new Join_();
        }
        static instanceOf(obj) {
            return obj.tag === MembershipState_Tags.Join;
        }
    }
    /**
     * The user has requested to join.
     */
    class Knock_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MembershipState";
        tag = MembershipState_Tags.Knock;
        constructor() {
            super("MembershipState", "Knock");
        }
        static new() {
            return new Knock_();
        }
        static instanceOf(obj) {
            return obj.tag === MembershipState_Tags.Knock;
        }
    }
    /**
     * The user has left.
     */
    class Leave_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MembershipState";
        tag = MembershipState_Tags.Leave;
        constructor() {
            super("MembershipState", "Leave");
        }
        static new() {
            return new Leave_();
        }
        static instanceOf(obj) {
            return obj.tag === MembershipState_Tags.Leave;
        }
    }
    /**
     * A custom membership state value.
     */
    class Custom_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MembershipState";
        tag = MembershipState_Tags.Custom;
        inner;
        constructor(inner) {
            super("MembershipState", "Custom");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Custom_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MembershipState_Tags.Custom;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "MembershipState";
    }
    return Object.freeze({
        instanceOf,
        Ban: Ban_,
        Invite: Invite_,
        Join: Join_,
        Knock: Knock_,
        Leave: Leave_,
        Custom: Custom_
    });
})();
// FfiConverter for enum MembershipState
const FfiConverterTypeMembershipState = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new MembershipState.Ban();
                case 2: return new MembershipState.Invite();
                case 3: return new MembershipState.Join();
                case 4: return new MembershipState.Knock();
                case 5: return new MembershipState.Leave();
                case 6: return new MembershipState.Custom({ value: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case MembershipState_Tags.Ban: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case MembershipState_Tags.Invite: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case MembershipState_Tags.Join: {
                    ordinalConverter.write(3, into);
                    return;
                }
                case MembershipState_Tags.Knock: {
                    ordinalConverter.write(4, into);
                    return;
                }
                case MembershipState_Tags.Leave: {
                    ordinalConverter.write(5, into);
                    return;
                }
                case MembershipState_Tags.Custom: {
                    ordinalConverter.write(6, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.value, into);
                    return;
                }
                default:
                    // Throwing from here means that MembershipState_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case MembershipState_Tags.Ban: {
                    return ordinalConverter.allocationSize(1);
                }
                case MembershipState_Tags.Invite: {
                    return ordinalConverter.allocationSize(2);
                }
                case MembershipState_Tags.Join: {
                    return ordinalConverter.allocationSize(3);
                }
                case MembershipState_Tags.Knock: {
                    return ordinalConverter.allocationSize(4);
                }
                case MembershipState_Tags.Leave: {
                    return ordinalConverter.allocationSize(5);
                }
                case MembershipState_Tags.Custom: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(6);
                    size += FfiConverterString.allocationSize(inner.value);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: MessageFormat
export var MessageFormat_Tags;
(function (MessageFormat_Tags) {
    MessageFormat_Tags["Html"] = "Html";
    MessageFormat_Tags["Unknown"] = "Unknown";
})(MessageFormat_Tags || (MessageFormat_Tags = {}));
export const MessageFormat = (() => {
    class Html_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageFormat";
        tag = MessageFormat_Tags.Html;
        constructor() {
            super("MessageFormat", "Html");
        }
        static new() {
            return new Html_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageFormat_Tags.Html;
        }
    }
    class Unknown_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageFormat";
        tag = MessageFormat_Tags.Unknown;
        inner;
        constructor(inner) {
            super("MessageFormat", "Unknown");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Unknown_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MessageFormat_Tags.Unknown;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "MessageFormat";
    }
    return Object.freeze({
        instanceOf,
        Html: Html_,
        Unknown: Unknown_
    });
})();
// FfiConverter for enum MessageFormat
const FfiConverterTypeMessageFormat = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new MessageFormat.Html();
                case 2: return new MessageFormat.Unknown({ format: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case MessageFormat_Tags.Html: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case MessageFormat_Tags.Unknown: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.format, into);
                    return;
                }
                default:
                    // Throwing from here means that MessageFormat_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case MessageFormat_Tags.Html: {
                    return ordinalConverter.allocationSize(1);
                }
                case MessageFormat_Tags.Unknown: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterString.allocationSize(inner.format);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: MessageLikeEventContent
export var MessageLikeEventContent_Tags;
(function (MessageLikeEventContent_Tags) {
    MessageLikeEventContent_Tags["CallAnswer"] = "CallAnswer";
    MessageLikeEventContent_Tags["CallInvite"] = "CallInvite";
    MessageLikeEventContent_Tags["RtcNotification"] = "RtcNotification";
    MessageLikeEventContent_Tags["CallHangup"] = "CallHangup";
    MessageLikeEventContent_Tags["CallCandidates"] = "CallCandidates";
    MessageLikeEventContent_Tags["KeyVerificationReady"] = "KeyVerificationReady";
    MessageLikeEventContent_Tags["KeyVerificationStart"] = "KeyVerificationStart";
    MessageLikeEventContent_Tags["KeyVerificationCancel"] = "KeyVerificationCancel";
    MessageLikeEventContent_Tags["KeyVerificationAccept"] = "KeyVerificationAccept";
    MessageLikeEventContent_Tags["KeyVerificationKey"] = "KeyVerificationKey";
    MessageLikeEventContent_Tags["KeyVerificationMac"] = "KeyVerificationMac";
    MessageLikeEventContent_Tags["KeyVerificationDone"] = "KeyVerificationDone";
    MessageLikeEventContent_Tags["Poll"] = "Poll";
    MessageLikeEventContent_Tags["ReactionContent"] = "ReactionContent";
    MessageLikeEventContent_Tags["RoomEncrypted"] = "RoomEncrypted";
    MessageLikeEventContent_Tags["RoomMessage"] = "RoomMessage";
    MessageLikeEventContent_Tags["RoomRedaction"] = "RoomRedaction";
    MessageLikeEventContent_Tags["Sticker"] = "Sticker";
})(MessageLikeEventContent_Tags || (MessageLikeEventContent_Tags = {}));
export const MessageLikeEventContent = (() => {
    class CallAnswer_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventContent";
        tag = MessageLikeEventContent_Tags.CallAnswer;
        constructor() {
            super("MessageLikeEventContent", "CallAnswer");
        }
        static new() {
            return new CallAnswer_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventContent_Tags.CallAnswer;
        }
    }
    class CallInvite_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventContent";
        tag = MessageLikeEventContent_Tags.CallInvite;
        constructor() {
            super("MessageLikeEventContent", "CallInvite");
        }
        static new() {
            return new CallInvite_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventContent_Tags.CallInvite;
        }
    }
    class RtcNotification_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventContent";
        tag = MessageLikeEventContent_Tags.RtcNotification;
        inner;
        constructor(inner) {
            super("MessageLikeEventContent", "RtcNotification");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new RtcNotification_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventContent_Tags.RtcNotification;
        }
    }
    class CallHangup_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventContent";
        tag = MessageLikeEventContent_Tags.CallHangup;
        constructor() {
            super("MessageLikeEventContent", "CallHangup");
        }
        static new() {
            return new CallHangup_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventContent_Tags.CallHangup;
        }
    }
    class CallCandidates_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventContent";
        tag = MessageLikeEventContent_Tags.CallCandidates;
        constructor() {
            super("MessageLikeEventContent", "CallCandidates");
        }
        static new() {
            return new CallCandidates_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventContent_Tags.CallCandidates;
        }
    }
    class KeyVerificationReady_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventContent";
        tag = MessageLikeEventContent_Tags.KeyVerificationReady;
        constructor() {
            super("MessageLikeEventContent", "KeyVerificationReady");
        }
        static new() {
            return new KeyVerificationReady_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventContent_Tags.KeyVerificationReady;
        }
    }
    class KeyVerificationStart_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventContent";
        tag = MessageLikeEventContent_Tags.KeyVerificationStart;
        constructor() {
            super("MessageLikeEventContent", "KeyVerificationStart");
        }
        static new() {
            return new KeyVerificationStart_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventContent_Tags.KeyVerificationStart;
        }
    }
    class KeyVerificationCancel_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventContent";
        tag = MessageLikeEventContent_Tags.KeyVerificationCancel;
        constructor() {
            super("MessageLikeEventContent", "KeyVerificationCancel");
        }
        static new() {
            return new KeyVerificationCancel_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventContent_Tags.KeyVerificationCancel;
        }
    }
    class KeyVerificationAccept_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventContent";
        tag = MessageLikeEventContent_Tags.KeyVerificationAccept;
        constructor() {
            super("MessageLikeEventContent", "KeyVerificationAccept");
        }
        static new() {
            return new KeyVerificationAccept_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventContent_Tags.KeyVerificationAccept;
        }
    }
    class KeyVerificationKey_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventContent";
        tag = MessageLikeEventContent_Tags.KeyVerificationKey;
        constructor() {
            super("MessageLikeEventContent", "KeyVerificationKey");
        }
        static new() {
            return new KeyVerificationKey_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventContent_Tags.KeyVerificationKey;
        }
    }
    class KeyVerificationMac_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventContent";
        tag = MessageLikeEventContent_Tags.KeyVerificationMac;
        constructor() {
            super("MessageLikeEventContent", "KeyVerificationMac");
        }
        static new() {
            return new KeyVerificationMac_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventContent_Tags.KeyVerificationMac;
        }
    }
    class KeyVerificationDone_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventContent";
        tag = MessageLikeEventContent_Tags.KeyVerificationDone;
        constructor() {
            super("MessageLikeEventContent", "KeyVerificationDone");
        }
        static new() {
            return new KeyVerificationDone_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventContent_Tags.KeyVerificationDone;
        }
    }
    class Poll_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventContent";
        tag = MessageLikeEventContent_Tags.Poll;
        inner;
        constructor(inner) {
            super("MessageLikeEventContent", "Poll");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Poll_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventContent_Tags.Poll;
        }
    }
    class ReactionContent_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventContent";
        tag = MessageLikeEventContent_Tags.ReactionContent;
        inner;
        constructor(inner) {
            super("MessageLikeEventContent", "ReactionContent");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new ReactionContent_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventContent_Tags.ReactionContent;
        }
    }
    class RoomEncrypted_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventContent";
        tag = MessageLikeEventContent_Tags.RoomEncrypted;
        constructor() {
            super("MessageLikeEventContent", "RoomEncrypted");
        }
        static new() {
            return new RoomEncrypted_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventContent_Tags.RoomEncrypted;
        }
    }
    class RoomMessage_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventContent";
        tag = MessageLikeEventContent_Tags.RoomMessage;
        inner;
        constructor(inner) {
            super("MessageLikeEventContent", "RoomMessage");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new RoomMessage_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventContent_Tags.RoomMessage;
        }
    }
    class RoomRedaction_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventContent";
        tag = MessageLikeEventContent_Tags.RoomRedaction;
        inner;
        constructor(inner) {
            super("MessageLikeEventContent", "RoomRedaction");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new RoomRedaction_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventContent_Tags.RoomRedaction;
        }
    }
    class Sticker_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventContent";
        tag = MessageLikeEventContent_Tags.Sticker;
        constructor() {
            super("MessageLikeEventContent", "Sticker");
        }
        static new() {
            return new Sticker_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventContent_Tags.Sticker;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "MessageLikeEventContent";
    }
    return Object.freeze({
        instanceOf,
        CallAnswer: CallAnswer_,
        CallInvite: CallInvite_,
        RtcNotification: RtcNotification_,
        CallHangup: CallHangup_,
        CallCandidates: CallCandidates_,
        KeyVerificationReady: KeyVerificationReady_,
        KeyVerificationStart: KeyVerificationStart_,
        KeyVerificationCancel: KeyVerificationCancel_,
        KeyVerificationAccept: KeyVerificationAccept_,
        KeyVerificationKey: KeyVerificationKey_,
        KeyVerificationMac: KeyVerificationMac_,
        KeyVerificationDone: KeyVerificationDone_,
        Poll: Poll_,
        ReactionContent: ReactionContent_,
        RoomEncrypted: RoomEncrypted_,
        RoomMessage: RoomMessage_,
        RoomRedaction: RoomRedaction_,
        Sticker: Sticker_
    });
})();
// FfiConverter for enum MessageLikeEventContent
const FfiConverterTypeMessageLikeEventContent = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new MessageLikeEventContent.CallAnswer();
                case 2: return new MessageLikeEventContent.CallInvite();
                case 3: return new MessageLikeEventContent.RtcNotification({ notificationType: FfiConverterTypeRtcNotificationType.read(from), expirationTs: FfiConverterTypeTimestamp.read(from) });
                case 4: return new MessageLikeEventContent.CallHangup();
                case 5: return new MessageLikeEventContent.CallCandidates();
                case 6: return new MessageLikeEventContent.KeyVerificationReady();
                case 7: return new MessageLikeEventContent.KeyVerificationStart();
                case 8: return new MessageLikeEventContent.KeyVerificationCancel();
                case 9: return new MessageLikeEventContent.KeyVerificationAccept();
                case 10: return new MessageLikeEventContent.KeyVerificationKey();
                case 11: return new MessageLikeEventContent.KeyVerificationMac();
                case 12: return new MessageLikeEventContent.KeyVerificationDone();
                case 13: return new MessageLikeEventContent.Poll({ question: FfiConverterString.read(from) });
                case 14: return new MessageLikeEventContent.ReactionContent({ relatedEventId: FfiConverterString.read(from) });
                case 15: return new MessageLikeEventContent.RoomEncrypted();
                case 16: return new MessageLikeEventContent.RoomMessage({ messageType: FfiConverterTypeMessageType.read(from), inReplyToEventId: FfiConverterOptionalString.read(from) });
                case 17: return new MessageLikeEventContent.RoomRedaction({ redactedEventId: FfiConverterOptionalString.read(from), reason: FfiConverterOptionalString.read(from) });
                case 18: return new MessageLikeEventContent.Sticker();
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case MessageLikeEventContent_Tags.CallAnswer: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case MessageLikeEventContent_Tags.CallInvite: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case MessageLikeEventContent_Tags.RtcNotification: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterTypeRtcNotificationType.write(inner.notificationType, into);
                    FfiConverterTypeTimestamp.write(inner.expirationTs, into);
                    return;
                }
                case MessageLikeEventContent_Tags.CallHangup: {
                    ordinalConverter.write(4, into);
                    return;
                }
                case MessageLikeEventContent_Tags.CallCandidates: {
                    ordinalConverter.write(5, into);
                    return;
                }
                case MessageLikeEventContent_Tags.KeyVerificationReady: {
                    ordinalConverter.write(6, into);
                    return;
                }
                case MessageLikeEventContent_Tags.KeyVerificationStart: {
                    ordinalConverter.write(7, into);
                    return;
                }
                case MessageLikeEventContent_Tags.KeyVerificationCancel: {
                    ordinalConverter.write(8, into);
                    return;
                }
                case MessageLikeEventContent_Tags.KeyVerificationAccept: {
                    ordinalConverter.write(9, into);
                    return;
                }
                case MessageLikeEventContent_Tags.KeyVerificationKey: {
                    ordinalConverter.write(10, into);
                    return;
                }
                case MessageLikeEventContent_Tags.KeyVerificationMac: {
                    ordinalConverter.write(11, into);
                    return;
                }
                case MessageLikeEventContent_Tags.KeyVerificationDone: {
                    ordinalConverter.write(12, into);
                    return;
                }
                case MessageLikeEventContent_Tags.Poll: {
                    ordinalConverter.write(13, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.question, into);
                    return;
                }
                case MessageLikeEventContent_Tags.ReactionContent: {
                    ordinalConverter.write(14, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.relatedEventId, into);
                    return;
                }
                case MessageLikeEventContent_Tags.RoomEncrypted: {
                    ordinalConverter.write(15, into);
                    return;
                }
                case MessageLikeEventContent_Tags.RoomMessage: {
                    ordinalConverter.write(16, into);
                    const inner = value.inner;
                    FfiConverterTypeMessageType.write(inner.messageType, into);
                    FfiConverterOptionalString.write(inner.inReplyToEventId, into);
                    return;
                }
                case MessageLikeEventContent_Tags.RoomRedaction: {
                    ordinalConverter.write(17, into);
                    const inner = value.inner;
                    FfiConverterOptionalString.write(inner.redactedEventId, into);
                    FfiConverterOptionalString.write(inner.reason, into);
                    return;
                }
                case MessageLikeEventContent_Tags.Sticker: {
                    ordinalConverter.write(18, into);
                    return;
                }
                default:
                    // Throwing from here means that MessageLikeEventContent_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case MessageLikeEventContent_Tags.CallAnswer: {
                    return ordinalConverter.allocationSize(1);
                }
                case MessageLikeEventContent_Tags.CallInvite: {
                    return ordinalConverter.allocationSize(2);
                }
                case MessageLikeEventContent_Tags.RtcNotification: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterTypeRtcNotificationType.allocationSize(inner.notificationType);
                    size += FfiConverterTypeTimestamp.allocationSize(inner.expirationTs);
                    return size;
                }
                case MessageLikeEventContent_Tags.CallHangup: {
                    return ordinalConverter.allocationSize(4);
                }
                case MessageLikeEventContent_Tags.CallCandidates: {
                    return ordinalConverter.allocationSize(5);
                }
                case MessageLikeEventContent_Tags.KeyVerificationReady: {
                    return ordinalConverter.allocationSize(6);
                }
                case MessageLikeEventContent_Tags.KeyVerificationStart: {
                    return ordinalConverter.allocationSize(7);
                }
                case MessageLikeEventContent_Tags.KeyVerificationCancel: {
                    return ordinalConverter.allocationSize(8);
                }
                case MessageLikeEventContent_Tags.KeyVerificationAccept: {
                    return ordinalConverter.allocationSize(9);
                }
                case MessageLikeEventContent_Tags.KeyVerificationKey: {
                    return ordinalConverter.allocationSize(10);
                }
                case MessageLikeEventContent_Tags.KeyVerificationMac: {
                    return ordinalConverter.allocationSize(11);
                }
                case MessageLikeEventContent_Tags.KeyVerificationDone: {
                    return ordinalConverter.allocationSize(12);
                }
                case MessageLikeEventContent_Tags.Poll: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(13);
                    size += FfiConverterString.allocationSize(inner.question);
                    return size;
                }
                case MessageLikeEventContent_Tags.ReactionContent: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(14);
                    size += FfiConverterString.allocationSize(inner.relatedEventId);
                    return size;
                }
                case MessageLikeEventContent_Tags.RoomEncrypted: {
                    return ordinalConverter.allocationSize(15);
                }
                case MessageLikeEventContent_Tags.RoomMessage: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(16);
                    size += FfiConverterTypeMessageType.allocationSize(inner.messageType);
                    size += FfiConverterOptionalString.allocationSize(inner.inReplyToEventId);
                    return size;
                }
                case MessageLikeEventContent_Tags.RoomRedaction: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(17);
                    size += FfiConverterOptionalString.allocationSize(inner.redactedEventId);
                    size += FfiConverterOptionalString.allocationSize(inner.reason);
                    return size;
                }
                case MessageLikeEventContent_Tags.Sticker: {
                    return ordinalConverter.allocationSize(18);
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: MessageLikeEventType
export var MessageLikeEventType_Tags;
(function (MessageLikeEventType_Tags) {
    MessageLikeEventType_Tags["CallAnswer"] = "CallAnswer";
    MessageLikeEventType_Tags["CallCandidates"] = "CallCandidates";
    MessageLikeEventType_Tags["CallHangup"] = "CallHangup";
    MessageLikeEventType_Tags["CallInvite"] = "CallInvite";
    MessageLikeEventType_Tags["RtcNotification"] = "RtcNotification";
    MessageLikeEventType_Tags["KeyVerificationAccept"] = "KeyVerificationAccept";
    MessageLikeEventType_Tags["KeyVerificationCancel"] = "KeyVerificationCancel";
    MessageLikeEventType_Tags["KeyVerificationDone"] = "KeyVerificationDone";
    MessageLikeEventType_Tags["KeyVerificationKey"] = "KeyVerificationKey";
    MessageLikeEventType_Tags["KeyVerificationMac"] = "KeyVerificationMac";
    MessageLikeEventType_Tags["KeyVerificationReady"] = "KeyVerificationReady";
    MessageLikeEventType_Tags["KeyVerificationStart"] = "KeyVerificationStart";
    MessageLikeEventType_Tags["PollEnd"] = "PollEnd";
    MessageLikeEventType_Tags["PollResponse"] = "PollResponse";
    MessageLikeEventType_Tags["PollStart"] = "PollStart";
    MessageLikeEventType_Tags["Reaction"] = "Reaction";
    MessageLikeEventType_Tags["RoomEncrypted"] = "RoomEncrypted";
    MessageLikeEventType_Tags["RoomMessage"] = "RoomMessage";
    MessageLikeEventType_Tags["RoomRedaction"] = "RoomRedaction";
    MessageLikeEventType_Tags["Sticker"] = "Sticker";
    MessageLikeEventType_Tags["UnstablePollEnd"] = "UnstablePollEnd";
    MessageLikeEventType_Tags["UnstablePollResponse"] = "UnstablePollResponse";
    MessageLikeEventType_Tags["UnstablePollStart"] = "UnstablePollStart";
    MessageLikeEventType_Tags["Other"] = "Other";
})(MessageLikeEventType_Tags || (MessageLikeEventType_Tags = {}));
export const MessageLikeEventType = (() => {
    class CallAnswer_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventType";
        tag = MessageLikeEventType_Tags.CallAnswer;
        constructor() {
            super("MessageLikeEventType", "CallAnswer");
        }
        static new() {
            return new CallAnswer_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventType_Tags.CallAnswer;
        }
    }
    class CallCandidates_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventType";
        tag = MessageLikeEventType_Tags.CallCandidates;
        constructor() {
            super("MessageLikeEventType", "CallCandidates");
        }
        static new() {
            return new CallCandidates_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventType_Tags.CallCandidates;
        }
    }
    class CallHangup_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventType";
        tag = MessageLikeEventType_Tags.CallHangup;
        constructor() {
            super("MessageLikeEventType", "CallHangup");
        }
        static new() {
            return new CallHangup_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventType_Tags.CallHangup;
        }
    }
    class CallInvite_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventType";
        tag = MessageLikeEventType_Tags.CallInvite;
        constructor() {
            super("MessageLikeEventType", "CallInvite");
        }
        static new() {
            return new CallInvite_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventType_Tags.CallInvite;
        }
    }
    class RtcNotification_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventType";
        tag = MessageLikeEventType_Tags.RtcNotification;
        constructor() {
            super("MessageLikeEventType", "RtcNotification");
        }
        static new() {
            return new RtcNotification_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventType_Tags.RtcNotification;
        }
    }
    class KeyVerificationAccept_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventType";
        tag = MessageLikeEventType_Tags.KeyVerificationAccept;
        constructor() {
            super("MessageLikeEventType", "KeyVerificationAccept");
        }
        static new() {
            return new KeyVerificationAccept_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventType_Tags.KeyVerificationAccept;
        }
    }
    class KeyVerificationCancel_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventType";
        tag = MessageLikeEventType_Tags.KeyVerificationCancel;
        constructor() {
            super("MessageLikeEventType", "KeyVerificationCancel");
        }
        static new() {
            return new KeyVerificationCancel_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventType_Tags.KeyVerificationCancel;
        }
    }
    class KeyVerificationDone_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventType";
        tag = MessageLikeEventType_Tags.KeyVerificationDone;
        constructor() {
            super("MessageLikeEventType", "KeyVerificationDone");
        }
        static new() {
            return new KeyVerificationDone_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventType_Tags.KeyVerificationDone;
        }
    }
    class KeyVerificationKey_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventType";
        tag = MessageLikeEventType_Tags.KeyVerificationKey;
        constructor() {
            super("MessageLikeEventType", "KeyVerificationKey");
        }
        static new() {
            return new KeyVerificationKey_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventType_Tags.KeyVerificationKey;
        }
    }
    class KeyVerificationMac_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventType";
        tag = MessageLikeEventType_Tags.KeyVerificationMac;
        constructor() {
            super("MessageLikeEventType", "KeyVerificationMac");
        }
        static new() {
            return new KeyVerificationMac_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventType_Tags.KeyVerificationMac;
        }
    }
    class KeyVerificationReady_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventType";
        tag = MessageLikeEventType_Tags.KeyVerificationReady;
        constructor() {
            super("MessageLikeEventType", "KeyVerificationReady");
        }
        static new() {
            return new KeyVerificationReady_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventType_Tags.KeyVerificationReady;
        }
    }
    class KeyVerificationStart_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventType";
        tag = MessageLikeEventType_Tags.KeyVerificationStart;
        constructor() {
            super("MessageLikeEventType", "KeyVerificationStart");
        }
        static new() {
            return new KeyVerificationStart_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventType_Tags.KeyVerificationStart;
        }
    }
    class PollEnd_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventType";
        tag = MessageLikeEventType_Tags.PollEnd;
        constructor() {
            super("MessageLikeEventType", "PollEnd");
        }
        static new() {
            return new PollEnd_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventType_Tags.PollEnd;
        }
    }
    class PollResponse_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventType";
        tag = MessageLikeEventType_Tags.PollResponse;
        constructor() {
            super("MessageLikeEventType", "PollResponse");
        }
        static new() {
            return new PollResponse_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventType_Tags.PollResponse;
        }
    }
    class PollStart_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventType";
        tag = MessageLikeEventType_Tags.PollStart;
        constructor() {
            super("MessageLikeEventType", "PollStart");
        }
        static new() {
            return new PollStart_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventType_Tags.PollStart;
        }
    }
    class Reaction_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventType";
        tag = MessageLikeEventType_Tags.Reaction;
        constructor() {
            super("MessageLikeEventType", "Reaction");
        }
        static new() {
            return new Reaction_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventType_Tags.Reaction;
        }
    }
    class RoomEncrypted_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventType";
        tag = MessageLikeEventType_Tags.RoomEncrypted;
        constructor() {
            super("MessageLikeEventType", "RoomEncrypted");
        }
        static new() {
            return new RoomEncrypted_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventType_Tags.RoomEncrypted;
        }
    }
    class RoomMessage_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventType";
        tag = MessageLikeEventType_Tags.RoomMessage;
        constructor() {
            super("MessageLikeEventType", "RoomMessage");
        }
        static new() {
            return new RoomMessage_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventType_Tags.RoomMessage;
        }
    }
    class RoomRedaction_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventType";
        tag = MessageLikeEventType_Tags.RoomRedaction;
        constructor() {
            super("MessageLikeEventType", "RoomRedaction");
        }
        static new() {
            return new RoomRedaction_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventType_Tags.RoomRedaction;
        }
    }
    class Sticker_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventType";
        tag = MessageLikeEventType_Tags.Sticker;
        constructor() {
            super("MessageLikeEventType", "Sticker");
        }
        static new() {
            return new Sticker_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventType_Tags.Sticker;
        }
    }
    class UnstablePollEnd_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventType";
        tag = MessageLikeEventType_Tags.UnstablePollEnd;
        constructor() {
            super("MessageLikeEventType", "UnstablePollEnd");
        }
        static new() {
            return new UnstablePollEnd_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventType_Tags.UnstablePollEnd;
        }
    }
    class UnstablePollResponse_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventType";
        tag = MessageLikeEventType_Tags.UnstablePollResponse;
        constructor() {
            super("MessageLikeEventType", "UnstablePollResponse");
        }
        static new() {
            return new UnstablePollResponse_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventType_Tags.UnstablePollResponse;
        }
    }
    class UnstablePollStart_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventType";
        tag = MessageLikeEventType_Tags.UnstablePollStart;
        constructor() {
            super("MessageLikeEventType", "UnstablePollStart");
        }
        static new() {
            return new UnstablePollStart_();
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventType_Tags.UnstablePollStart;
        }
    }
    class Other_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageLikeEventType";
        tag = MessageLikeEventType_Tags.Other;
        inner;
        constructor(v0) {
            super("MessageLikeEventType", "Other");
            this.inner = Object.freeze([v0]);
        }
        static new(v0) {
            return new Other_(v0);
        }
        static instanceOf(obj) {
            return obj.tag === MessageLikeEventType_Tags.Other;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "MessageLikeEventType";
    }
    return Object.freeze({
        instanceOf,
        CallAnswer: CallAnswer_,
        CallCandidates: CallCandidates_,
        CallHangup: CallHangup_,
        CallInvite: CallInvite_,
        RtcNotification: RtcNotification_,
        KeyVerificationAccept: KeyVerificationAccept_,
        KeyVerificationCancel: KeyVerificationCancel_,
        KeyVerificationDone: KeyVerificationDone_,
        KeyVerificationKey: KeyVerificationKey_,
        KeyVerificationMac: KeyVerificationMac_,
        KeyVerificationReady: KeyVerificationReady_,
        KeyVerificationStart: KeyVerificationStart_,
        PollEnd: PollEnd_,
        PollResponse: PollResponse_,
        PollStart: PollStart_,
        Reaction: Reaction_,
        RoomEncrypted: RoomEncrypted_,
        RoomMessage: RoomMessage_,
        RoomRedaction: RoomRedaction_,
        Sticker: Sticker_,
        UnstablePollEnd: UnstablePollEnd_,
        UnstablePollResponse: UnstablePollResponse_,
        UnstablePollStart: UnstablePollStart_,
        Other: Other_
    });
})();
// FfiConverter for enum MessageLikeEventType
const FfiConverterTypeMessageLikeEventType = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new MessageLikeEventType.CallAnswer();
                case 2: return new MessageLikeEventType.CallCandidates();
                case 3: return new MessageLikeEventType.CallHangup();
                case 4: return new MessageLikeEventType.CallInvite();
                case 5: return new MessageLikeEventType.RtcNotification();
                case 6: return new MessageLikeEventType.KeyVerificationAccept();
                case 7: return new MessageLikeEventType.KeyVerificationCancel();
                case 8: return new MessageLikeEventType.KeyVerificationDone();
                case 9: return new MessageLikeEventType.KeyVerificationKey();
                case 10: return new MessageLikeEventType.KeyVerificationMac();
                case 11: return new MessageLikeEventType.KeyVerificationReady();
                case 12: return new MessageLikeEventType.KeyVerificationStart();
                case 13: return new MessageLikeEventType.PollEnd();
                case 14: return new MessageLikeEventType.PollResponse();
                case 15: return new MessageLikeEventType.PollStart();
                case 16: return new MessageLikeEventType.Reaction();
                case 17: return new MessageLikeEventType.RoomEncrypted();
                case 18: return new MessageLikeEventType.RoomMessage();
                case 19: return new MessageLikeEventType.RoomRedaction();
                case 20: return new MessageLikeEventType.Sticker();
                case 21: return new MessageLikeEventType.UnstablePollEnd();
                case 22: return new MessageLikeEventType.UnstablePollResponse();
                case 23: return new MessageLikeEventType.UnstablePollStart();
                case 24: return new MessageLikeEventType.Other(FfiConverterString.read(from));
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case MessageLikeEventType_Tags.CallAnswer: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case MessageLikeEventType_Tags.CallCandidates: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case MessageLikeEventType_Tags.CallHangup: {
                    ordinalConverter.write(3, into);
                    return;
                }
                case MessageLikeEventType_Tags.CallInvite: {
                    ordinalConverter.write(4, into);
                    return;
                }
                case MessageLikeEventType_Tags.RtcNotification: {
                    ordinalConverter.write(5, into);
                    return;
                }
                case MessageLikeEventType_Tags.KeyVerificationAccept: {
                    ordinalConverter.write(6, into);
                    return;
                }
                case MessageLikeEventType_Tags.KeyVerificationCancel: {
                    ordinalConverter.write(7, into);
                    return;
                }
                case MessageLikeEventType_Tags.KeyVerificationDone: {
                    ordinalConverter.write(8, into);
                    return;
                }
                case MessageLikeEventType_Tags.KeyVerificationKey: {
                    ordinalConverter.write(9, into);
                    return;
                }
                case MessageLikeEventType_Tags.KeyVerificationMac: {
                    ordinalConverter.write(10, into);
                    return;
                }
                case MessageLikeEventType_Tags.KeyVerificationReady: {
                    ordinalConverter.write(11, into);
                    return;
                }
                case MessageLikeEventType_Tags.KeyVerificationStart: {
                    ordinalConverter.write(12, into);
                    return;
                }
                case MessageLikeEventType_Tags.PollEnd: {
                    ordinalConverter.write(13, into);
                    return;
                }
                case MessageLikeEventType_Tags.PollResponse: {
                    ordinalConverter.write(14, into);
                    return;
                }
                case MessageLikeEventType_Tags.PollStart: {
                    ordinalConverter.write(15, into);
                    return;
                }
                case MessageLikeEventType_Tags.Reaction: {
                    ordinalConverter.write(16, into);
                    return;
                }
                case MessageLikeEventType_Tags.RoomEncrypted: {
                    ordinalConverter.write(17, into);
                    return;
                }
                case MessageLikeEventType_Tags.RoomMessage: {
                    ordinalConverter.write(18, into);
                    return;
                }
                case MessageLikeEventType_Tags.RoomRedaction: {
                    ordinalConverter.write(19, into);
                    return;
                }
                case MessageLikeEventType_Tags.Sticker: {
                    ordinalConverter.write(20, into);
                    return;
                }
                case MessageLikeEventType_Tags.UnstablePollEnd: {
                    ordinalConverter.write(21, into);
                    return;
                }
                case MessageLikeEventType_Tags.UnstablePollResponse: {
                    ordinalConverter.write(22, into);
                    return;
                }
                case MessageLikeEventType_Tags.UnstablePollStart: {
                    ordinalConverter.write(23, into);
                    return;
                }
                case MessageLikeEventType_Tags.Other: {
                    ordinalConverter.write(24, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner[0], into);
                    return;
                }
                default:
                    // Throwing from here means that MessageLikeEventType_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case MessageLikeEventType_Tags.CallAnswer: {
                    return ordinalConverter.allocationSize(1);
                }
                case MessageLikeEventType_Tags.CallCandidates: {
                    return ordinalConverter.allocationSize(2);
                }
                case MessageLikeEventType_Tags.CallHangup: {
                    return ordinalConverter.allocationSize(3);
                }
                case MessageLikeEventType_Tags.CallInvite: {
                    return ordinalConverter.allocationSize(4);
                }
                case MessageLikeEventType_Tags.RtcNotification: {
                    return ordinalConverter.allocationSize(5);
                }
                case MessageLikeEventType_Tags.KeyVerificationAccept: {
                    return ordinalConverter.allocationSize(6);
                }
                case MessageLikeEventType_Tags.KeyVerificationCancel: {
                    return ordinalConverter.allocationSize(7);
                }
                case MessageLikeEventType_Tags.KeyVerificationDone: {
                    return ordinalConverter.allocationSize(8);
                }
                case MessageLikeEventType_Tags.KeyVerificationKey: {
                    return ordinalConverter.allocationSize(9);
                }
                case MessageLikeEventType_Tags.KeyVerificationMac: {
                    return ordinalConverter.allocationSize(10);
                }
                case MessageLikeEventType_Tags.KeyVerificationReady: {
                    return ordinalConverter.allocationSize(11);
                }
                case MessageLikeEventType_Tags.KeyVerificationStart: {
                    return ordinalConverter.allocationSize(12);
                }
                case MessageLikeEventType_Tags.PollEnd: {
                    return ordinalConverter.allocationSize(13);
                }
                case MessageLikeEventType_Tags.PollResponse: {
                    return ordinalConverter.allocationSize(14);
                }
                case MessageLikeEventType_Tags.PollStart: {
                    return ordinalConverter.allocationSize(15);
                }
                case MessageLikeEventType_Tags.Reaction: {
                    return ordinalConverter.allocationSize(16);
                }
                case MessageLikeEventType_Tags.RoomEncrypted: {
                    return ordinalConverter.allocationSize(17);
                }
                case MessageLikeEventType_Tags.RoomMessage: {
                    return ordinalConverter.allocationSize(18);
                }
                case MessageLikeEventType_Tags.RoomRedaction: {
                    return ordinalConverter.allocationSize(19);
                }
                case MessageLikeEventType_Tags.Sticker: {
                    return ordinalConverter.allocationSize(20);
                }
                case MessageLikeEventType_Tags.UnstablePollEnd: {
                    return ordinalConverter.allocationSize(21);
                }
                case MessageLikeEventType_Tags.UnstablePollResponse: {
                    return ordinalConverter.allocationSize(22);
                }
                case MessageLikeEventType_Tags.UnstablePollStart: {
                    return ordinalConverter.allocationSize(23);
                }
                case MessageLikeEventType_Tags.Other: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(24);
                    size += FfiConverterString.allocationSize(inner[0]);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: MessageType
export var MessageType_Tags;
(function (MessageType_Tags) {
    MessageType_Tags["Emote"] = "Emote";
    MessageType_Tags["Image"] = "Image";
    MessageType_Tags["Audio"] = "Audio";
    MessageType_Tags["Video"] = "Video";
    MessageType_Tags["File"] = "File";
    MessageType_Tags["Notice"] = "Notice";
    MessageType_Tags["Text"] = "Text";
    MessageType_Tags["Location"] = "Location";
    MessageType_Tags["Other"] = "Other";
})(MessageType_Tags || (MessageType_Tags = {}));
export const MessageType = (() => {
    class Emote_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageType";
        tag = MessageType_Tags.Emote;
        inner;
        constructor(inner) {
            super("MessageType", "Emote");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Emote_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MessageType_Tags.Emote;
        }
    }
    class Image_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageType";
        tag = MessageType_Tags.Image;
        inner;
        constructor(inner) {
            super("MessageType", "Image");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Image_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MessageType_Tags.Image;
        }
    }
    class Audio_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageType";
        tag = MessageType_Tags.Audio;
        inner;
        constructor(inner) {
            super("MessageType", "Audio");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Audio_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MessageType_Tags.Audio;
        }
    }
    class Video_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageType";
        tag = MessageType_Tags.Video;
        inner;
        constructor(inner) {
            super("MessageType", "Video");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Video_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MessageType_Tags.Video;
        }
    }
    class File_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageType";
        tag = MessageType_Tags.File;
        inner;
        constructor(inner) {
            super("MessageType", "File");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new File_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MessageType_Tags.File;
        }
    }
    class Notice_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageType";
        tag = MessageType_Tags.Notice;
        inner;
        constructor(inner) {
            super("MessageType", "Notice");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Notice_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MessageType_Tags.Notice;
        }
    }
    class Text_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageType";
        tag = MessageType_Tags.Text;
        inner;
        constructor(inner) {
            super("MessageType", "Text");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Text_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MessageType_Tags.Text;
        }
    }
    class Location_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageType";
        tag = MessageType_Tags.Location;
        inner;
        constructor(inner) {
            super("MessageType", "Location");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Location_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MessageType_Tags.Location;
        }
    }
    class Other_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MessageType";
        tag = MessageType_Tags.Other;
        inner;
        constructor(inner) {
            super("MessageType", "Other");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Other_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MessageType_Tags.Other;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "MessageType";
    }
    return Object.freeze({
        instanceOf,
        Emote: Emote_,
        Image: Image_,
        Audio: Audio_,
        Video: Video_,
        File: File_,
        Notice: Notice_,
        Text: Text_,
        Location: Location_,
        Other: Other_
    });
})();
// FfiConverter for enum MessageType
const FfiConverterTypeMessageType = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new MessageType.Emote({ content: FfiConverterTypeEmoteMessageContent.read(from) });
                case 2: return new MessageType.Image({ content: FfiConverterTypeImageMessageContent.read(from) });
                case 3: return new MessageType.Audio({ content: FfiConverterTypeAudioMessageContent.read(from) });
                case 4: return new MessageType.Video({ content: FfiConverterTypeVideoMessageContent.read(from) });
                case 5: return new MessageType.File({ content: FfiConverterTypeFileMessageContent.read(from) });
                case 6: return new MessageType.Notice({ content: FfiConverterTypeNoticeMessageContent.read(from) });
                case 7: return new MessageType.Text({ content: FfiConverterTypeTextMessageContent.read(from) });
                case 8: return new MessageType.Location({ content: FfiConverterTypeLocationContent.read(from) });
                case 9: return new MessageType.Other({ msgtype: FfiConverterString.read(from), body: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case MessageType_Tags.Emote: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterTypeEmoteMessageContent.write(inner.content, into);
                    return;
                }
                case MessageType_Tags.Image: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterTypeImageMessageContent.write(inner.content, into);
                    return;
                }
                case MessageType_Tags.Audio: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterTypeAudioMessageContent.write(inner.content, into);
                    return;
                }
                case MessageType_Tags.Video: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterTypeVideoMessageContent.write(inner.content, into);
                    return;
                }
                case MessageType_Tags.File: {
                    ordinalConverter.write(5, into);
                    const inner = value.inner;
                    FfiConverterTypeFileMessageContent.write(inner.content, into);
                    return;
                }
                case MessageType_Tags.Notice: {
                    ordinalConverter.write(6, into);
                    const inner = value.inner;
                    FfiConverterTypeNoticeMessageContent.write(inner.content, into);
                    return;
                }
                case MessageType_Tags.Text: {
                    ordinalConverter.write(7, into);
                    const inner = value.inner;
                    FfiConverterTypeTextMessageContent.write(inner.content, into);
                    return;
                }
                case MessageType_Tags.Location: {
                    ordinalConverter.write(8, into);
                    const inner = value.inner;
                    FfiConverterTypeLocationContent.write(inner.content, into);
                    return;
                }
                case MessageType_Tags.Other: {
                    ordinalConverter.write(9, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.msgtype, into);
                    FfiConverterString.write(inner.body, into);
                    return;
                }
                default:
                    // Throwing from here means that MessageType_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case MessageType_Tags.Emote: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterTypeEmoteMessageContent.allocationSize(inner.content);
                    return size;
                }
                case MessageType_Tags.Image: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterTypeImageMessageContent.allocationSize(inner.content);
                    return size;
                }
                case MessageType_Tags.Audio: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterTypeAudioMessageContent.allocationSize(inner.content);
                    return size;
                }
                case MessageType_Tags.Video: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterTypeVideoMessageContent.allocationSize(inner.content);
                    return size;
                }
                case MessageType_Tags.File: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(5);
                    size += FfiConverterTypeFileMessageContent.allocationSize(inner.content);
                    return size;
                }
                case MessageType_Tags.Notice: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(6);
                    size += FfiConverterTypeNoticeMessageContent.allocationSize(inner.content);
                    return size;
                }
                case MessageType_Tags.Text: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(7);
                    size += FfiConverterTypeTextMessageContent.allocationSize(inner.content);
                    return size;
                }
                case MessageType_Tags.Location: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(8);
                    size += FfiConverterTypeLocationContent.allocationSize(inner.content);
                    return size;
                }
                case MessageType_Tags.Other: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(9);
                    size += FfiConverterString.allocationSize(inner.msgtype);
                    size += FfiConverterString.allocationSize(inner.body);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: MsgLikeKind
export var MsgLikeKind_Tags;
(function (MsgLikeKind_Tags) {
    MsgLikeKind_Tags["Message"] = "Message";
    MsgLikeKind_Tags["Sticker"] = "Sticker";
    MsgLikeKind_Tags["Poll"] = "Poll";
    MsgLikeKind_Tags["Redacted"] = "Redacted";
    MsgLikeKind_Tags["UnableToDecrypt"] = "UnableToDecrypt";
    MsgLikeKind_Tags["Other"] = "Other";
})(MsgLikeKind_Tags || (MsgLikeKind_Tags = {}));
export const MsgLikeKind = (() => {
    /**
     * An `m.room.message` event or extensible event, including edits.
     */
    class Message_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MsgLikeKind";
        tag = MsgLikeKind_Tags.Message;
        inner;
        constructor(inner) {
            super("MsgLikeKind", "Message");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Message_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MsgLikeKind_Tags.Message;
        }
    }
    /**
     * An `m.sticker` event.
     */
    class Sticker_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MsgLikeKind";
        tag = MsgLikeKind_Tags.Sticker;
        inner;
        constructor(inner) {
            super("MsgLikeKind", "Sticker");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Sticker_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MsgLikeKind_Tags.Sticker;
        }
    }
    /**
     * An `m.poll.start` event.
     */
    class Poll_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MsgLikeKind";
        tag = MsgLikeKind_Tags.Poll;
        inner;
        constructor(inner) {
            super("MsgLikeKind", "Poll");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Poll_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MsgLikeKind_Tags.Poll;
        }
    }
    /**
     * A redacted message.
     */
    class Redacted_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MsgLikeKind";
        tag = MsgLikeKind_Tags.Redacted;
        constructor() {
            super("MsgLikeKind", "Redacted");
        }
        static new() {
            return new Redacted_();
        }
        static instanceOf(obj) {
            return obj.tag === MsgLikeKind_Tags.Redacted;
        }
    }
    /**
     * An `m.room.encrypted` event that could not be decrypted.
     */
    class UnableToDecrypt_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MsgLikeKind";
        tag = MsgLikeKind_Tags.UnableToDecrypt;
        inner;
        constructor(inner) {
            super("MsgLikeKind", "UnableToDecrypt");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new UnableToDecrypt_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MsgLikeKind_Tags.UnableToDecrypt;
        }
    }
    /**
     * A custom message like event.
     */
    class Other_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "MsgLikeKind";
        tag = MsgLikeKind_Tags.Other;
        inner;
        constructor(inner) {
            super("MsgLikeKind", "Other");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Other_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === MsgLikeKind_Tags.Other;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "MsgLikeKind";
    }
    return Object.freeze({
        instanceOf,
        Message: Message_,
        Sticker: Sticker_,
        Poll: Poll_,
        Redacted: Redacted_,
        UnableToDecrypt: UnableToDecrypt_,
        Other: Other_
    });
})();
// FfiConverter for enum MsgLikeKind
const FfiConverterTypeMsgLikeKind = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new MsgLikeKind.Message({ content: FfiConverterTypeMessageContent.read(from) });
                case 2: return new MsgLikeKind.Sticker({ body: FfiConverterString.read(from), info: FfiConverterTypeImageInfo.read(from), source: FfiConverterTypeMediaSource.read(from) });
                case 3: return new MsgLikeKind.Poll({ question: FfiConverterString.read(from), kind: FfiConverterTypePollKind.read(from), maxSelections: FfiConverterUInt64.read(from), answers: FfiConverterArrayTypePollAnswer.read(from), votes: FfiConverterMapStringArrayString.read(from), endTime: FfiConverterOptionalTypeTimestamp.read(from), hasBeenEdited: FfiConverterBool.read(from) });
                case 4: return new MsgLikeKind.Redacted();
                case 5: return new MsgLikeKind.UnableToDecrypt({ msg: FfiConverterTypeEncryptedMessage.read(from) });
                case 6: return new MsgLikeKind.Other({ eventType: FfiConverterTypeMessageLikeEventType.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case MsgLikeKind_Tags.Message: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterTypeMessageContent.write(inner.content, into);
                    return;
                }
                case MsgLikeKind_Tags.Sticker: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.body, into);
                    FfiConverterTypeImageInfo.write(inner.info, into);
                    FfiConverterTypeMediaSource.write(inner.source, into);
                    return;
                }
                case MsgLikeKind_Tags.Poll: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.question, into);
                    FfiConverterTypePollKind.write(inner.kind, into);
                    FfiConverterUInt64.write(inner.maxSelections, into);
                    FfiConverterArrayTypePollAnswer.write(inner.answers, into);
                    FfiConverterMapStringArrayString.write(inner.votes, into);
                    FfiConverterOptionalTypeTimestamp.write(inner.endTime, into);
                    FfiConverterBool.write(inner.hasBeenEdited, into);
                    return;
                }
                case MsgLikeKind_Tags.Redacted: {
                    ordinalConverter.write(4, into);
                    return;
                }
                case MsgLikeKind_Tags.UnableToDecrypt: {
                    ordinalConverter.write(5, into);
                    const inner = value.inner;
                    FfiConverterTypeEncryptedMessage.write(inner.msg, into);
                    return;
                }
                case MsgLikeKind_Tags.Other: {
                    ordinalConverter.write(6, into);
                    const inner = value.inner;
                    FfiConverterTypeMessageLikeEventType.write(inner.eventType, into);
                    return;
                }
                default:
                    // Throwing from here means that MsgLikeKind_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case MsgLikeKind_Tags.Message: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterTypeMessageContent.allocationSize(inner.content);
                    return size;
                }
                case MsgLikeKind_Tags.Sticker: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterString.allocationSize(inner.body);
                    size += FfiConverterTypeImageInfo.allocationSize(inner.info);
                    size += FfiConverterTypeMediaSource.allocationSize(inner.source);
                    return size;
                }
                case MsgLikeKind_Tags.Poll: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterString.allocationSize(inner.question);
                    size += FfiConverterTypePollKind.allocationSize(inner.kind);
                    size += FfiConverterUInt64.allocationSize(inner.maxSelections);
                    size += FfiConverterArrayTypePollAnswer.allocationSize(inner.answers);
                    size += FfiConverterMapStringArrayString.allocationSize(inner.votes);
                    size += FfiConverterOptionalTypeTimestamp.allocationSize(inner.endTime);
                    size += FfiConverterBool.allocationSize(inner.hasBeenEdited);
                    return size;
                }
                case MsgLikeKind_Tags.Redacted: {
                    return ordinalConverter.allocationSize(4);
                }
                case MsgLikeKind_Tags.UnableToDecrypt: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(5);
                    size += FfiConverterTypeEncryptedMessage.allocationSize(inner.msg);
                    return size;
                }
                case MsgLikeKind_Tags.Other: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(6);
                    size += FfiConverterTypeMessageLikeEventType.allocationSize(inner.eventType);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: NotificationEvent
export var NotificationEvent_Tags;
(function (NotificationEvent_Tags) {
    NotificationEvent_Tags["Timeline"] = "Timeline";
    NotificationEvent_Tags["Invite"] = "Invite";
})(NotificationEvent_Tags || (NotificationEvent_Tags = {}));
export const NotificationEvent = (() => {
    class Timeline_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "NotificationEvent";
        tag = NotificationEvent_Tags.Timeline;
        inner;
        constructor(inner) {
            super("NotificationEvent", "Timeline");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Timeline_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === NotificationEvent_Tags.Timeline;
        }
    }
    class Invite_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "NotificationEvent";
        tag = NotificationEvent_Tags.Invite;
        inner;
        constructor(inner) {
            super("NotificationEvent", "Invite");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Invite_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === NotificationEvent_Tags.Invite;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "NotificationEvent";
    }
    return Object.freeze({
        instanceOf,
        Timeline: Timeline_,
        Invite: Invite_
    });
})();
// FfiConverter for enum NotificationEvent
const FfiConverterTypeNotificationEvent = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new NotificationEvent.Timeline({ event: FfiConverterTypeTimelineEvent.read(from) });
                case 2: return new NotificationEvent.Invite({ sender: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case NotificationEvent_Tags.Timeline: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterTypeTimelineEvent.write(inner.event, into);
                    return;
                }
                case NotificationEvent_Tags.Invite: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.sender, into);
                    return;
                }
                default:
                    // Throwing from here means that NotificationEvent_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case NotificationEvent_Tags.Timeline: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterTypeTimelineEvent.allocationSize(inner.event);
                    return size;
                }
                case NotificationEvent_Tags.Invite: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterString.allocationSize(inner.sender);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: NotificationProcessSetup
export var NotificationProcessSetup_Tags;
(function (NotificationProcessSetup_Tags) {
    NotificationProcessSetup_Tags["MultipleProcesses"] = "MultipleProcesses";
    NotificationProcessSetup_Tags["SingleProcess"] = "SingleProcess";
})(NotificationProcessSetup_Tags || (NotificationProcessSetup_Tags = {}));
export const NotificationProcessSetup = (() => {
    class MultipleProcesses_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "NotificationProcessSetup";
        tag = NotificationProcessSetup_Tags.MultipleProcesses;
        constructor() {
            super("NotificationProcessSetup", "MultipleProcesses");
        }
        static new() {
            return new MultipleProcesses_();
        }
        static instanceOf(obj) {
            return obj.tag === NotificationProcessSetup_Tags.MultipleProcesses;
        }
    }
    class SingleProcess_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "NotificationProcessSetup";
        tag = NotificationProcessSetup_Tags.SingleProcess;
        inner;
        constructor(inner) {
            super("NotificationProcessSetup", "SingleProcess");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new SingleProcess_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === NotificationProcessSetup_Tags.SingleProcess;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "NotificationProcessSetup";
    }
    return Object.freeze({
        instanceOf,
        MultipleProcesses: MultipleProcesses_,
        SingleProcess: SingleProcess_
    });
})();
// FfiConverter for enum NotificationProcessSetup
const FfiConverterTypeNotificationProcessSetup = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new NotificationProcessSetup.MultipleProcesses();
                case 2: return new NotificationProcessSetup.SingleProcess({ syncService: FfiConverterTypeSyncService.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case NotificationProcessSetup_Tags.MultipleProcesses: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case NotificationProcessSetup_Tags.SingleProcess: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterTypeSyncService.write(inner.syncService, into);
                    return;
                }
                default:
                    // Throwing from here means that NotificationProcessSetup_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case NotificationProcessSetup_Tags.MultipleProcesses: {
                    return ordinalConverter.allocationSize(1);
                }
                case NotificationProcessSetup_Tags.SingleProcess: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterTypeSyncService.allocationSize(inner.syncService);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Error type: NotificationSettingsError
// Enum: NotificationSettingsError
export var NotificationSettingsError_Tags;
(function (NotificationSettingsError_Tags) {
    NotificationSettingsError_Tags["Generic"] = "Generic";
    NotificationSettingsError_Tags["InvalidParameter"] = "InvalidParameter";
    NotificationSettingsError_Tags["InvalidRoomId"] = "InvalidRoomId";
    NotificationSettingsError_Tags["RuleNotFound"] = "RuleNotFound";
    NotificationSettingsError_Tags["UnableToAddPushRule"] = "UnableToAddPushRule";
    NotificationSettingsError_Tags["UnableToRemovePushRule"] = "UnableToRemovePushRule";
    NotificationSettingsError_Tags["UnableToSavePushRules"] = "UnableToSavePushRules";
    NotificationSettingsError_Tags["UnableToUpdatePushRule"] = "UnableToUpdatePushRule";
})(NotificationSettingsError_Tags || (NotificationSettingsError_Tags = {}));
export const NotificationSettingsError = (() => {
    class Generic_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "NotificationSettingsError";
        tag = NotificationSettingsError_Tags.Generic;
        inner;
        constructor(inner) {
            super("NotificationSettingsError", "Generic");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Generic_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === NotificationSettingsError_Tags.Generic;
        }
        static hasInner(obj) {
            return Generic_.instanceOf(obj);
        }
        static getInner(obj) {
            return obj.inner;
        }
    }
    /**
     * Invalid parameter.
     */
    class InvalidParameter_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "NotificationSettingsError";
        tag = NotificationSettingsError_Tags.InvalidParameter;
        inner;
        constructor(inner) {
            super("NotificationSettingsError", "InvalidParameter");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new InvalidParameter_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === NotificationSettingsError_Tags.InvalidParameter;
        }
        static hasInner(obj) {
            return InvalidParameter_.instanceOf(obj);
        }
        static getInner(obj) {
            return obj.inner;
        }
    }
    /**
     * Invalid room id.
     */
    class InvalidRoomId_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "NotificationSettingsError";
        tag = NotificationSettingsError_Tags.InvalidRoomId;
        inner;
        constructor(inner) {
            super("NotificationSettingsError", "InvalidRoomId");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new InvalidRoomId_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === NotificationSettingsError_Tags.InvalidRoomId;
        }
        static hasInner(obj) {
            return InvalidRoomId_.instanceOf(obj);
        }
        static getInner(obj) {
            return obj.inner;
        }
    }
    /**
     * Rule not found
     */
    class RuleNotFound_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "NotificationSettingsError";
        tag = NotificationSettingsError_Tags.RuleNotFound;
        inner;
        constructor(inner) {
            super("NotificationSettingsError", "RuleNotFound");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new RuleNotFound_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === NotificationSettingsError_Tags.RuleNotFound;
        }
        static hasInner(obj) {
            return RuleNotFound_.instanceOf(obj);
        }
        static getInner(obj) {
            return obj.inner;
        }
    }
    /**
     * Unable to add push rule.
     */
    class UnableToAddPushRule_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "NotificationSettingsError";
        tag = NotificationSettingsError_Tags.UnableToAddPushRule;
        constructor() {
            super("NotificationSettingsError", "UnableToAddPushRule");
        }
        static new() {
            return new UnableToAddPushRule_();
        }
        static instanceOf(obj) {
            return obj.tag === NotificationSettingsError_Tags.UnableToAddPushRule;
        }
        static hasInner(obj) {
            return false;
        }
    }
    /**
     * Unable to remove push rule.
     */
    class UnableToRemovePushRule_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "NotificationSettingsError";
        tag = NotificationSettingsError_Tags.UnableToRemovePushRule;
        constructor() {
            super("NotificationSettingsError", "UnableToRemovePushRule");
        }
        static new() {
            return new UnableToRemovePushRule_();
        }
        static instanceOf(obj) {
            return obj.tag === NotificationSettingsError_Tags.UnableToRemovePushRule;
        }
        static hasInner(obj) {
            return false;
        }
    }
    /**
     * Unable to save the push rules
     */
    class UnableToSavePushRules_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "NotificationSettingsError";
        tag = NotificationSettingsError_Tags.UnableToSavePushRules;
        constructor() {
            super("NotificationSettingsError", "UnableToSavePushRules");
        }
        static new() {
            return new UnableToSavePushRules_();
        }
        static instanceOf(obj) {
            return obj.tag === NotificationSettingsError_Tags.UnableToSavePushRules;
        }
        static hasInner(obj) {
            return false;
        }
    }
    /**
     * Unable to update push rule.
     */
    class UnableToUpdatePushRule_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "NotificationSettingsError";
        tag = NotificationSettingsError_Tags.UnableToUpdatePushRule;
        constructor() {
            super("NotificationSettingsError", "UnableToUpdatePushRule");
        }
        static new() {
            return new UnableToUpdatePushRule_();
        }
        static instanceOf(obj) {
            return obj.tag === NotificationSettingsError_Tags.UnableToUpdatePushRule;
        }
        static hasInner(obj) {
            return false;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "NotificationSettingsError";
    }
    return Object.freeze({
        instanceOf,
        Generic: Generic_,
        InvalidParameter: InvalidParameter_,
        InvalidRoomId: InvalidRoomId_,
        RuleNotFound: RuleNotFound_,
        UnableToAddPushRule: UnableToAddPushRule_,
        UnableToRemovePushRule: UnableToRemovePushRule_,
        UnableToSavePushRules: UnableToSavePushRules_,
        UnableToUpdatePushRule: UnableToUpdatePushRule_
    });
})();
// FfiConverter for enum NotificationSettingsError
const FfiConverterTypeNotificationSettingsError = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new NotificationSettingsError.Generic({ msg: FfiConverterString.read(from) });
                case 2: return new NotificationSettingsError.InvalidParameter({ msg: FfiConverterString.read(from) });
                case 3: return new NotificationSettingsError.InvalidRoomId({ roomId: FfiConverterString.read(from) });
                case 4: return new NotificationSettingsError.RuleNotFound({ ruleId: FfiConverterString.read(from) });
                case 5: return new NotificationSettingsError.UnableToAddPushRule();
                case 6: return new NotificationSettingsError.UnableToRemovePushRule();
                case 7: return new NotificationSettingsError.UnableToSavePushRules();
                case 8: return new NotificationSettingsError.UnableToUpdatePushRule();
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case NotificationSettingsError_Tags.Generic: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.msg, into);
                    return;
                }
                case NotificationSettingsError_Tags.InvalidParameter: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.msg, into);
                    return;
                }
                case NotificationSettingsError_Tags.InvalidRoomId: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.roomId, into);
                    return;
                }
                case NotificationSettingsError_Tags.RuleNotFound: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.ruleId, into);
                    return;
                }
                case NotificationSettingsError_Tags.UnableToAddPushRule: {
                    ordinalConverter.write(5, into);
                    return;
                }
                case NotificationSettingsError_Tags.UnableToRemovePushRule: {
                    ordinalConverter.write(6, into);
                    return;
                }
                case NotificationSettingsError_Tags.UnableToSavePushRules: {
                    ordinalConverter.write(7, into);
                    return;
                }
                case NotificationSettingsError_Tags.UnableToUpdatePushRule: {
                    ordinalConverter.write(8, into);
                    return;
                }
                default:
                    // Throwing from here means that NotificationSettingsError_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case NotificationSettingsError_Tags.Generic: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterString.allocationSize(inner.msg);
                    return size;
                }
                case NotificationSettingsError_Tags.InvalidParameter: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterString.allocationSize(inner.msg);
                    return size;
                }
                case NotificationSettingsError_Tags.InvalidRoomId: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterString.allocationSize(inner.roomId);
                    return size;
                }
                case NotificationSettingsError_Tags.RuleNotFound: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterString.allocationSize(inner.ruleId);
                    return size;
                }
                case NotificationSettingsError_Tags.UnableToAddPushRule: {
                    return ordinalConverter.allocationSize(5);
                }
                case NotificationSettingsError_Tags.UnableToRemovePushRule: {
                    return ordinalConverter.allocationSize(6);
                }
                case NotificationSettingsError_Tags.UnableToSavePushRules: {
                    return ordinalConverter.allocationSize(7);
                }
                case NotificationSettingsError_Tags.UnableToUpdatePushRule: {
                    return ordinalConverter.allocationSize(8);
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: NotificationStatus
export var NotificationStatus_Tags;
(function (NotificationStatus_Tags) {
    NotificationStatus_Tags["Event"] = "Event";
    NotificationStatus_Tags["EventNotFound"] = "EventNotFound";
    NotificationStatus_Tags["EventFilteredOut"] = "EventFilteredOut";
})(NotificationStatus_Tags || (NotificationStatus_Tags = {}));
export const NotificationStatus = (() => {
    /**
     * The event has been found and was not filtered out.
     */
    class Event_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "NotificationStatus";
        tag = NotificationStatus_Tags.Event;
        inner;
        constructor(inner) {
            super("NotificationStatus", "Event");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Event_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === NotificationStatus_Tags.Event;
        }
    }
    /**
     * The event couldn't be found in the network queries used to find it.
     */
    class EventNotFound_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "NotificationStatus";
        tag = NotificationStatus_Tags.EventNotFound;
        constructor() {
            super("NotificationStatus", "EventNotFound");
        }
        static new() {
            return new EventNotFound_();
        }
        static instanceOf(obj) {
            return obj.tag === NotificationStatus_Tags.EventNotFound;
        }
    }
    /**
     * The event has been filtered out, either because of the user's push
     * rules, or because the user which triggered it is ignored by the
     * current user.
     */
    class EventFilteredOut_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "NotificationStatus";
        tag = NotificationStatus_Tags.EventFilteredOut;
        constructor() {
            super("NotificationStatus", "EventFilteredOut");
        }
        static new() {
            return new EventFilteredOut_();
        }
        static instanceOf(obj) {
            return obj.tag === NotificationStatus_Tags.EventFilteredOut;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "NotificationStatus";
    }
    return Object.freeze({
        instanceOf,
        Event: Event_,
        EventNotFound: EventNotFound_,
        EventFilteredOut: EventFilteredOut_
    });
})();
// FfiConverter for enum NotificationStatus
const FfiConverterTypeNotificationStatus = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new NotificationStatus.Event({ item: FfiConverterTypeNotificationItem.read(from) });
                case 2: return new NotificationStatus.EventNotFound();
                case 3: return new NotificationStatus.EventFilteredOut();
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case NotificationStatus_Tags.Event: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterTypeNotificationItem.write(inner.item, into);
                    return;
                }
                case NotificationStatus_Tags.EventNotFound: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case NotificationStatus_Tags.EventFilteredOut: {
                    ordinalConverter.write(3, into);
                    return;
                }
                default:
                    // Throwing from here means that NotificationStatus_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case NotificationStatus_Tags.Event: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterTypeNotificationItem.allocationSize(inner.item);
                    return size;
                }
                case NotificationStatus_Tags.EventNotFound: {
                    return ordinalConverter.allocationSize(2);
                }
                case NotificationStatus_Tags.EventFilteredOut: {
                    return ordinalConverter.allocationSize(3);
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Flat error type: OidcError
export var OidcError_Tags;
(function (OidcError_Tags) {
    OidcError_Tags["NotSupported"] = "NotSupported";
    OidcError_Tags["MetadataInvalid"] = "MetadataInvalid";
    OidcError_Tags["CallbackUrlInvalid"] = "CallbackUrlInvalid";
    OidcError_Tags["Cancelled"] = "Cancelled";
    OidcError_Tags["Generic"] = "Generic";
})(OidcError_Tags || (OidcError_Tags = {}));
export const OidcError = (() => {
    class NotSupported extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "OidcError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 1;
        tag = OidcError_Tags.NotSupported;
        constructor(message) {
            super("OidcError", "NotSupported", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 1);
        }
    }
    class MetadataInvalid extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "OidcError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 2;
        tag = OidcError_Tags.MetadataInvalid;
        constructor(message) {
            super("OidcError", "MetadataInvalid", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 2);
        }
    }
    class CallbackUrlInvalid extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "OidcError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 3;
        tag = OidcError_Tags.CallbackUrlInvalid;
        constructor(message) {
            super("OidcError", "CallbackUrlInvalid", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 3);
        }
    }
    class Cancelled extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "OidcError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 4;
        tag = OidcError_Tags.Cancelled;
        constructor(message) {
            super("OidcError", "Cancelled", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 4);
        }
    }
    class Generic extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "OidcError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 5;
        tag = OidcError_Tags.Generic;
        constructor(message) {
            super("OidcError", "Generic", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 5);
        }
    }
    // Utility function which does not rely on instanceof.
    function instanceOf(e) {
        return e[uniffiTypeNameSymbol] === "OidcError";
    }
    return {
        NotSupported,
        MetadataInvalid,
        CallbackUrlInvalid,
        Cancelled,
        Generic,
        instanceOf,
    };
})();
const FfiConverterTypeOidcError = (() => {
    const intConverter = FfiConverterInt32;
    class FfiConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (intConverter.read(from)) {
                case 1: return new OidcError.NotSupported(FfiConverterString.read(from));
                case 2: return new OidcError.MetadataInvalid(FfiConverterString.read(from));
                case 3: return new OidcError.CallbackUrlInvalid(FfiConverterString.read(from));
                case 4: return new OidcError.Cancelled(FfiConverterString.read(from));
                case 5: return new OidcError.Generic(FfiConverterString.read(from));
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            const obj = value;
            const index = obj[variantOrdinalSymbol];
            intConverter.write(index, into);
        }
        allocationSize(value) {
            return intConverter.allocationSize(0);
        }
    }
    return new FfiConverter();
})();
// Enum: OidcPrompt
export var OidcPrompt_Tags;
(function (OidcPrompt_Tags) {
    OidcPrompt_Tags["Create"] = "Create";
    OidcPrompt_Tags["Login"] = "Login";
    OidcPrompt_Tags["Consent"] = "Consent";
    OidcPrompt_Tags["Unknown"] = "Unknown";
})(OidcPrompt_Tags || (OidcPrompt_Tags = {}));
export const OidcPrompt = (() => {
    /**
     * The Authorization Server should prompt the End-User to create a user
     * account.
     *
     * Defined in [Initiating User Registration via OpenID Connect](https://openid.net/specs/openid-connect-prompt-create-1_0.html).
     */
    class Create_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "OidcPrompt";
        tag = OidcPrompt_Tags.Create;
        constructor() {
            super("OidcPrompt", "Create");
        }
        static new() {
            return new Create_();
        }
        static instanceOf(obj) {
            return obj.tag === OidcPrompt_Tags.Create;
        }
    }
    /**
     * The Authorization Server should prompt the End-User for
     * reauthentication.
     */
    class Login_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "OidcPrompt";
        tag = OidcPrompt_Tags.Login;
        constructor() {
            super("OidcPrompt", "Login");
        }
        static new() {
            return new Login_();
        }
        static instanceOf(obj) {
            return obj.tag === OidcPrompt_Tags.Login;
        }
    }
    /**
     * The Authorization Server should prompt the End-User for consent before
     * returning information to the Client.
     */
    class Consent_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "OidcPrompt";
        tag = OidcPrompt_Tags.Consent;
        constructor() {
            super("OidcPrompt", "Consent");
        }
        static new() {
            return new Consent_();
        }
        static instanceOf(obj) {
            return obj.tag === OidcPrompt_Tags.Consent;
        }
    }
    /**
     * An unknown value.
     */
    class Unknown_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "OidcPrompt";
        tag = OidcPrompt_Tags.Unknown;
        inner;
        constructor(inner) {
            super("OidcPrompt", "Unknown");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Unknown_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === OidcPrompt_Tags.Unknown;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "OidcPrompt";
    }
    return Object.freeze({
        instanceOf,
        Create: Create_,
        Login: Login_,
        Consent: Consent_,
        Unknown: Unknown_
    });
})();
// FfiConverter for enum OidcPrompt
const FfiConverterTypeOidcPrompt = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new OidcPrompt.Create();
                case 2: return new OidcPrompt.Login();
                case 3: return new OidcPrompt.Consent();
                case 4: return new OidcPrompt.Unknown({ value: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case OidcPrompt_Tags.Create: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case OidcPrompt_Tags.Login: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case OidcPrompt_Tags.Consent: {
                    ordinalConverter.write(3, into);
                    return;
                }
                case OidcPrompt_Tags.Unknown: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.value, into);
                    return;
                }
                default:
                    // Throwing from here means that OidcPrompt_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case OidcPrompt_Tags.Create: {
                    return ordinalConverter.allocationSize(1);
                }
                case OidcPrompt_Tags.Login: {
                    return ordinalConverter.allocationSize(2);
                }
                case OidcPrompt_Tags.Consent: {
                    return ordinalConverter.allocationSize(3);
                }
                case OidcPrompt_Tags.Unknown: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterString.allocationSize(inner.value);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: OtherState
export var OtherState_Tags;
(function (OtherState_Tags) {
    OtherState_Tags["PolicyRuleRoom"] = "PolicyRuleRoom";
    OtherState_Tags["PolicyRuleServer"] = "PolicyRuleServer";
    OtherState_Tags["PolicyRuleUser"] = "PolicyRuleUser";
    OtherState_Tags["RoomAliases"] = "RoomAliases";
    OtherState_Tags["RoomAvatar"] = "RoomAvatar";
    OtherState_Tags["RoomCanonicalAlias"] = "RoomCanonicalAlias";
    OtherState_Tags["RoomCreate"] = "RoomCreate";
    OtherState_Tags["RoomEncryption"] = "RoomEncryption";
    OtherState_Tags["RoomGuestAccess"] = "RoomGuestAccess";
    OtherState_Tags["RoomHistoryVisibility"] = "RoomHistoryVisibility";
    OtherState_Tags["RoomJoinRules"] = "RoomJoinRules";
    OtherState_Tags["RoomName"] = "RoomName";
    OtherState_Tags["RoomPinnedEvents"] = "RoomPinnedEvents";
    OtherState_Tags["RoomPowerLevels"] = "RoomPowerLevels";
    OtherState_Tags["RoomServerAcl"] = "RoomServerAcl";
    OtherState_Tags["RoomThirdPartyInvite"] = "RoomThirdPartyInvite";
    OtherState_Tags["RoomTombstone"] = "RoomTombstone";
    OtherState_Tags["RoomTopic"] = "RoomTopic";
    OtherState_Tags["SpaceChild"] = "SpaceChild";
    OtherState_Tags["SpaceParent"] = "SpaceParent";
    OtherState_Tags["Custom"] = "Custom";
})(OtherState_Tags || (OtherState_Tags = {}));
export const OtherState = (() => {
    class PolicyRuleRoom_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "OtherState";
        tag = OtherState_Tags.PolicyRuleRoom;
        constructor() {
            super("OtherState", "PolicyRuleRoom");
        }
        static new() {
            return new PolicyRuleRoom_();
        }
        static instanceOf(obj) {
            return obj.tag === OtherState_Tags.PolicyRuleRoom;
        }
    }
    class PolicyRuleServer_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "OtherState";
        tag = OtherState_Tags.PolicyRuleServer;
        constructor() {
            super("OtherState", "PolicyRuleServer");
        }
        static new() {
            return new PolicyRuleServer_();
        }
        static instanceOf(obj) {
            return obj.tag === OtherState_Tags.PolicyRuleServer;
        }
    }
    class PolicyRuleUser_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "OtherState";
        tag = OtherState_Tags.PolicyRuleUser;
        constructor() {
            super("OtherState", "PolicyRuleUser");
        }
        static new() {
            return new PolicyRuleUser_();
        }
        static instanceOf(obj) {
            return obj.tag === OtherState_Tags.PolicyRuleUser;
        }
    }
    class RoomAliases_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "OtherState";
        tag = OtherState_Tags.RoomAliases;
        constructor() {
            super("OtherState", "RoomAliases");
        }
        static new() {
            return new RoomAliases_();
        }
        static instanceOf(obj) {
            return obj.tag === OtherState_Tags.RoomAliases;
        }
    }
    class RoomAvatar_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "OtherState";
        tag = OtherState_Tags.RoomAvatar;
        inner;
        constructor(inner) {
            super("OtherState", "RoomAvatar");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new RoomAvatar_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === OtherState_Tags.RoomAvatar;
        }
    }
    class RoomCanonicalAlias_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "OtherState";
        tag = OtherState_Tags.RoomCanonicalAlias;
        constructor() {
            super("OtherState", "RoomCanonicalAlias");
        }
        static new() {
            return new RoomCanonicalAlias_();
        }
        static instanceOf(obj) {
            return obj.tag === OtherState_Tags.RoomCanonicalAlias;
        }
    }
    class RoomCreate_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "OtherState";
        tag = OtherState_Tags.RoomCreate;
        inner;
        constructor(inner) {
            super("OtherState", "RoomCreate");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new RoomCreate_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === OtherState_Tags.RoomCreate;
        }
    }
    class RoomEncryption_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "OtherState";
        tag = OtherState_Tags.RoomEncryption;
        constructor() {
            super("OtherState", "RoomEncryption");
        }
        static new() {
            return new RoomEncryption_();
        }
        static instanceOf(obj) {
            return obj.tag === OtherState_Tags.RoomEncryption;
        }
    }
    class RoomGuestAccess_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "OtherState";
        tag = OtherState_Tags.RoomGuestAccess;
        constructor() {
            super("OtherState", "RoomGuestAccess");
        }
        static new() {
            return new RoomGuestAccess_();
        }
        static instanceOf(obj) {
            return obj.tag === OtherState_Tags.RoomGuestAccess;
        }
    }
    class RoomHistoryVisibility_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "OtherState";
        tag = OtherState_Tags.RoomHistoryVisibility;
        inner;
        constructor(inner) {
            super("OtherState", "RoomHistoryVisibility");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new RoomHistoryVisibility_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === OtherState_Tags.RoomHistoryVisibility;
        }
    }
    class RoomJoinRules_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "OtherState";
        tag = OtherState_Tags.RoomJoinRules;
        inner;
        constructor(inner) {
            super("OtherState", "RoomJoinRules");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new RoomJoinRules_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === OtherState_Tags.RoomJoinRules;
        }
    }
    class RoomName_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "OtherState";
        tag = OtherState_Tags.RoomName;
        inner;
        constructor(inner) {
            super("OtherState", "RoomName");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new RoomName_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === OtherState_Tags.RoomName;
        }
    }
    class RoomPinnedEvents_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "OtherState";
        tag = OtherState_Tags.RoomPinnedEvents;
        inner;
        constructor(inner) {
            super("OtherState", "RoomPinnedEvents");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new RoomPinnedEvents_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === OtherState_Tags.RoomPinnedEvents;
        }
    }
    class RoomPowerLevels_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "OtherState";
        tag = OtherState_Tags.RoomPowerLevels;
        inner;
        constructor(inner) {
            super("OtherState", "RoomPowerLevels");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new RoomPowerLevels_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === OtherState_Tags.RoomPowerLevels;
        }
    }
    class RoomServerAcl_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "OtherState";
        tag = OtherState_Tags.RoomServerAcl;
        constructor() {
            super("OtherState", "RoomServerAcl");
        }
        static new() {
            return new RoomServerAcl_();
        }
        static instanceOf(obj) {
            return obj.tag === OtherState_Tags.RoomServerAcl;
        }
    }
    class RoomThirdPartyInvite_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "OtherState";
        tag = OtherState_Tags.RoomThirdPartyInvite;
        inner;
        constructor(inner) {
            super("OtherState", "RoomThirdPartyInvite");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new RoomThirdPartyInvite_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === OtherState_Tags.RoomThirdPartyInvite;
        }
    }
    class RoomTombstone_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "OtherState";
        tag = OtherState_Tags.RoomTombstone;
        constructor() {
            super("OtherState", "RoomTombstone");
        }
        static new() {
            return new RoomTombstone_();
        }
        static instanceOf(obj) {
            return obj.tag === OtherState_Tags.RoomTombstone;
        }
    }
    class RoomTopic_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "OtherState";
        tag = OtherState_Tags.RoomTopic;
        inner;
        constructor(inner) {
            super("OtherState", "RoomTopic");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new RoomTopic_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === OtherState_Tags.RoomTopic;
        }
    }
    class SpaceChild_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "OtherState";
        tag = OtherState_Tags.SpaceChild;
        constructor() {
            super("OtherState", "SpaceChild");
        }
        static new() {
            return new SpaceChild_();
        }
        static instanceOf(obj) {
            return obj.tag === OtherState_Tags.SpaceChild;
        }
    }
    class SpaceParent_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "OtherState";
        tag = OtherState_Tags.SpaceParent;
        constructor() {
            super("OtherState", "SpaceParent");
        }
        static new() {
            return new SpaceParent_();
        }
        static instanceOf(obj) {
            return obj.tag === OtherState_Tags.SpaceParent;
        }
    }
    class Custom_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "OtherState";
        tag = OtherState_Tags.Custom;
        inner;
        constructor(inner) {
            super("OtherState", "Custom");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Custom_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === OtherState_Tags.Custom;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "OtherState";
    }
    return Object.freeze({
        instanceOf,
        PolicyRuleRoom: PolicyRuleRoom_,
        PolicyRuleServer: PolicyRuleServer_,
        PolicyRuleUser: PolicyRuleUser_,
        RoomAliases: RoomAliases_,
        RoomAvatar: RoomAvatar_,
        RoomCanonicalAlias: RoomCanonicalAlias_,
        RoomCreate: RoomCreate_,
        RoomEncryption: RoomEncryption_,
        RoomGuestAccess: RoomGuestAccess_,
        RoomHistoryVisibility: RoomHistoryVisibility_,
        RoomJoinRules: RoomJoinRules_,
        RoomName: RoomName_,
        RoomPinnedEvents: RoomPinnedEvents_,
        RoomPowerLevels: RoomPowerLevels_,
        RoomServerAcl: RoomServerAcl_,
        RoomThirdPartyInvite: RoomThirdPartyInvite_,
        RoomTombstone: RoomTombstone_,
        RoomTopic: RoomTopic_,
        SpaceChild: SpaceChild_,
        SpaceParent: SpaceParent_,
        Custom: Custom_
    });
})();
// FfiConverter for enum OtherState
const FfiConverterTypeOtherState = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new OtherState.PolicyRuleRoom();
                case 2: return new OtherState.PolicyRuleServer();
                case 3: return new OtherState.PolicyRuleUser();
                case 4: return new OtherState.RoomAliases();
                case 5: return new OtherState.RoomAvatar({ url: FfiConverterOptionalString.read(from) });
                case 6: return new OtherState.RoomCanonicalAlias();
                case 7: return new OtherState.RoomCreate({ federate: FfiConverterOptionalBool.read(from) });
                case 8: return new OtherState.RoomEncryption();
                case 9: return new OtherState.RoomGuestAccess();
                case 10: return new OtherState.RoomHistoryVisibility({ historyVisibility: FfiConverterOptionalTypeHistoryVisibility.read(from) });
                case 11: return new OtherState.RoomJoinRules({ joinRule: FfiConverterOptionalTypeJoinRule.read(from) });
                case 12: return new OtherState.RoomName({ name: FfiConverterOptionalString.read(from) });
                case 13: return new OtherState.RoomPinnedEvents({ change: FfiConverterTypeRoomPinnedEventsChange.read(from) });
                case 14: return new OtherState.RoomPowerLevels({ users: FfiConverterMapStringInt64.read(from), previous: FfiConverterOptionalMapStringInt64.read(from) });
                case 15: return new OtherState.RoomServerAcl();
                case 16: return new OtherState.RoomThirdPartyInvite({ displayName: FfiConverterOptionalString.read(from) });
                case 17: return new OtherState.RoomTombstone();
                case 18: return new OtherState.RoomTopic({ topic: FfiConverterOptionalString.read(from) });
                case 19: return new OtherState.SpaceChild();
                case 20: return new OtherState.SpaceParent();
                case 21: return new OtherState.Custom({ eventType: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case OtherState_Tags.PolicyRuleRoom: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case OtherState_Tags.PolicyRuleServer: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case OtherState_Tags.PolicyRuleUser: {
                    ordinalConverter.write(3, into);
                    return;
                }
                case OtherState_Tags.RoomAliases: {
                    ordinalConverter.write(4, into);
                    return;
                }
                case OtherState_Tags.RoomAvatar: {
                    ordinalConverter.write(5, into);
                    const inner = value.inner;
                    FfiConverterOptionalString.write(inner.url, into);
                    return;
                }
                case OtherState_Tags.RoomCanonicalAlias: {
                    ordinalConverter.write(6, into);
                    return;
                }
                case OtherState_Tags.RoomCreate: {
                    ordinalConverter.write(7, into);
                    const inner = value.inner;
                    FfiConverterOptionalBool.write(inner.federate, into);
                    return;
                }
                case OtherState_Tags.RoomEncryption: {
                    ordinalConverter.write(8, into);
                    return;
                }
                case OtherState_Tags.RoomGuestAccess: {
                    ordinalConverter.write(9, into);
                    return;
                }
                case OtherState_Tags.RoomHistoryVisibility: {
                    ordinalConverter.write(10, into);
                    const inner = value.inner;
                    FfiConverterOptionalTypeHistoryVisibility.write(inner.historyVisibility, into);
                    return;
                }
                case OtherState_Tags.RoomJoinRules: {
                    ordinalConverter.write(11, into);
                    const inner = value.inner;
                    FfiConverterOptionalTypeJoinRule.write(inner.joinRule, into);
                    return;
                }
                case OtherState_Tags.RoomName: {
                    ordinalConverter.write(12, into);
                    const inner = value.inner;
                    FfiConverterOptionalString.write(inner.name, into);
                    return;
                }
                case OtherState_Tags.RoomPinnedEvents: {
                    ordinalConverter.write(13, into);
                    const inner = value.inner;
                    FfiConverterTypeRoomPinnedEventsChange.write(inner.change, into);
                    return;
                }
                case OtherState_Tags.RoomPowerLevels: {
                    ordinalConverter.write(14, into);
                    const inner = value.inner;
                    FfiConverterMapStringInt64.write(inner.users, into);
                    FfiConverterOptionalMapStringInt64.write(inner.previous, into);
                    return;
                }
                case OtherState_Tags.RoomServerAcl: {
                    ordinalConverter.write(15, into);
                    return;
                }
                case OtherState_Tags.RoomThirdPartyInvite: {
                    ordinalConverter.write(16, into);
                    const inner = value.inner;
                    FfiConverterOptionalString.write(inner.displayName, into);
                    return;
                }
                case OtherState_Tags.RoomTombstone: {
                    ordinalConverter.write(17, into);
                    return;
                }
                case OtherState_Tags.RoomTopic: {
                    ordinalConverter.write(18, into);
                    const inner = value.inner;
                    FfiConverterOptionalString.write(inner.topic, into);
                    return;
                }
                case OtherState_Tags.SpaceChild: {
                    ordinalConverter.write(19, into);
                    return;
                }
                case OtherState_Tags.SpaceParent: {
                    ordinalConverter.write(20, into);
                    return;
                }
                case OtherState_Tags.Custom: {
                    ordinalConverter.write(21, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.eventType, into);
                    return;
                }
                default:
                    // Throwing from here means that OtherState_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case OtherState_Tags.PolicyRuleRoom: {
                    return ordinalConverter.allocationSize(1);
                }
                case OtherState_Tags.PolicyRuleServer: {
                    return ordinalConverter.allocationSize(2);
                }
                case OtherState_Tags.PolicyRuleUser: {
                    return ordinalConverter.allocationSize(3);
                }
                case OtherState_Tags.RoomAliases: {
                    return ordinalConverter.allocationSize(4);
                }
                case OtherState_Tags.RoomAvatar: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(5);
                    size += FfiConverterOptionalString.allocationSize(inner.url);
                    return size;
                }
                case OtherState_Tags.RoomCanonicalAlias: {
                    return ordinalConverter.allocationSize(6);
                }
                case OtherState_Tags.RoomCreate: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(7);
                    size += FfiConverterOptionalBool.allocationSize(inner.federate);
                    return size;
                }
                case OtherState_Tags.RoomEncryption: {
                    return ordinalConverter.allocationSize(8);
                }
                case OtherState_Tags.RoomGuestAccess: {
                    return ordinalConverter.allocationSize(9);
                }
                case OtherState_Tags.RoomHistoryVisibility: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(10);
                    size += FfiConverterOptionalTypeHistoryVisibility.allocationSize(inner.historyVisibility);
                    return size;
                }
                case OtherState_Tags.RoomJoinRules: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(11);
                    size += FfiConverterOptionalTypeJoinRule.allocationSize(inner.joinRule);
                    return size;
                }
                case OtherState_Tags.RoomName: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(12);
                    size += FfiConverterOptionalString.allocationSize(inner.name);
                    return size;
                }
                case OtherState_Tags.RoomPinnedEvents: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(13);
                    size += FfiConverterTypeRoomPinnedEventsChange.allocationSize(inner.change);
                    return size;
                }
                case OtherState_Tags.RoomPowerLevels: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(14);
                    size += FfiConverterMapStringInt64.allocationSize(inner.users);
                    size += FfiConverterOptionalMapStringInt64.allocationSize(inner.previous);
                    return size;
                }
                case OtherState_Tags.RoomServerAcl: {
                    return ordinalConverter.allocationSize(15);
                }
                case OtherState_Tags.RoomThirdPartyInvite: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(16);
                    size += FfiConverterOptionalString.allocationSize(inner.displayName);
                    return size;
                }
                case OtherState_Tags.RoomTombstone: {
                    return ordinalConverter.allocationSize(17);
                }
                case OtherState_Tags.RoomTopic: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(18);
                    size += FfiConverterOptionalString.allocationSize(inner.topic);
                    return size;
                }
                case OtherState_Tags.SpaceChild: {
                    return ordinalConverter.allocationSize(19);
                }
                case OtherState_Tags.SpaceParent: {
                    return ordinalConverter.allocationSize(20);
                }
                case OtherState_Tags.Custom: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(21);
                    size += FfiConverterString.allocationSize(inner.eventType);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Flat error type: ParseError
export var ParseError_Tags;
(function (ParseError_Tags) {
    ParseError_Tags["EmptyHost"] = "EmptyHost";
    ParseError_Tags["IdnaError"] = "IdnaError";
    ParseError_Tags["InvalidPort"] = "InvalidPort";
    ParseError_Tags["InvalidIpv4Address"] = "InvalidIpv4Address";
    ParseError_Tags["InvalidIpv6Address"] = "InvalidIpv6Address";
    ParseError_Tags["InvalidDomainCharacter"] = "InvalidDomainCharacter";
    ParseError_Tags["RelativeUrlWithoutBase"] = "RelativeUrlWithoutBase";
    ParseError_Tags["RelativeUrlWithCannotBeABaseBase"] = "RelativeUrlWithCannotBeABaseBase";
    ParseError_Tags["SetHostOnCannotBeABaseUrl"] = "SetHostOnCannotBeABaseUrl";
    ParseError_Tags["Overflow"] = "Overflow";
    ParseError_Tags["Other"] = "Other";
})(ParseError_Tags || (ParseError_Tags = {}));
export const ParseError = (() => {
    class EmptyHost extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "ParseError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 1;
        tag = ParseError_Tags.EmptyHost;
        constructor(message) {
            super("ParseError", "EmptyHost", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 1);
        }
    }
    class IdnaError extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "ParseError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 2;
        tag = ParseError_Tags.IdnaError;
        constructor(message) {
            super("ParseError", "IdnaError", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 2);
        }
    }
    class InvalidPort extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "ParseError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 3;
        tag = ParseError_Tags.InvalidPort;
        constructor(message) {
            super("ParseError", "InvalidPort", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 3);
        }
    }
    class InvalidIpv4Address extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "ParseError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 4;
        tag = ParseError_Tags.InvalidIpv4Address;
        constructor(message) {
            super("ParseError", "InvalidIpv4Address", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 4);
        }
    }
    class InvalidIpv6Address extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "ParseError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 5;
        tag = ParseError_Tags.InvalidIpv6Address;
        constructor(message) {
            super("ParseError", "InvalidIpv6Address", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 5);
        }
    }
    class InvalidDomainCharacter extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "ParseError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 6;
        tag = ParseError_Tags.InvalidDomainCharacter;
        constructor(message) {
            super("ParseError", "InvalidDomainCharacter", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 6);
        }
    }
    class RelativeUrlWithoutBase extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "ParseError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 7;
        tag = ParseError_Tags.RelativeUrlWithoutBase;
        constructor(message) {
            super("ParseError", "RelativeUrlWithoutBase", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 7);
        }
    }
    class RelativeUrlWithCannotBeABaseBase extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "ParseError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 8;
        tag = ParseError_Tags.RelativeUrlWithCannotBeABaseBase;
        constructor(message) {
            super("ParseError", "RelativeUrlWithCannotBeABaseBase", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 8);
        }
    }
    class SetHostOnCannotBeABaseUrl extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "ParseError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 9;
        tag = ParseError_Tags.SetHostOnCannotBeABaseUrl;
        constructor(message) {
            super("ParseError", "SetHostOnCannotBeABaseUrl", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 9);
        }
    }
    class Overflow extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "ParseError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 10;
        tag = ParseError_Tags.Overflow;
        constructor(message) {
            super("ParseError", "Overflow", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 10);
        }
    }
    class Other extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "ParseError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 11;
        tag = ParseError_Tags.Other;
        constructor(message) {
            super("ParseError", "Other", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 11);
        }
    }
    // Utility function which does not rely on instanceof.
    function instanceOf(e) {
        return e[uniffiTypeNameSymbol] === "ParseError";
    }
    return {
        EmptyHost,
        IdnaError,
        InvalidPort,
        InvalidIpv4Address,
        InvalidIpv6Address,
        InvalidDomainCharacter,
        RelativeUrlWithoutBase,
        RelativeUrlWithCannotBeABaseBase,
        SetHostOnCannotBeABaseUrl,
        Overflow,
        Other,
        instanceOf,
    };
})();
const FfiConverterTypeParseError = (() => {
    const intConverter = FfiConverterInt32;
    class FfiConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (intConverter.read(from)) {
                case 1: return new ParseError.EmptyHost(FfiConverterString.read(from));
                case 2: return new ParseError.IdnaError(FfiConverterString.read(from));
                case 3: return new ParseError.InvalidPort(FfiConverterString.read(from));
                case 4: return new ParseError.InvalidIpv4Address(FfiConverterString.read(from));
                case 5: return new ParseError.InvalidIpv6Address(FfiConverterString.read(from));
                case 6: return new ParseError.InvalidDomainCharacter(FfiConverterString.read(from));
                case 7: return new ParseError.RelativeUrlWithoutBase(FfiConverterString.read(from));
                case 8: return new ParseError.RelativeUrlWithCannotBeABaseBase(FfiConverterString.read(from));
                case 9: return new ParseError.SetHostOnCannotBeABaseUrl(FfiConverterString.read(from));
                case 10: return new ParseError.Overflow(FfiConverterString.read(from));
                case 11: return new ParseError.Other(FfiConverterString.read(from));
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            const obj = value;
            const index = obj[variantOrdinalSymbol];
            intConverter.write(index, into);
        }
        allocationSize(value) {
            return intConverter.allocationSize(0);
        }
    }
    return new FfiConverter();
})();
export var PollKind;
(function (PollKind) {
    PollKind[PollKind["Disclosed"] = 0] = "Disclosed";
    PollKind[PollKind["Undisclosed"] = 1] = "Undisclosed";
})(PollKind || (PollKind = {}));
const FfiConverterTypePollKind = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return PollKind.Disclosed;
                case 2: return PollKind.Undisclosed;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case PollKind.Disclosed: return ordinalConverter.write(1, into);
                case PollKind.Undisclosed: return ordinalConverter.write(2, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Enum: PowerLevel
export var PowerLevel_Tags;
(function (PowerLevel_Tags) {
    PowerLevel_Tags["Infinite"] = "Infinite";
    PowerLevel_Tags["Value"] = "Value";
})(PowerLevel_Tags || (PowerLevel_Tags = {}));
export const PowerLevel = (() => {
    /**
     * The user is a room creator and has infinite power level.
     *
     * This power level was introduced in room version 12.
     */
    class Infinite_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "PowerLevel";
        tag = PowerLevel_Tags.Infinite;
        constructor() {
            super("PowerLevel", "Infinite");
        }
        static new() {
            return new Infinite_();
        }
        static instanceOf(obj) {
            return obj.tag === PowerLevel_Tags.Infinite;
        }
    }
    /**
     * The user has the given power level.
     */
    class Value_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "PowerLevel";
        tag = PowerLevel_Tags.Value;
        inner;
        constructor(inner) {
            super("PowerLevel", "Value");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Value_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === PowerLevel_Tags.Value;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "PowerLevel";
    }
    return Object.freeze({
        instanceOf,
        Infinite: Infinite_,
        Value: Value_
    });
})();
// FfiConverter for enum PowerLevel
const FfiConverterTypePowerLevel = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new PowerLevel.Infinite();
                case 2: return new PowerLevel.Value({ value: FfiConverterInt64.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case PowerLevel_Tags.Infinite: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case PowerLevel_Tags.Value: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterInt64.write(inner.value, into);
                    return;
                }
                default:
                    // Throwing from here means that PowerLevel_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case PowerLevel_Tags.Infinite: {
                    return ordinalConverter.allocationSize(1);
                }
                case PowerLevel_Tags.Value: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterInt64.allocationSize(inner.value);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: ProfileDetails
export var ProfileDetails_Tags;
(function (ProfileDetails_Tags) {
    ProfileDetails_Tags["Unavailable"] = "Unavailable";
    ProfileDetails_Tags["Pending"] = "Pending";
    ProfileDetails_Tags["Ready"] = "Ready";
    ProfileDetails_Tags["Error"] = "Error";
})(ProfileDetails_Tags || (ProfileDetails_Tags = {}));
export const ProfileDetails = (() => {
    class Unavailable_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ProfileDetails";
        tag = ProfileDetails_Tags.Unavailable;
        constructor() {
            super("ProfileDetails", "Unavailable");
        }
        static new() {
            return new Unavailable_();
        }
        static instanceOf(obj) {
            return obj.tag === ProfileDetails_Tags.Unavailable;
        }
    }
    class Pending_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ProfileDetails";
        tag = ProfileDetails_Tags.Pending;
        constructor() {
            super("ProfileDetails", "Pending");
        }
        static new() {
            return new Pending_();
        }
        static instanceOf(obj) {
            return obj.tag === ProfileDetails_Tags.Pending;
        }
    }
    class Ready_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ProfileDetails";
        tag = ProfileDetails_Tags.Ready;
        inner;
        constructor(inner) {
            super("ProfileDetails", "Ready");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Ready_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === ProfileDetails_Tags.Ready;
        }
    }
    class Error_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ProfileDetails";
        tag = ProfileDetails_Tags.Error;
        inner;
        constructor(inner) {
            super("ProfileDetails", "Error");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Error_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === ProfileDetails_Tags.Error;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "ProfileDetails";
    }
    return Object.freeze({
        instanceOf,
        Unavailable: Unavailable_,
        Pending: Pending_,
        Ready: Ready_,
        Error: Error_
    });
})();
// FfiConverter for enum ProfileDetails
const FfiConverterTypeProfileDetails = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new ProfileDetails.Unavailable();
                case 2: return new ProfileDetails.Pending();
                case 3: return new ProfileDetails.Ready({ displayName: FfiConverterOptionalString.read(from), displayNameAmbiguous: FfiConverterBool.read(from), avatarUrl: FfiConverterOptionalString.read(from) });
                case 4: return new ProfileDetails.Error({ message: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case ProfileDetails_Tags.Unavailable: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case ProfileDetails_Tags.Pending: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case ProfileDetails_Tags.Ready: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterOptionalString.write(inner.displayName, into);
                    FfiConverterBool.write(inner.displayNameAmbiguous, into);
                    FfiConverterOptionalString.write(inner.avatarUrl, into);
                    return;
                }
                case ProfileDetails_Tags.Error: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.message, into);
                    return;
                }
                default:
                    // Throwing from here means that ProfileDetails_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case ProfileDetails_Tags.Unavailable: {
                    return ordinalConverter.allocationSize(1);
                }
                case ProfileDetails_Tags.Pending: {
                    return ordinalConverter.allocationSize(2);
                }
                case ProfileDetails_Tags.Ready: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterOptionalString.allocationSize(inner.displayName);
                    size += FfiConverterBool.allocationSize(inner.displayNameAmbiguous);
                    size += FfiConverterOptionalString.allocationSize(inner.avatarUrl);
                    return size;
                }
                case ProfileDetails_Tags.Error: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterString.allocationSize(inner.message);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
export var PublicRoomJoinRule;
(function (PublicRoomJoinRule) {
    PublicRoomJoinRule[PublicRoomJoinRule["Public"] = 0] = "Public";
    PublicRoomJoinRule[PublicRoomJoinRule["Knock"] = 1] = "Knock";
    PublicRoomJoinRule[PublicRoomJoinRule["Restricted"] = 2] = "Restricted";
    PublicRoomJoinRule[PublicRoomJoinRule["KnockRestricted"] = 3] = "KnockRestricted";
    PublicRoomJoinRule[PublicRoomJoinRule["Invite"] = 4] = "Invite";
})(PublicRoomJoinRule || (PublicRoomJoinRule = {}));
const FfiConverterTypePublicRoomJoinRule = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return PublicRoomJoinRule.Public;
                case 2: return PublicRoomJoinRule.Knock;
                case 3: return PublicRoomJoinRule.Restricted;
                case 4: return PublicRoomJoinRule.KnockRestricted;
                case 5: return PublicRoomJoinRule.Invite;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case PublicRoomJoinRule.Public: return ordinalConverter.write(1, into);
                case PublicRoomJoinRule.Knock: return ordinalConverter.write(2, into);
                case PublicRoomJoinRule.Restricted: return ordinalConverter.write(3, into);
                case PublicRoomJoinRule.KnockRestricted: return ordinalConverter.write(4, into);
                case PublicRoomJoinRule.Invite: return ordinalConverter.write(5, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Enum: PushCondition
export var PushCondition_Tags;
(function (PushCondition_Tags) {
    PushCondition_Tags["EventMatch"] = "EventMatch";
    PushCondition_Tags["ContainsDisplayName"] = "ContainsDisplayName";
    PushCondition_Tags["RoomMemberCount"] = "RoomMemberCount";
    PushCondition_Tags["SenderNotificationPermission"] = "SenderNotificationPermission";
    PushCondition_Tags["EventPropertyIs"] = "EventPropertyIs";
    PushCondition_Tags["EventPropertyContains"] = "EventPropertyContains";
})(PushCondition_Tags || (PushCondition_Tags = {}));
export const PushCondition = (() => {
    /**
     * A glob pattern match on a field of the event.
     */
    class EventMatch_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "PushCondition";
        tag = PushCondition_Tags.EventMatch;
        inner;
        constructor(inner) {
            super("PushCondition", "EventMatch");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new EventMatch_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === PushCondition_Tags.EventMatch;
        }
    }
    /**
     * Matches unencrypted messages where `content.body` contains the owner's
     * display name in that room.
     */
    class ContainsDisplayName_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "PushCondition";
        tag = PushCondition_Tags.ContainsDisplayName;
        constructor() {
            super("PushCondition", "ContainsDisplayName");
        }
        static new() {
            return new ContainsDisplayName_();
        }
        static instanceOf(obj) {
            return obj.tag === PushCondition_Tags.ContainsDisplayName;
        }
    }
    /**
     * Matches the current number of members in the room.
     */
    class RoomMemberCount_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "PushCondition";
        tag = PushCondition_Tags.RoomMemberCount;
        inner;
        constructor(inner) {
            super("PushCondition", "RoomMemberCount");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new RoomMemberCount_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === PushCondition_Tags.RoomMemberCount;
        }
    }
    /**
     * Takes into account the current power levels in the room, ensuring the
     * sender of the event has high enough power to trigger the
     * notification.
     */
    class SenderNotificationPermission_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "PushCondition";
        tag = PushCondition_Tags.SenderNotificationPermission;
        inner;
        constructor(inner) {
            super("PushCondition", "SenderNotificationPermission");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new SenderNotificationPermission_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === PushCondition_Tags.SenderNotificationPermission;
        }
    }
    /**
     * Exact value match on a property of the event.
     */
    class EventPropertyIs_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "PushCondition";
        tag = PushCondition_Tags.EventPropertyIs;
        inner;
        constructor(inner) {
            super("PushCondition", "EventPropertyIs");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new EventPropertyIs_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === PushCondition_Tags.EventPropertyIs;
        }
    }
    /**
     * Exact value match on a value in an array property of the event.
     */
    class EventPropertyContains_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "PushCondition";
        tag = PushCondition_Tags.EventPropertyContains;
        inner;
        constructor(inner) {
            super("PushCondition", "EventPropertyContains");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new EventPropertyContains_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === PushCondition_Tags.EventPropertyContains;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "PushCondition";
    }
    return Object.freeze({
        instanceOf,
        EventMatch: EventMatch_,
        ContainsDisplayName: ContainsDisplayName_,
        RoomMemberCount: RoomMemberCount_,
        SenderNotificationPermission: SenderNotificationPermission_,
        EventPropertyIs: EventPropertyIs_,
        EventPropertyContains: EventPropertyContains_
    });
})();
// FfiConverter for enum PushCondition
const FfiConverterTypePushCondition = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new PushCondition.EventMatch({ key: FfiConverterString.read(from), pattern: FfiConverterString.read(from) });
                case 2: return new PushCondition.ContainsDisplayName();
                case 3: return new PushCondition.RoomMemberCount({ prefix: FfiConverterTypeComparisonOperator.read(from), count: FfiConverterUInt64.read(from) });
                case 4: return new PushCondition.SenderNotificationPermission({ key: FfiConverterString.read(from) });
                case 5: return new PushCondition.EventPropertyIs({ key: FfiConverterString.read(from), value: FfiConverterTypeJsonValue.read(from) });
                case 6: return new PushCondition.EventPropertyContains({ key: FfiConverterString.read(from), value: FfiConverterTypeJsonValue.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case PushCondition_Tags.EventMatch: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.key, into);
                    FfiConverterString.write(inner.pattern, into);
                    return;
                }
                case PushCondition_Tags.ContainsDisplayName: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case PushCondition_Tags.RoomMemberCount: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterTypeComparisonOperator.write(inner.prefix, into);
                    FfiConverterUInt64.write(inner.count, into);
                    return;
                }
                case PushCondition_Tags.SenderNotificationPermission: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.key, into);
                    return;
                }
                case PushCondition_Tags.EventPropertyIs: {
                    ordinalConverter.write(5, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.key, into);
                    FfiConverterTypeJsonValue.write(inner.value, into);
                    return;
                }
                case PushCondition_Tags.EventPropertyContains: {
                    ordinalConverter.write(6, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.key, into);
                    FfiConverterTypeJsonValue.write(inner.value, into);
                    return;
                }
                default:
                    // Throwing from here means that PushCondition_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case PushCondition_Tags.EventMatch: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterString.allocationSize(inner.key);
                    size += FfiConverterString.allocationSize(inner.pattern);
                    return size;
                }
                case PushCondition_Tags.ContainsDisplayName: {
                    return ordinalConverter.allocationSize(2);
                }
                case PushCondition_Tags.RoomMemberCount: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterTypeComparisonOperator.allocationSize(inner.prefix);
                    size += FfiConverterUInt64.allocationSize(inner.count);
                    return size;
                }
                case PushCondition_Tags.SenderNotificationPermission: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterString.allocationSize(inner.key);
                    return size;
                }
                case PushCondition_Tags.EventPropertyIs: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(5);
                    size += FfiConverterString.allocationSize(inner.key);
                    size += FfiConverterTypeJsonValue.allocationSize(inner.value);
                    return size;
                }
                case PushCondition_Tags.EventPropertyContains: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(6);
                    size += FfiConverterString.allocationSize(inner.key);
                    size += FfiConverterTypeJsonValue.allocationSize(inner.value);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
export var PushFormat;
(function (PushFormat) {
    PushFormat[PushFormat["EventIdOnly"] = 0] = "EventIdOnly";
})(PushFormat || (PushFormat = {}));
const FfiConverterTypePushFormat = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return PushFormat.EventIdOnly;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case PushFormat.EventIdOnly: return ordinalConverter.write(1, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Enum: PusherKind
export var PusherKind_Tags;
(function (PusherKind_Tags) {
    PusherKind_Tags["Http"] = "Http";
    PusherKind_Tags["Email"] = "Email";
})(PusherKind_Tags || (PusherKind_Tags = {}));
export const PusherKind = (() => {
    class Http_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "PusherKind";
        tag = PusherKind_Tags.Http;
        inner;
        constructor(inner) {
            super("PusherKind", "Http");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Http_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === PusherKind_Tags.Http;
        }
    }
    class Email_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "PusherKind";
        tag = PusherKind_Tags.Email;
        constructor() {
            super("PusherKind", "Email");
        }
        static new() {
            return new Email_();
        }
        static instanceOf(obj) {
            return obj.tag === PusherKind_Tags.Email;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "PusherKind";
    }
    return Object.freeze({
        instanceOf,
        Http: Http_,
        Email: Email_
    });
})();
// FfiConverter for enum PusherKind
const FfiConverterTypePusherKind = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new PusherKind.Http({ data: FfiConverterTypeHttpPusherData.read(from) });
                case 2: return new PusherKind.Email();
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case PusherKind_Tags.Http: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterTypeHttpPusherData.write(inner.data, into);
                    return;
                }
                case PusherKind_Tags.Email: {
                    ordinalConverter.write(2, into);
                    return;
                }
                default:
                    // Throwing from here means that PusherKind_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case PusherKind_Tags.Http: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterTypeHttpPusherData.allocationSize(inner.data);
                    return size;
                }
                case PusherKind_Tags.Email: {
                    return ordinalConverter.allocationSize(2);
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Flat error type: QrCodeDecodeError
export var QrCodeDecodeError_Tags;
(function (QrCodeDecodeError_Tags) {
    QrCodeDecodeError_Tags["Crypto"] = "Crypto";
})(QrCodeDecodeError_Tags || (QrCodeDecodeError_Tags = {}));
/**
 * Error type for the decoding of the [`QrCodeData`].
 */
export const QrCodeDecodeError = (() => {
    class Crypto extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "QrCodeDecodeError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 1;
        tag = QrCodeDecodeError_Tags.Crypto;
        constructor(message) {
            super("QrCodeDecodeError", "Crypto", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 1);
        }
    }
    // Utility function which does not rely on instanceof.
    function instanceOf(e) {
        return e[uniffiTypeNameSymbol] === "QrCodeDecodeError";
    }
    return {
        Crypto,
        instanceOf,
    };
})();
const FfiConverterTypeQrCodeDecodeError = (() => {
    const intConverter = FfiConverterInt32;
    class FfiConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (intConverter.read(from)) {
                case 1: return new QrCodeDecodeError.Crypto(FfiConverterString.read(from));
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            const obj = value;
            const index = obj[variantOrdinalSymbol];
            intConverter.write(index, into);
        }
        allocationSize(value) {
            return intConverter.allocationSize(0);
        }
    }
    return new FfiConverter();
})();
// Enum: QrLoginProgress
export var QrLoginProgress_Tags;
(function (QrLoginProgress_Tags) {
    QrLoginProgress_Tags["Starting"] = "Starting";
    QrLoginProgress_Tags["EstablishingSecureChannel"] = "EstablishingSecureChannel";
    QrLoginProgress_Tags["WaitingForToken"] = "WaitingForToken";
    QrLoginProgress_Tags["SyncingSecrets"] = "SyncingSecrets";
    QrLoginProgress_Tags["Done"] = "Done";
})(QrLoginProgress_Tags || (QrLoginProgress_Tags = {}));
/**
 * Enum describing the progress of logging in by scanning a QR code that was
 * generated on an existing device.
 */
export const QrLoginProgress = (() => {
    /**
     * The login process is starting.
     */
    class Starting_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "QrLoginProgress";
        tag = QrLoginProgress_Tags.Starting;
        constructor() {
            super("QrLoginProgress", "Starting");
        }
        static new() {
            return new Starting_();
        }
        static instanceOf(obj) {
            return obj.tag === QrLoginProgress_Tags.Starting;
        }
    }
    /**
     * We established a secure channel with the other device.
     */
    class EstablishingSecureChannel_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "QrLoginProgress";
        tag = QrLoginProgress_Tags.EstablishingSecureChannel;
        inner;
        constructor(inner) {
            super("QrLoginProgress", "EstablishingSecureChannel");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new EstablishingSecureChannel_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === QrLoginProgress_Tags.EstablishingSecureChannel;
        }
    }
    /**
     * We are waiting for the login and for the OAuth 2.0 authorization server
     * to give us an access token.
     */
    class WaitingForToken_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "QrLoginProgress";
        tag = QrLoginProgress_Tags.WaitingForToken;
        inner;
        constructor(inner) {
            super("QrLoginProgress", "WaitingForToken");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new WaitingForToken_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === QrLoginProgress_Tags.WaitingForToken;
        }
    }
    /**
     * We are syncing secrets.
     */
    class SyncingSecrets_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "QrLoginProgress";
        tag = QrLoginProgress_Tags.SyncingSecrets;
        constructor() {
            super("QrLoginProgress", "SyncingSecrets");
        }
        static new() {
            return new SyncingSecrets_();
        }
        static instanceOf(obj) {
            return obj.tag === QrLoginProgress_Tags.SyncingSecrets;
        }
    }
    /**
     * The login has successfully finished.
     */
    class Done_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "QrLoginProgress";
        tag = QrLoginProgress_Tags.Done;
        constructor() {
            super("QrLoginProgress", "Done");
        }
        static new() {
            return new Done_();
        }
        static instanceOf(obj) {
            return obj.tag === QrLoginProgress_Tags.Done;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "QrLoginProgress";
    }
    return Object.freeze({
        instanceOf,
        Starting: Starting_,
        EstablishingSecureChannel: EstablishingSecureChannel_,
        WaitingForToken: WaitingForToken_,
        SyncingSecrets: SyncingSecrets_,
        Done: Done_
    });
})();
// FfiConverter for enum QrLoginProgress
const FfiConverterTypeQrLoginProgress = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new QrLoginProgress.Starting();
                case 2: return new QrLoginProgress.EstablishingSecureChannel({ checkCode: FfiConverterUInt8.read(from), checkCodeString: FfiConverterString.read(from) });
                case 3: return new QrLoginProgress.WaitingForToken({ userCode: FfiConverterString.read(from) });
                case 4: return new QrLoginProgress.SyncingSecrets();
                case 5: return new QrLoginProgress.Done();
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case QrLoginProgress_Tags.Starting: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case QrLoginProgress_Tags.EstablishingSecureChannel: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterUInt8.write(inner.checkCode, into);
                    FfiConverterString.write(inner.checkCodeString, into);
                    return;
                }
                case QrLoginProgress_Tags.WaitingForToken: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.userCode, into);
                    return;
                }
                case QrLoginProgress_Tags.SyncingSecrets: {
                    ordinalConverter.write(4, into);
                    return;
                }
                case QrLoginProgress_Tags.Done: {
                    ordinalConverter.write(5, into);
                    return;
                }
                default:
                    // Throwing from here means that QrLoginProgress_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case QrLoginProgress_Tags.Starting: {
                    return ordinalConverter.allocationSize(1);
                }
                case QrLoginProgress_Tags.EstablishingSecureChannel: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterUInt8.allocationSize(inner.checkCode);
                    size += FfiConverterString.allocationSize(inner.checkCodeString);
                    return size;
                }
                case QrLoginProgress_Tags.WaitingForToken: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterString.allocationSize(inner.userCode);
                    return size;
                }
                case QrLoginProgress_Tags.SyncingSecrets: {
                    return ordinalConverter.allocationSize(4);
                }
                case QrLoginProgress_Tags.Done: {
                    return ordinalConverter.allocationSize(5);
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: QueueWedgeError
export var QueueWedgeError_Tags;
(function (QueueWedgeError_Tags) {
    QueueWedgeError_Tags["InsecureDevices"] = "InsecureDevices";
    QueueWedgeError_Tags["IdentityViolations"] = "IdentityViolations";
    QueueWedgeError_Tags["CrossVerificationRequired"] = "CrossVerificationRequired";
    QueueWedgeError_Tags["MissingMediaContent"] = "MissingMediaContent";
    QueueWedgeError_Tags["InvalidMimeType"] = "InvalidMimeType";
    QueueWedgeError_Tags["GenericApiError"] = "GenericApiError";
})(QueueWedgeError_Tags || (QueueWedgeError_Tags = {}));
/**
 * Bindings version of the sdk type replacing OwnedUserId/DeviceIds with simple
 * String.
 *
 * Represent a failed to send unrecoverable error of an event sent via the
 * send_queue. It is a serializable representation of a client error, see
 * `From` implementation for more details. These errors can not be
 * automatically retried, but yet some manual action can be taken before retry
 * sending. If not the only solution is to delete the local event.
 */
export const QueueWedgeError = (() => {
    /**
     * This error occurs when there are some insecure devices in the room, and
     * the current encryption setting prohibit sharing with them.
     */
    class InsecureDevices_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "QueueWedgeError";
        tag = QueueWedgeError_Tags.InsecureDevices;
        inner;
        constructor(inner) {
            super("QueueWedgeError", "InsecureDevices");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new InsecureDevices_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === QueueWedgeError_Tags.InsecureDevices;
        }
    }
    /**
     * This error occurs when a previously verified user is not anymore, and
     * the current encryption setting prohibit sharing when it happens.
     */
    class IdentityViolations_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "QueueWedgeError";
        tag = QueueWedgeError_Tags.IdentityViolations;
        inner;
        constructor(inner) {
            super("QueueWedgeError", "IdentityViolations");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new IdentityViolations_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === QueueWedgeError_Tags.IdentityViolations;
        }
    }
    /**
     * It is required to set up cross-signing and properly erify the current
     * session before sending.
     */
    class CrossVerificationRequired_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "QueueWedgeError";
        tag = QueueWedgeError_Tags.CrossVerificationRequired;
        constructor() {
            super("QueueWedgeError", "CrossVerificationRequired");
        }
        static new() {
            return new CrossVerificationRequired_();
        }
        static instanceOf(obj) {
            return obj.tag === QueueWedgeError_Tags.CrossVerificationRequired;
        }
    }
    /**
     * Some media content to be sent has disappeared from the cache.
     */
    class MissingMediaContent_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "QueueWedgeError";
        tag = QueueWedgeError_Tags.MissingMediaContent;
        constructor() {
            super("QueueWedgeError", "MissingMediaContent");
        }
        static new() {
            return new MissingMediaContent_();
        }
        static instanceOf(obj) {
            return obj.tag === QueueWedgeError_Tags.MissingMediaContent;
        }
    }
    /**
     * Some mime type couldn't be parsed.
     */
    class InvalidMimeType_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "QueueWedgeError";
        tag = QueueWedgeError_Tags.InvalidMimeType;
        inner;
        constructor(inner) {
            super("QueueWedgeError", "InvalidMimeType");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new InvalidMimeType_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === QueueWedgeError_Tags.InvalidMimeType;
        }
    }
    /**
     * Other errors.
     */
    class GenericApiError_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "QueueWedgeError";
        tag = QueueWedgeError_Tags.GenericApiError;
        inner;
        constructor(inner) {
            super("QueueWedgeError", "GenericApiError");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new GenericApiError_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === QueueWedgeError_Tags.GenericApiError;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "QueueWedgeError";
    }
    return Object.freeze({
        instanceOf,
        InsecureDevices: InsecureDevices_,
        IdentityViolations: IdentityViolations_,
        CrossVerificationRequired: CrossVerificationRequired_,
        MissingMediaContent: MissingMediaContent_,
        InvalidMimeType: InvalidMimeType_,
        GenericApiError: GenericApiError_
    });
})();
// FfiConverter for enum QueueWedgeError
const FfiConverterTypeQueueWedgeError = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new QueueWedgeError.InsecureDevices({ userDeviceMap: FfiConverterMapStringArrayString.read(from) });
                case 2: return new QueueWedgeError.IdentityViolations({ users: FfiConverterArrayString.read(from) });
                case 3: return new QueueWedgeError.CrossVerificationRequired();
                case 4: return new QueueWedgeError.MissingMediaContent();
                case 5: return new QueueWedgeError.InvalidMimeType({ mimeType: FfiConverterString.read(from) });
                case 6: return new QueueWedgeError.GenericApiError({ msg: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case QueueWedgeError_Tags.InsecureDevices: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterMapStringArrayString.write(inner.userDeviceMap, into);
                    return;
                }
                case QueueWedgeError_Tags.IdentityViolations: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterArrayString.write(inner.users, into);
                    return;
                }
                case QueueWedgeError_Tags.CrossVerificationRequired: {
                    ordinalConverter.write(3, into);
                    return;
                }
                case QueueWedgeError_Tags.MissingMediaContent: {
                    ordinalConverter.write(4, into);
                    return;
                }
                case QueueWedgeError_Tags.InvalidMimeType: {
                    ordinalConverter.write(5, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.mimeType, into);
                    return;
                }
                case QueueWedgeError_Tags.GenericApiError: {
                    ordinalConverter.write(6, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.msg, into);
                    return;
                }
                default:
                    // Throwing from here means that QueueWedgeError_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case QueueWedgeError_Tags.InsecureDevices: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterMapStringArrayString.allocationSize(inner.userDeviceMap);
                    return size;
                }
                case QueueWedgeError_Tags.IdentityViolations: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterArrayString.allocationSize(inner.users);
                    return size;
                }
                case QueueWedgeError_Tags.CrossVerificationRequired: {
                    return ordinalConverter.allocationSize(3);
                }
                case QueueWedgeError_Tags.MissingMediaContent: {
                    return ordinalConverter.allocationSize(4);
                }
                case QueueWedgeError_Tags.InvalidMimeType: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(5);
                    size += FfiConverterString.allocationSize(inner.mimeType);
                    return size;
                }
                case QueueWedgeError_Tags.GenericApiError: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(6);
                    size += FfiConverterString.allocationSize(inner.msg);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
/**
 * A [`TimelineItem`](super::TimelineItem) that doesn't correspond to an event.
 */
export var ReceiptType;
(function (ReceiptType) {
    ReceiptType[ReceiptType["Read"] = 0] = "Read";
    ReceiptType[ReceiptType["ReadPrivate"] = 1] = "ReadPrivate";
    ReceiptType[ReceiptType["FullyRead"] = 2] = "FullyRead";
})(ReceiptType || (ReceiptType = {}));
const FfiConverterTypeReceiptType = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return ReceiptType.Read;
                case 2: return ReceiptType.ReadPrivate;
                case 3: return ReceiptType.FullyRead;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case ReceiptType.Read: return ordinalConverter.write(1, into);
                case ReceiptType.ReadPrivate: return ordinalConverter.write(2, into);
                case ReceiptType.FullyRead: return ordinalConverter.write(3, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Error type: RecoveryError
// Enum: RecoveryError
export var RecoveryError_Tags;
(function (RecoveryError_Tags) {
    RecoveryError_Tags["BackupExistsOnServer"] = "BackupExistsOnServer";
    RecoveryError_Tags["Client"] = "Client";
    RecoveryError_Tags["SecretStorage"] = "SecretStorage";
    RecoveryError_Tags["Import"] = "Import";
})(RecoveryError_Tags || (RecoveryError_Tags = {}));
export const RecoveryError = (() => {
    /**
     * A backup already exists on the homeserver, the recovery subsystem does
     * not allow backups to be overwritten, disable recovery first.
     */
    class BackupExistsOnServer_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RecoveryError";
        tag = RecoveryError_Tags.BackupExistsOnServer;
        constructor() {
            super("RecoveryError", "BackupExistsOnServer");
        }
        static new() {
            return new BackupExistsOnServer_();
        }
        static instanceOf(obj) {
            return obj.tag === RecoveryError_Tags.BackupExistsOnServer;
        }
        static hasInner(obj) {
            return false;
        }
    }
    /**
     * A typical SDK error.
     */
    class Client_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RecoveryError";
        tag = RecoveryError_Tags.Client;
        inner;
        constructor(inner) {
            super("RecoveryError", "Client");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Client_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RecoveryError_Tags.Client;
        }
        static hasInner(obj) {
            return Client_.instanceOf(obj);
        }
        static getInner(obj) {
            return obj.inner;
        }
    }
    /**
     * Error in the secret storage subsystem, except for when importing a
     * secret.
     */
    class SecretStorage_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RecoveryError";
        tag = RecoveryError_Tags.SecretStorage;
        inner;
        constructor(inner) {
            super("RecoveryError", "SecretStorage");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new SecretStorage_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RecoveryError_Tags.SecretStorage;
        }
        static hasInner(obj) {
            return SecretStorage_.instanceOf(obj);
        }
        static getInner(obj) {
            return obj.inner;
        }
    }
    /**
     * Error when importing a secret from secret storage.
     */
    class Import_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RecoveryError";
        tag = RecoveryError_Tags.Import;
        inner;
        constructor(inner) {
            super("RecoveryError", "Import");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Import_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RecoveryError_Tags.Import;
        }
        static hasInner(obj) {
            return Import_.instanceOf(obj);
        }
        static getInner(obj) {
            return obj.inner;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "RecoveryError";
    }
    return Object.freeze({
        instanceOf,
        BackupExistsOnServer: BackupExistsOnServer_,
        Client: Client_,
        SecretStorage: SecretStorage_,
        Import: Import_
    });
})();
// FfiConverter for enum RecoveryError
const FfiConverterTypeRecoveryError = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new RecoveryError.BackupExistsOnServer();
                case 2: return new RecoveryError.Client({ source: FfiConverterTypeClientError.read(from) });
                case 3: return new RecoveryError.SecretStorage({ errorMessage: FfiConverterString.read(from) });
                case 4: return new RecoveryError.Import({ errorMessage: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case RecoveryError_Tags.BackupExistsOnServer: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case RecoveryError_Tags.Client: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterTypeClientError.write(inner.source, into);
                    return;
                }
                case RecoveryError_Tags.SecretStorage: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.errorMessage, into);
                    return;
                }
                case RecoveryError_Tags.Import: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.errorMessage, into);
                    return;
                }
                default:
                    // Throwing from here means that RecoveryError_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case RecoveryError_Tags.BackupExistsOnServer: {
                    return ordinalConverter.allocationSize(1);
                }
                case RecoveryError_Tags.Client: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterTypeClientError.allocationSize(inner.source);
                    return size;
                }
                case RecoveryError_Tags.SecretStorage: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterString.allocationSize(inner.errorMessage);
                    return size;
                }
                case RecoveryError_Tags.Import: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterString.allocationSize(inner.errorMessage);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
export var RecoveryState;
(function (RecoveryState) {
    RecoveryState[RecoveryState["Unknown"] = 0] = "Unknown";
    RecoveryState[RecoveryState["Enabled"] = 1] = "Enabled";
    RecoveryState[RecoveryState["Disabled"] = 2] = "Disabled";
    RecoveryState[RecoveryState["Incomplete"] = 3] = "Incomplete";
})(RecoveryState || (RecoveryState = {}));
const FfiConverterTypeRecoveryState = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return RecoveryState.Unknown;
                case 2: return RecoveryState.Enabled;
                case 3: return RecoveryState.Disabled;
                case 4: return RecoveryState.Incomplete;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case RecoveryState.Unknown: return ordinalConverter.write(1, into);
                case RecoveryState.Enabled: return ordinalConverter.write(2, into);
                case RecoveryState.Disabled: return ordinalConverter.write(3, into);
                case RecoveryState.Incomplete: return ordinalConverter.write(4, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Enum: RoomAccountDataEvent
export var RoomAccountDataEvent_Tags;
(function (RoomAccountDataEvent_Tags) {
    RoomAccountDataEvent_Tags["FullyReadEvent"] = "FullyReadEvent";
    RoomAccountDataEvent_Tags["MarkedUnread"] = "MarkedUnread";
    RoomAccountDataEvent_Tags["Tag"] = "Tag";
    RoomAccountDataEvent_Tags["UnstableMarkedUnread"] = "UnstableMarkedUnread";
})(RoomAccountDataEvent_Tags || (RoomAccountDataEvent_Tags = {}));
/**
 * Room account data events.
 */
export const RoomAccountDataEvent = (() => {
    /**
     * m.fully_read
     */
    class FullyReadEvent_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomAccountDataEvent";
        tag = RoomAccountDataEvent_Tags.FullyReadEvent;
        inner;
        constructor(inner) {
            super("RoomAccountDataEvent", "FullyReadEvent");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new FullyReadEvent_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomAccountDataEvent_Tags.FullyReadEvent;
        }
    }
    /**
     * m.marked_unread
     */
    class MarkedUnread_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomAccountDataEvent";
        tag = RoomAccountDataEvent_Tags.MarkedUnread;
        inner;
        constructor(inner) {
            super("RoomAccountDataEvent", "MarkedUnread");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new MarkedUnread_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomAccountDataEvent_Tags.MarkedUnread;
        }
    }
    /**
     * m.tag
     */
    class Tag_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomAccountDataEvent";
        tag = RoomAccountDataEvent_Tags.Tag;
        inner;
        constructor(inner) {
            super("RoomAccountDataEvent", "Tag");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Tag_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomAccountDataEvent_Tags.Tag;
        }
    }
    /**
     * com.famedly.marked_unread
     */
    class UnstableMarkedUnread_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomAccountDataEvent";
        tag = RoomAccountDataEvent_Tags.UnstableMarkedUnread;
        inner;
        constructor(inner) {
            super("RoomAccountDataEvent", "UnstableMarkedUnread");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new UnstableMarkedUnread_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomAccountDataEvent_Tags.UnstableMarkedUnread;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "RoomAccountDataEvent";
    }
    return Object.freeze({
        instanceOf,
        FullyReadEvent: FullyReadEvent_,
        MarkedUnread: MarkedUnread_,
        Tag: Tag_,
        UnstableMarkedUnread: UnstableMarkedUnread_
    });
})();
// FfiConverter for enum RoomAccountDataEvent
const FfiConverterTypeRoomAccountDataEvent = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new RoomAccountDataEvent.FullyReadEvent({ eventId: FfiConverterString.read(from) });
                case 2: return new RoomAccountDataEvent.MarkedUnread({ unread: FfiConverterBool.read(from) });
                case 3: return new RoomAccountDataEvent.Tag({ tags: FfiConverterMapTypeTagNameTypeTagInfo.read(from) });
                case 4: return new RoomAccountDataEvent.UnstableMarkedUnread({ unread: FfiConverterBool.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case RoomAccountDataEvent_Tags.FullyReadEvent: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.eventId, into);
                    return;
                }
                case RoomAccountDataEvent_Tags.MarkedUnread: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterBool.write(inner.unread, into);
                    return;
                }
                case RoomAccountDataEvent_Tags.Tag: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterMapTypeTagNameTypeTagInfo.write(inner.tags, into);
                    return;
                }
                case RoomAccountDataEvent_Tags.UnstableMarkedUnread: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterBool.write(inner.unread, into);
                    return;
                }
                default:
                    // Throwing from here means that RoomAccountDataEvent_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case RoomAccountDataEvent_Tags.FullyReadEvent: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterString.allocationSize(inner.eventId);
                    return size;
                }
                case RoomAccountDataEvent_Tags.MarkedUnread: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterBool.allocationSize(inner.unread);
                    return size;
                }
                case RoomAccountDataEvent_Tags.Tag: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterMapTypeTagNameTypeTagInfo.allocationSize(inner.tags);
                    return size;
                }
                case RoomAccountDataEvent_Tags.UnstableMarkedUnread: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterBool.allocationSize(inner.unread);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
/**
 * Types of room account data events.
 */
export var RoomAccountDataEventType;
(function (RoomAccountDataEventType) {
    /**
     * m.fully_read
     */
    RoomAccountDataEventType[RoomAccountDataEventType["FullyRead"] = 0] = "FullyRead";
    /**
     * m.marked_unread
     */
    RoomAccountDataEventType[RoomAccountDataEventType["MarkedUnread"] = 1] = "MarkedUnread";
    /**
     * m.tag
     */
    RoomAccountDataEventType[RoomAccountDataEventType["Tag"] = 2] = "Tag";
    /**
     * com.famedly.marked_unread
     */
    RoomAccountDataEventType[RoomAccountDataEventType["UnstableMarkedUnread"] = 3] = "UnstableMarkedUnread";
})(RoomAccountDataEventType || (RoomAccountDataEventType = {}));
const FfiConverterTypeRoomAccountDataEventType = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return RoomAccountDataEventType.FullyRead;
                case 2: return RoomAccountDataEventType.MarkedUnread;
                case 3: return RoomAccountDataEventType.Tag;
                case 4: return RoomAccountDataEventType.UnstableMarkedUnread;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case RoomAccountDataEventType.FullyRead: return ordinalConverter.write(1, into);
                case RoomAccountDataEventType.MarkedUnread: return ordinalConverter.write(2, into);
                case RoomAccountDataEventType.Tag: return ordinalConverter.write(3, into);
                case RoomAccountDataEventType.UnstableMarkedUnread: return ordinalConverter.write(4, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Enum: RoomDirectorySearchEntryUpdate
export var RoomDirectorySearchEntryUpdate_Tags;
(function (RoomDirectorySearchEntryUpdate_Tags) {
    RoomDirectorySearchEntryUpdate_Tags["Append"] = "Append";
    RoomDirectorySearchEntryUpdate_Tags["Clear"] = "Clear";
    RoomDirectorySearchEntryUpdate_Tags["PushFront"] = "PushFront";
    RoomDirectorySearchEntryUpdate_Tags["PushBack"] = "PushBack";
    RoomDirectorySearchEntryUpdate_Tags["PopFront"] = "PopFront";
    RoomDirectorySearchEntryUpdate_Tags["PopBack"] = "PopBack";
    RoomDirectorySearchEntryUpdate_Tags["Insert"] = "Insert";
    RoomDirectorySearchEntryUpdate_Tags["Set"] = "Set";
    RoomDirectorySearchEntryUpdate_Tags["Remove"] = "Remove";
    RoomDirectorySearchEntryUpdate_Tags["Truncate"] = "Truncate";
    RoomDirectorySearchEntryUpdate_Tags["Reset"] = "Reset";
})(RoomDirectorySearchEntryUpdate_Tags || (RoomDirectorySearchEntryUpdate_Tags = {}));
export const RoomDirectorySearchEntryUpdate = (() => {
    class Append_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomDirectorySearchEntryUpdate";
        tag = RoomDirectorySearchEntryUpdate_Tags.Append;
        inner;
        constructor(inner) {
            super("RoomDirectorySearchEntryUpdate", "Append");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Append_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomDirectorySearchEntryUpdate_Tags.Append;
        }
    }
    class Clear_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomDirectorySearchEntryUpdate";
        tag = RoomDirectorySearchEntryUpdate_Tags.Clear;
        constructor() {
            super("RoomDirectorySearchEntryUpdate", "Clear");
        }
        static new() {
            return new Clear_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomDirectorySearchEntryUpdate_Tags.Clear;
        }
    }
    class PushFront_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomDirectorySearchEntryUpdate";
        tag = RoomDirectorySearchEntryUpdate_Tags.PushFront;
        inner;
        constructor(inner) {
            super("RoomDirectorySearchEntryUpdate", "PushFront");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new PushFront_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomDirectorySearchEntryUpdate_Tags.PushFront;
        }
    }
    class PushBack_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomDirectorySearchEntryUpdate";
        tag = RoomDirectorySearchEntryUpdate_Tags.PushBack;
        inner;
        constructor(inner) {
            super("RoomDirectorySearchEntryUpdate", "PushBack");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new PushBack_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomDirectorySearchEntryUpdate_Tags.PushBack;
        }
    }
    class PopFront_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomDirectorySearchEntryUpdate";
        tag = RoomDirectorySearchEntryUpdate_Tags.PopFront;
        constructor() {
            super("RoomDirectorySearchEntryUpdate", "PopFront");
        }
        static new() {
            return new PopFront_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomDirectorySearchEntryUpdate_Tags.PopFront;
        }
    }
    class PopBack_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomDirectorySearchEntryUpdate";
        tag = RoomDirectorySearchEntryUpdate_Tags.PopBack;
        constructor() {
            super("RoomDirectorySearchEntryUpdate", "PopBack");
        }
        static new() {
            return new PopBack_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomDirectorySearchEntryUpdate_Tags.PopBack;
        }
    }
    class Insert_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomDirectorySearchEntryUpdate";
        tag = RoomDirectorySearchEntryUpdate_Tags.Insert;
        inner;
        constructor(inner) {
            super("RoomDirectorySearchEntryUpdate", "Insert");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Insert_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomDirectorySearchEntryUpdate_Tags.Insert;
        }
    }
    class Set_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomDirectorySearchEntryUpdate";
        tag = RoomDirectorySearchEntryUpdate_Tags.Set;
        inner;
        constructor(inner) {
            super("RoomDirectorySearchEntryUpdate", "Set");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Set_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomDirectorySearchEntryUpdate_Tags.Set;
        }
    }
    class Remove_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomDirectorySearchEntryUpdate";
        tag = RoomDirectorySearchEntryUpdate_Tags.Remove;
        inner;
        constructor(inner) {
            super("RoomDirectorySearchEntryUpdate", "Remove");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Remove_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomDirectorySearchEntryUpdate_Tags.Remove;
        }
    }
    class Truncate_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomDirectorySearchEntryUpdate";
        tag = RoomDirectorySearchEntryUpdate_Tags.Truncate;
        inner;
        constructor(inner) {
            super("RoomDirectorySearchEntryUpdate", "Truncate");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Truncate_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomDirectorySearchEntryUpdate_Tags.Truncate;
        }
    }
    class Reset_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomDirectorySearchEntryUpdate";
        tag = RoomDirectorySearchEntryUpdate_Tags.Reset;
        inner;
        constructor(inner) {
            super("RoomDirectorySearchEntryUpdate", "Reset");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Reset_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomDirectorySearchEntryUpdate_Tags.Reset;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "RoomDirectorySearchEntryUpdate";
    }
    return Object.freeze({
        instanceOf,
        Append: Append_,
        Clear: Clear_,
        PushFront: PushFront_,
        PushBack: PushBack_,
        PopFront: PopFront_,
        PopBack: PopBack_,
        Insert: Insert_,
        Set: Set_,
        Remove: Remove_,
        Truncate: Truncate_,
        Reset: Reset_
    });
})();
// FfiConverter for enum RoomDirectorySearchEntryUpdate
const FfiConverterTypeRoomDirectorySearchEntryUpdate = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new RoomDirectorySearchEntryUpdate.Append({ values: FfiConverterArrayTypeRoomDescription.read(from) });
                case 2: return new RoomDirectorySearchEntryUpdate.Clear();
                case 3: return new RoomDirectorySearchEntryUpdate.PushFront({ value: FfiConverterTypeRoomDescription.read(from) });
                case 4: return new RoomDirectorySearchEntryUpdate.PushBack({ value: FfiConverterTypeRoomDescription.read(from) });
                case 5: return new RoomDirectorySearchEntryUpdate.PopFront();
                case 6: return new RoomDirectorySearchEntryUpdate.PopBack();
                case 7: return new RoomDirectorySearchEntryUpdate.Insert({ index: FfiConverterUInt32.read(from), value: FfiConverterTypeRoomDescription.read(from) });
                case 8: return new RoomDirectorySearchEntryUpdate.Set({ index: FfiConverterUInt32.read(from), value: FfiConverterTypeRoomDescription.read(from) });
                case 9: return new RoomDirectorySearchEntryUpdate.Remove({ index: FfiConverterUInt32.read(from) });
                case 10: return new RoomDirectorySearchEntryUpdate.Truncate({ length: FfiConverterUInt32.read(from) });
                case 11: return new RoomDirectorySearchEntryUpdate.Reset({ values: FfiConverterArrayTypeRoomDescription.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case RoomDirectorySearchEntryUpdate_Tags.Append: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterArrayTypeRoomDescription.write(inner.values, into);
                    return;
                }
                case RoomDirectorySearchEntryUpdate_Tags.Clear: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case RoomDirectorySearchEntryUpdate_Tags.PushFront: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterTypeRoomDescription.write(inner.value, into);
                    return;
                }
                case RoomDirectorySearchEntryUpdate_Tags.PushBack: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterTypeRoomDescription.write(inner.value, into);
                    return;
                }
                case RoomDirectorySearchEntryUpdate_Tags.PopFront: {
                    ordinalConverter.write(5, into);
                    return;
                }
                case RoomDirectorySearchEntryUpdate_Tags.PopBack: {
                    ordinalConverter.write(6, into);
                    return;
                }
                case RoomDirectorySearchEntryUpdate_Tags.Insert: {
                    ordinalConverter.write(7, into);
                    const inner = value.inner;
                    FfiConverterUInt32.write(inner.index, into);
                    FfiConverterTypeRoomDescription.write(inner.value, into);
                    return;
                }
                case RoomDirectorySearchEntryUpdate_Tags.Set: {
                    ordinalConverter.write(8, into);
                    const inner = value.inner;
                    FfiConverterUInt32.write(inner.index, into);
                    FfiConverterTypeRoomDescription.write(inner.value, into);
                    return;
                }
                case RoomDirectorySearchEntryUpdate_Tags.Remove: {
                    ordinalConverter.write(9, into);
                    const inner = value.inner;
                    FfiConverterUInt32.write(inner.index, into);
                    return;
                }
                case RoomDirectorySearchEntryUpdate_Tags.Truncate: {
                    ordinalConverter.write(10, into);
                    const inner = value.inner;
                    FfiConverterUInt32.write(inner.length, into);
                    return;
                }
                case RoomDirectorySearchEntryUpdate_Tags.Reset: {
                    ordinalConverter.write(11, into);
                    const inner = value.inner;
                    FfiConverterArrayTypeRoomDescription.write(inner.values, into);
                    return;
                }
                default:
                    // Throwing from here means that RoomDirectorySearchEntryUpdate_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case RoomDirectorySearchEntryUpdate_Tags.Append: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterArrayTypeRoomDescription.allocationSize(inner.values);
                    return size;
                }
                case RoomDirectorySearchEntryUpdate_Tags.Clear: {
                    return ordinalConverter.allocationSize(2);
                }
                case RoomDirectorySearchEntryUpdate_Tags.PushFront: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterTypeRoomDescription.allocationSize(inner.value);
                    return size;
                }
                case RoomDirectorySearchEntryUpdate_Tags.PushBack: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterTypeRoomDescription.allocationSize(inner.value);
                    return size;
                }
                case RoomDirectorySearchEntryUpdate_Tags.PopFront: {
                    return ordinalConverter.allocationSize(5);
                }
                case RoomDirectorySearchEntryUpdate_Tags.PopBack: {
                    return ordinalConverter.allocationSize(6);
                }
                case RoomDirectorySearchEntryUpdate_Tags.Insert: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(7);
                    size += FfiConverterUInt32.allocationSize(inner.index);
                    size += FfiConverterTypeRoomDescription.allocationSize(inner.value);
                    return size;
                }
                case RoomDirectorySearchEntryUpdate_Tags.Set: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(8);
                    size += FfiConverterUInt32.allocationSize(inner.index);
                    size += FfiConverterTypeRoomDescription.allocationSize(inner.value);
                    return size;
                }
                case RoomDirectorySearchEntryUpdate_Tags.Remove: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(9);
                    size += FfiConverterUInt32.allocationSize(inner.index);
                    return size;
                }
                case RoomDirectorySearchEntryUpdate_Tags.Truncate: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(10);
                    size += FfiConverterUInt32.allocationSize(inner.length);
                    return size;
                }
                case RoomDirectorySearchEntryUpdate_Tags.Reset: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(11);
                    size += FfiConverterArrayTypeRoomDescription.allocationSize(inner.values);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Flat error type: RoomError
export var RoomError_Tags;
(function (RoomError_Tags) {
    RoomError_Tags["InvalidAttachmentData"] = "InvalidAttachmentData";
    RoomError_Tags["InvalidAttachmentMimeType"] = "InvalidAttachmentMimeType";
    RoomError_Tags["InvalidMediaInfo"] = "InvalidMediaInfo";
    RoomError_Tags["TimelineUnavailable"] = "TimelineUnavailable";
    RoomError_Tags["InvalidThumbnailData"] = "InvalidThumbnailData";
    RoomError_Tags["InvalidRepliedToEventId"] = "InvalidRepliedToEventId";
    RoomError_Tags["FailedSendingAttachment"] = "FailedSendingAttachment";
})(RoomError_Tags || (RoomError_Tags = {}));
export const RoomError = (() => {
    class InvalidAttachmentData extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "RoomError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 1;
        tag = RoomError_Tags.InvalidAttachmentData;
        constructor(message) {
            super("RoomError", "InvalidAttachmentData", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 1);
        }
    }
    class InvalidAttachmentMimeType extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "RoomError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 2;
        tag = RoomError_Tags.InvalidAttachmentMimeType;
        constructor(message) {
            super("RoomError", "InvalidAttachmentMimeType", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 2);
        }
    }
    class InvalidMediaInfo extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "RoomError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 3;
        tag = RoomError_Tags.InvalidMediaInfo;
        constructor(message) {
            super("RoomError", "InvalidMediaInfo", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 3);
        }
    }
    class TimelineUnavailable extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "RoomError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 4;
        tag = RoomError_Tags.TimelineUnavailable;
        constructor(message) {
            super("RoomError", "TimelineUnavailable", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 4);
        }
    }
    class InvalidThumbnailData extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "RoomError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 5;
        tag = RoomError_Tags.InvalidThumbnailData;
        constructor(message) {
            super("RoomError", "InvalidThumbnailData", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 5);
        }
    }
    class InvalidRepliedToEventId extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "RoomError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 6;
        tag = RoomError_Tags.InvalidRepliedToEventId;
        constructor(message) {
            super("RoomError", "InvalidRepliedToEventId", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 6);
        }
    }
    class FailedSendingAttachment extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "RoomError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 7;
        tag = RoomError_Tags.FailedSendingAttachment;
        constructor(message) {
            super("RoomError", "FailedSendingAttachment", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 7);
        }
    }
    // Utility function which does not rely on instanceof.
    function instanceOf(e) {
        return e[uniffiTypeNameSymbol] === "RoomError";
    }
    return {
        InvalidAttachmentData,
        InvalidAttachmentMimeType,
        InvalidMediaInfo,
        TimelineUnavailable,
        InvalidThumbnailData,
        InvalidRepliedToEventId,
        FailedSendingAttachment,
        instanceOf,
    };
})();
const FfiConverterTypeRoomError = (() => {
    const intConverter = FfiConverterInt32;
    class FfiConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (intConverter.read(from)) {
                case 1: return new RoomError.InvalidAttachmentData(FfiConverterString.read(from));
                case 2: return new RoomError.InvalidAttachmentMimeType(FfiConverterString.read(from));
                case 3: return new RoomError.InvalidMediaInfo(FfiConverterString.read(from));
                case 4: return new RoomError.TimelineUnavailable(FfiConverterString.read(from));
                case 5: return new RoomError.InvalidThumbnailData(FfiConverterString.read(from));
                case 6: return new RoomError.InvalidRepliedToEventId(FfiConverterString.read(from));
                case 7: return new RoomError.FailedSendingAttachment(FfiConverterString.read(from));
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            const obj = value;
            const index = obj[variantOrdinalSymbol];
            intConverter.write(index, into);
        }
        allocationSize(value) {
            return intConverter.allocationSize(0);
        }
    }
    return new FfiConverter();
})();
// Enum: RoomHistoryVisibility
export var RoomHistoryVisibility_Tags;
(function (RoomHistoryVisibility_Tags) {
    RoomHistoryVisibility_Tags["Invited"] = "Invited";
    RoomHistoryVisibility_Tags["Joined"] = "Joined";
    RoomHistoryVisibility_Tags["Shared"] = "Shared";
    RoomHistoryVisibility_Tags["WorldReadable"] = "WorldReadable";
    RoomHistoryVisibility_Tags["Custom"] = "Custom";
})(RoomHistoryVisibility_Tags || (RoomHistoryVisibility_Tags = {}));
export const RoomHistoryVisibility = (() => {
    /**
     * Previous events are accessible to newly joined members from the point
     * they were invited onwards.
     *
     * Events stop being accessible when the member's state changes to
     * something other than *invite* or *join*.
     */
    class Invited_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomHistoryVisibility";
        tag = RoomHistoryVisibility_Tags.Invited;
        constructor() {
            super("RoomHistoryVisibility", "Invited");
        }
        static new() {
            return new Invited_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomHistoryVisibility_Tags.Invited;
        }
    }
    /**
     * Previous events are accessible to newly joined members from the point
     * they joined the room onwards.
     * Events stop being accessible when the member's state changes to
     * something other than *join*.
     */
    class Joined_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomHistoryVisibility";
        tag = RoomHistoryVisibility_Tags.Joined;
        constructor() {
            super("RoomHistoryVisibility", "Joined");
        }
        static new() {
            return new Joined_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomHistoryVisibility_Tags.Joined;
        }
    }
    /**
     * Previous events are always accessible to newly joined members.
     *
     * All events in the room are accessible, even those sent when the member
     * was not a part of the room.
     */
    class Shared_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomHistoryVisibility";
        tag = RoomHistoryVisibility_Tags.Shared;
        constructor() {
            super("RoomHistoryVisibility", "Shared");
        }
        static new() {
            return new Shared_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomHistoryVisibility_Tags.Shared;
        }
    }
    /**
     * All events while this is the `HistoryVisibility` value may be shared by
     * any participating homeserver with anyone, regardless of whether they
     * have ever joined the room.
     */
    class WorldReadable_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomHistoryVisibility";
        tag = RoomHistoryVisibility_Tags.WorldReadable;
        constructor() {
            super("RoomHistoryVisibility", "WorldReadable");
        }
        static new() {
            return new WorldReadable_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomHistoryVisibility_Tags.WorldReadable;
        }
    }
    /**
     * A custom visibility value.
     */
    class Custom_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomHistoryVisibility";
        tag = RoomHistoryVisibility_Tags.Custom;
        inner;
        constructor(inner) {
            super("RoomHistoryVisibility", "Custom");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Custom_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomHistoryVisibility_Tags.Custom;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "RoomHistoryVisibility";
    }
    return Object.freeze({
        instanceOf,
        Invited: Invited_,
        Joined: Joined_,
        Shared: Shared_,
        WorldReadable: WorldReadable_,
        Custom: Custom_
    });
})();
// FfiConverter for enum RoomHistoryVisibility
const FfiConverterTypeRoomHistoryVisibility = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new RoomHistoryVisibility.Invited();
                case 2: return new RoomHistoryVisibility.Joined();
                case 3: return new RoomHistoryVisibility.Shared();
                case 4: return new RoomHistoryVisibility.WorldReadable();
                case 5: return new RoomHistoryVisibility.Custom({ value: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case RoomHistoryVisibility_Tags.Invited: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case RoomHistoryVisibility_Tags.Joined: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case RoomHistoryVisibility_Tags.Shared: {
                    ordinalConverter.write(3, into);
                    return;
                }
                case RoomHistoryVisibility_Tags.WorldReadable: {
                    ordinalConverter.write(4, into);
                    return;
                }
                case RoomHistoryVisibility_Tags.Custom: {
                    ordinalConverter.write(5, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.value, into);
                    return;
                }
                default:
                    // Throwing from here means that RoomHistoryVisibility_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case RoomHistoryVisibility_Tags.Invited: {
                    return ordinalConverter.allocationSize(1);
                }
                case RoomHistoryVisibility_Tags.Joined: {
                    return ordinalConverter.allocationSize(2);
                }
                case RoomHistoryVisibility_Tags.Shared: {
                    return ordinalConverter.allocationSize(3);
                }
                case RoomHistoryVisibility_Tags.WorldReadable: {
                    return ordinalConverter.allocationSize(4);
                }
                case RoomHistoryVisibility_Tags.Custom: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(5);
                    size += FfiConverterString.allocationSize(inner.value);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: RoomListEntriesDynamicFilterKind
export var RoomListEntriesDynamicFilterKind_Tags;
(function (RoomListEntriesDynamicFilterKind_Tags) {
    RoomListEntriesDynamicFilterKind_Tags["All"] = "All";
    RoomListEntriesDynamicFilterKind_Tags["Any"] = "Any";
    RoomListEntriesDynamicFilterKind_Tags["NonSpace"] = "NonSpace";
    RoomListEntriesDynamicFilterKind_Tags["Space"] = "Space";
    RoomListEntriesDynamicFilterKind_Tags["NonLeft"] = "NonLeft";
    RoomListEntriesDynamicFilterKind_Tags["Joined"] = "Joined";
    RoomListEntriesDynamicFilterKind_Tags["Unread"] = "Unread";
    RoomListEntriesDynamicFilterKind_Tags["Favourite"] = "Favourite";
    RoomListEntriesDynamicFilterKind_Tags["LowPriority"] = "LowPriority";
    RoomListEntriesDynamicFilterKind_Tags["NonLowPriority"] = "NonLowPriority";
    RoomListEntriesDynamicFilterKind_Tags["Invite"] = "Invite";
    RoomListEntriesDynamicFilterKind_Tags["Category"] = "Category";
    RoomListEntriesDynamicFilterKind_Tags["None"] = "None";
    RoomListEntriesDynamicFilterKind_Tags["NormalizedMatchRoomName"] = "NormalizedMatchRoomName";
    RoomListEntriesDynamicFilterKind_Tags["FuzzyMatchRoomName"] = "FuzzyMatchRoomName";
    RoomListEntriesDynamicFilterKind_Tags["DeduplicateVersions"] = "DeduplicateVersions";
})(RoomListEntriesDynamicFilterKind_Tags || (RoomListEntriesDynamicFilterKind_Tags = {}));
export const RoomListEntriesDynamicFilterKind = (() => {
    class All_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesDynamicFilterKind";
        tag = RoomListEntriesDynamicFilterKind_Tags.All;
        inner;
        constructor(inner) {
            super("RoomListEntriesDynamicFilterKind", "All");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new All_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesDynamicFilterKind_Tags.All;
        }
    }
    class Any_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesDynamicFilterKind";
        tag = RoomListEntriesDynamicFilterKind_Tags.Any;
        inner;
        constructor(inner) {
            super("RoomListEntriesDynamicFilterKind", "Any");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Any_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesDynamicFilterKind_Tags.Any;
        }
    }
    class NonSpace_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesDynamicFilterKind";
        tag = RoomListEntriesDynamicFilterKind_Tags.NonSpace;
        constructor() {
            super("RoomListEntriesDynamicFilterKind", "NonSpace");
        }
        static new() {
            return new NonSpace_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesDynamicFilterKind_Tags.NonSpace;
        }
    }
    class Space_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesDynamicFilterKind";
        tag = RoomListEntriesDynamicFilterKind_Tags.Space;
        constructor() {
            super("RoomListEntriesDynamicFilterKind", "Space");
        }
        static new() {
            return new Space_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesDynamicFilterKind_Tags.Space;
        }
    }
    class NonLeft_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesDynamicFilterKind";
        tag = RoomListEntriesDynamicFilterKind_Tags.NonLeft;
        constructor() {
            super("RoomListEntriesDynamicFilterKind", "NonLeft");
        }
        static new() {
            return new NonLeft_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesDynamicFilterKind_Tags.NonLeft;
        }
    }
    class Joined_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesDynamicFilterKind";
        tag = RoomListEntriesDynamicFilterKind_Tags.Joined;
        constructor() {
            super("RoomListEntriesDynamicFilterKind", "Joined");
        }
        static new() {
            return new Joined_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesDynamicFilterKind_Tags.Joined;
        }
    }
    class Unread_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesDynamicFilterKind";
        tag = RoomListEntriesDynamicFilterKind_Tags.Unread;
        constructor() {
            super("RoomListEntriesDynamicFilterKind", "Unread");
        }
        static new() {
            return new Unread_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesDynamicFilterKind_Tags.Unread;
        }
    }
    class Favourite_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesDynamicFilterKind";
        tag = RoomListEntriesDynamicFilterKind_Tags.Favourite;
        constructor() {
            super("RoomListEntriesDynamicFilterKind", "Favourite");
        }
        static new() {
            return new Favourite_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesDynamicFilterKind_Tags.Favourite;
        }
    }
    class LowPriority_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesDynamicFilterKind";
        tag = RoomListEntriesDynamicFilterKind_Tags.LowPriority;
        constructor() {
            super("RoomListEntriesDynamicFilterKind", "LowPriority");
        }
        static new() {
            return new LowPriority_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesDynamicFilterKind_Tags.LowPriority;
        }
    }
    class NonLowPriority_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesDynamicFilterKind";
        tag = RoomListEntriesDynamicFilterKind_Tags.NonLowPriority;
        constructor() {
            super("RoomListEntriesDynamicFilterKind", "NonLowPriority");
        }
        static new() {
            return new NonLowPriority_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesDynamicFilterKind_Tags.NonLowPriority;
        }
    }
    class Invite_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesDynamicFilterKind";
        tag = RoomListEntriesDynamicFilterKind_Tags.Invite;
        constructor() {
            super("RoomListEntriesDynamicFilterKind", "Invite");
        }
        static new() {
            return new Invite_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesDynamicFilterKind_Tags.Invite;
        }
    }
    class Category_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesDynamicFilterKind";
        tag = RoomListEntriesDynamicFilterKind_Tags.Category;
        inner;
        constructor(inner) {
            super("RoomListEntriesDynamicFilterKind", "Category");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Category_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesDynamicFilterKind_Tags.Category;
        }
    }
    class None_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesDynamicFilterKind";
        tag = RoomListEntriesDynamicFilterKind_Tags.None;
        constructor() {
            super("RoomListEntriesDynamicFilterKind", "None");
        }
        static new() {
            return new None_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesDynamicFilterKind_Tags.None;
        }
    }
    class NormalizedMatchRoomName_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesDynamicFilterKind";
        tag = RoomListEntriesDynamicFilterKind_Tags.NormalizedMatchRoomName;
        inner;
        constructor(inner) {
            super("RoomListEntriesDynamicFilterKind", "NormalizedMatchRoomName");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new NormalizedMatchRoomName_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesDynamicFilterKind_Tags.NormalizedMatchRoomName;
        }
    }
    class FuzzyMatchRoomName_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesDynamicFilterKind";
        tag = RoomListEntriesDynamicFilterKind_Tags.FuzzyMatchRoomName;
        inner;
        constructor(inner) {
            super("RoomListEntriesDynamicFilterKind", "FuzzyMatchRoomName");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new FuzzyMatchRoomName_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesDynamicFilterKind_Tags.FuzzyMatchRoomName;
        }
    }
    class DeduplicateVersions_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesDynamicFilterKind";
        tag = RoomListEntriesDynamicFilterKind_Tags.DeduplicateVersions;
        constructor() {
            super("RoomListEntriesDynamicFilterKind", "DeduplicateVersions");
        }
        static new() {
            return new DeduplicateVersions_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesDynamicFilterKind_Tags.DeduplicateVersions;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "RoomListEntriesDynamicFilterKind";
    }
    return Object.freeze({
        instanceOf,
        All: All_,
        Any: Any_,
        NonSpace: NonSpace_,
        Space: Space_,
        NonLeft: NonLeft_,
        Joined: Joined_,
        Unread: Unread_,
        Favourite: Favourite_,
        LowPriority: LowPriority_,
        NonLowPriority: NonLowPriority_,
        Invite: Invite_,
        Category: Category_,
        None: None_,
        NormalizedMatchRoomName: NormalizedMatchRoomName_,
        FuzzyMatchRoomName: FuzzyMatchRoomName_,
        DeduplicateVersions: DeduplicateVersions_
    });
})();
// FfiConverter for enum RoomListEntriesDynamicFilterKind
const FfiConverterTypeRoomListEntriesDynamicFilterKind = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new RoomListEntriesDynamicFilterKind.All({ filters: FfiConverterArrayTypeRoomListEntriesDynamicFilterKind.read(from) });
                case 2: return new RoomListEntriesDynamicFilterKind.Any({ filters: FfiConverterArrayTypeRoomListEntriesDynamicFilterKind.read(from) });
                case 3: return new RoomListEntriesDynamicFilterKind.NonSpace();
                case 4: return new RoomListEntriesDynamicFilterKind.Space();
                case 5: return new RoomListEntriesDynamicFilterKind.NonLeft();
                case 6: return new RoomListEntriesDynamicFilterKind.Joined();
                case 7: return new RoomListEntriesDynamicFilterKind.Unread();
                case 8: return new RoomListEntriesDynamicFilterKind.Favourite();
                case 9: return new RoomListEntriesDynamicFilterKind.LowPriority();
                case 10: return new RoomListEntriesDynamicFilterKind.NonLowPriority();
                case 11: return new RoomListEntriesDynamicFilterKind.Invite();
                case 12: return new RoomListEntriesDynamicFilterKind.Category({ expect: FfiConverterTypeRoomListFilterCategory.read(from) });
                case 13: return new RoomListEntriesDynamicFilterKind.None();
                case 14: return new RoomListEntriesDynamicFilterKind.NormalizedMatchRoomName({ pattern: FfiConverterString.read(from) });
                case 15: return new RoomListEntriesDynamicFilterKind.FuzzyMatchRoomName({ pattern: FfiConverterString.read(from) });
                case 16: return new RoomListEntriesDynamicFilterKind.DeduplicateVersions();
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case RoomListEntriesDynamicFilterKind_Tags.All: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterArrayTypeRoomListEntriesDynamicFilterKind.write(inner.filters, into);
                    return;
                }
                case RoomListEntriesDynamicFilterKind_Tags.Any: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterArrayTypeRoomListEntriesDynamicFilterKind.write(inner.filters, into);
                    return;
                }
                case RoomListEntriesDynamicFilterKind_Tags.NonSpace: {
                    ordinalConverter.write(3, into);
                    return;
                }
                case RoomListEntriesDynamicFilterKind_Tags.Space: {
                    ordinalConverter.write(4, into);
                    return;
                }
                case RoomListEntriesDynamicFilterKind_Tags.NonLeft: {
                    ordinalConverter.write(5, into);
                    return;
                }
                case RoomListEntriesDynamicFilterKind_Tags.Joined: {
                    ordinalConverter.write(6, into);
                    return;
                }
                case RoomListEntriesDynamicFilterKind_Tags.Unread: {
                    ordinalConverter.write(7, into);
                    return;
                }
                case RoomListEntriesDynamicFilterKind_Tags.Favourite: {
                    ordinalConverter.write(8, into);
                    return;
                }
                case RoomListEntriesDynamicFilterKind_Tags.LowPriority: {
                    ordinalConverter.write(9, into);
                    return;
                }
                case RoomListEntriesDynamicFilterKind_Tags.NonLowPriority: {
                    ordinalConverter.write(10, into);
                    return;
                }
                case RoomListEntriesDynamicFilterKind_Tags.Invite: {
                    ordinalConverter.write(11, into);
                    return;
                }
                case RoomListEntriesDynamicFilterKind_Tags.Category: {
                    ordinalConverter.write(12, into);
                    const inner = value.inner;
                    FfiConverterTypeRoomListFilterCategory.write(inner.expect, into);
                    return;
                }
                case RoomListEntriesDynamicFilterKind_Tags.None: {
                    ordinalConverter.write(13, into);
                    return;
                }
                case RoomListEntriesDynamicFilterKind_Tags.NormalizedMatchRoomName: {
                    ordinalConverter.write(14, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.pattern, into);
                    return;
                }
                case RoomListEntriesDynamicFilterKind_Tags.FuzzyMatchRoomName: {
                    ordinalConverter.write(15, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.pattern, into);
                    return;
                }
                case RoomListEntriesDynamicFilterKind_Tags.DeduplicateVersions: {
                    ordinalConverter.write(16, into);
                    return;
                }
                default:
                    // Throwing from here means that RoomListEntriesDynamicFilterKind_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case RoomListEntriesDynamicFilterKind_Tags.All: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterArrayTypeRoomListEntriesDynamicFilterKind.allocationSize(inner.filters);
                    return size;
                }
                case RoomListEntriesDynamicFilterKind_Tags.Any: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterArrayTypeRoomListEntriesDynamicFilterKind.allocationSize(inner.filters);
                    return size;
                }
                case RoomListEntriesDynamicFilterKind_Tags.NonSpace: {
                    return ordinalConverter.allocationSize(3);
                }
                case RoomListEntriesDynamicFilterKind_Tags.Space: {
                    return ordinalConverter.allocationSize(4);
                }
                case RoomListEntriesDynamicFilterKind_Tags.NonLeft: {
                    return ordinalConverter.allocationSize(5);
                }
                case RoomListEntriesDynamicFilterKind_Tags.Joined: {
                    return ordinalConverter.allocationSize(6);
                }
                case RoomListEntriesDynamicFilterKind_Tags.Unread: {
                    return ordinalConverter.allocationSize(7);
                }
                case RoomListEntriesDynamicFilterKind_Tags.Favourite: {
                    return ordinalConverter.allocationSize(8);
                }
                case RoomListEntriesDynamicFilterKind_Tags.LowPriority: {
                    return ordinalConverter.allocationSize(9);
                }
                case RoomListEntriesDynamicFilterKind_Tags.NonLowPriority: {
                    return ordinalConverter.allocationSize(10);
                }
                case RoomListEntriesDynamicFilterKind_Tags.Invite: {
                    return ordinalConverter.allocationSize(11);
                }
                case RoomListEntriesDynamicFilterKind_Tags.Category: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(12);
                    size += FfiConverterTypeRoomListFilterCategory.allocationSize(inner.expect);
                    return size;
                }
                case RoomListEntriesDynamicFilterKind_Tags.None: {
                    return ordinalConverter.allocationSize(13);
                }
                case RoomListEntriesDynamicFilterKind_Tags.NormalizedMatchRoomName: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(14);
                    size += FfiConverterString.allocationSize(inner.pattern);
                    return size;
                }
                case RoomListEntriesDynamicFilterKind_Tags.FuzzyMatchRoomName: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(15);
                    size += FfiConverterString.allocationSize(inner.pattern);
                    return size;
                }
                case RoomListEntriesDynamicFilterKind_Tags.DeduplicateVersions: {
                    return ordinalConverter.allocationSize(16);
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: RoomListEntriesUpdate
export var RoomListEntriesUpdate_Tags;
(function (RoomListEntriesUpdate_Tags) {
    RoomListEntriesUpdate_Tags["Append"] = "Append";
    RoomListEntriesUpdate_Tags["Clear"] = "Clear";
    RoomListEntriesUpdate_Tags["PushFront"] = "PushFront";
    RoomListEntriesUpdate_Tags["PushBack"] = "PushBack";
    RoomListEntriesUpdate_Tags["PopFront"] = "PopFront";
    RoomListEntriesUpdate_Tags["PopBack"] = "PopBack";
    RoomListEntriesUpdate_Tags["Insert"] = "Insert";
    RoomListEntriesUpdate_Tags["Set"] = "Set";
    RoomListEntriesUpdate_Tags["Remove"] = "Remove";
    RoomListEntriesUpdate_Tags["Truncate"] = "Truncate";
    RoomListEntriesUpdate_Tags["Reset"] = "Reset";
})(RoomListEntriesUpdate_Tags || (RoomListEntriesUpdate_Tags = {}));
export const RoomListEntriesUpdate = (() => {
    class Append_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesUpdate";
        tag = RoomListEntriesUpdate_Tags.Append;
        inner;
        constructor(inner) {
            super("RoomListEntriesUpdate", "Append");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Append_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesUpdate_Tags.Append;
        }
    }
    class Clear_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesUpdate";
        tag = RoomListEntriesUpdate_Tags.Clear;
        constructor() {
            super("RoomListEntriesUpdate", "Clear");
        }
        static new() {
            return new Clear_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesUpdate_Tags.Clear;
        }
    }
    class PushFront_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesUpdate";
        tag = RoomListEntriesUpdate_Tags.PushFront;
        inner;
        constructor(inner) {
            super("RoomListEntriesUpdate", "PushFront");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new PushFront_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesUpdate_Tags.PushFront;
        }
    }
    class PushBack_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesUpdate";
        tag = RoomListEntriesUpdate_Tags.PushBack;
        inner;
        constructor(inner) {
            super("RoomListEntriesUpdate", "PushBack");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new PushBack_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesUpdate_Tags.PushBack;
        }
    }
    class PopFront_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesUpdate";
        tag = RoomListEntriesUpdate_Tags.PopFront;
        constructor() {
            super("RoomListEntriesUpdate", "PopFront");
        }
        static new() {
            return new PopFront_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesUpdate_Tags.PopFront;
        }
    }
    class PopBack_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesUpdate";
        tag = RoomListEntriesUpdate_Tags.PopBack;
        constructor() {
            super("RoomListEntriesUpdate", "PopBack");
        }
        static new() {
            return new PopBack_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesUpdate_Tags.PopBack;
        }
    }
    class Insert_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesUpdate";
        tag = RoomListEntriesUpdate_Tags.Insert;
        inner;
        constructor(inner) {
            super("RoomListEntriesUpdate", "Insert");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Insert_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesUpdate_Tags.Insert;
        }
    }
    class Set_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesUpdate";
        tag = RoomListEntriesUpdate_Tags.Set;
        inner;
        constructor(inner) {
            super("RoomListEntriesUpdate", "Set");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Set_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesUpdate_Tags.Set;
        }
    }
    class Remove_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesUpdate";
        tag = RoomListEntriesUpdate_Tags.Remove;
        inner;
        constructor(inner) {
            super("RoomListEntriesUpdate", "Remove");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Remove_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesUpdate_Tags.Remove;
        }
    }
    class Truncate_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesUpdate";
        tag = RoomListEntriesUpdate_Tags.Truncate;
        inner;
        constructor(inner) {
            super("RoomListEntriesUpdate", "Truncate");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Truncate_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesUpdate_Tags.Truncate;
        }
    }
    class Reset_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListEntriesUpdate";
        tag = RoomListEntriesUpdate_Tags.Reset;
        inner;
        constructor(inner) {
            super("RoomListEntriesUpdate", "Reset");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Reset_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomListEntriesUpdate_Tags.Reset;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "RoomListEntriesUpdate";
    }
    return Object.freeze({
        instanceOf,
        Append: Append_,
        Clear: Clear_,
        PushFront: PushFront_,
        PushBack: PushBack_,
        PopFront: PopFront_,
        PopBack: PopBack_,
        Insert: Insert_,
        Set: Set_,
        Remove: Remove_,
        Truncate: Truncate_,
        Reset: Reset_
    });
})();
// FfiConverter for enum RoomListEntriesUpdate
const FfiConverterTypeRoomListEntriesUpdate = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new RoomListEntriesUpdate.Append({ values: FfiConverterArrayTypeRoom.read(from) });
                case 2: return new RoomListEntriesUpdate.Clear();
                case 3: return new RoomListEntriesUpdate.PushFront({ value: FfiConverterTypeRoom.read(from) });
                case 4: return new RoomListEntriesUpdate.PushBack({ value: FfiConverterTypeRoom.read(from) });
                case 5: return new RoomListEntriesUpdate.PopFront();
                case 6: return new RoomListEntriesUpdate.PopBack();
                case 7: return new RoomListEntriesUpdate.Insert({ index: FfiConverterUInt32.read(from), value: FfiConverterTypeRoom.read(from) });
                case 8: return new RoomListEntriesUpdate.Set({ index: FfiConverterUInt32.read(from), value: FfiConverterTypeRoom.read(from) });
                case 9: return new RoomListEntriesUpdate.Remove({ index: FfiConverterUInt32.read(from) });
                case 10: return new RoomListEntriesUpdate.Truncate({ length: FfiConverterUInt32.read(from) });
                case 11: return new RoomListEntriesUpdate.Reset({ values: FfiConverterArrayTypeRoom.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case RoomListEntriesUpdate_Tags.Append: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterArrayTypeRoom.write(inner.values, into);
                    return;
                }
                case RoomListEntriesUpdate_Tags.Clear: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case RoomListEntriesUpdate_Tags.PushFront: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterTypeRoom.write(inner.value, into);
                    return;
                }
                case RoomListEntriesUpdate_Tags.PushBack: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterTypeRoom.write(inner.value, into);
                    return;
                }
                case RoomListEntriesUpdate_Tags.PopFront: {
                    ordinalConverter.write(5, into);
                    return;
                }
                case RoomListEntriesUpdate_Tags.PopBack: {
                    ordinalConverter.write(6, into);
                    return;
                }
                case RoomListEntriesUpdate_Tags.Insert: {
                    ordinalConverter.write(7, into);
                    const inner = value.inner;
                    FfiConverterUInt32.write(inner.index, into);
                    FfiConverterTypeRoom.write(inner.value, into);
                    return;
                }
                case RoomListEntriesUpdate_Tags.Set: {
                    ordinalConverter.write(8, into);
                    const inner = value.inner;
                    FfiConverterUInt32.write(inner.index, into);
                    FfiConverterTypeRoom.write(inner.value, into);
                    return;
                }
                case RoomListEntriesUpdate_Tags.Remove: {
                    ordinalConverter.write(9, into);
                    const inner = value.inner;
                    FfiConverterUInt32.write(inner.index, into);
                    return;
                }
                case RoomListEntriesUpdate_Tags.Truncate: {
                    ordinalConverter.write(10, into);
                    const inner = value.inner;
                    FfiConverterUInt32.write(inner.length, into);
                    return;
                }
                case RoomListEntriesUpdate_Tags.Reset: {
                    ordinalConverter.write(11, into);
                    const inner = value.inner;
                    FfiConverterArrayTypeRoom.write(inner.values, into);
                    return;
                }
                default:
                    // Throwing from here means that RoomListEntriesUpdate_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case RoomListEntriesUpdate_Tags.Append: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterArrayTypeRoom.allocationSize(inner.values);
                    return size;
                }
                case RoomListEntriesUpdate_Tags.Clear: {
                    return ordinalConverter.allocationSize(2);
                }
                case RoomListEntriesUpdate_Tags.PushFront: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterTypeRoom.allocationSize(inner.value);
                    return size;
                }
                case RoomListEntriesUpdate_Tags.PushBack: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterTypeRoom.allocationSize(inner.value);
                    return size;
                }
                case RoomListEntriesUpdate_Tags.PopFront: {
                    return ordinalConverter.allocationSize(5);
                }
                case RoomListEntriesUpdate_Tags.PopBack: {
                    return ordinalConverter.allocationSize(6);
                }
                case RoomListEntriesUpdate_Tags.Insert: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(7);
                    size += FfiConverterUInt32.allocationSize(inner.index);
                    size += FfiConverterTypeRoom.allocationSize(inner.value);
                    return size;
                }
                case RoomListEntriesUpdate_Tags.Set: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(8);
                    size += FfiConverterUInt32.allocationSize(inner.index);
                    size += FfiConverterTypeRoom.allocationSize(inner.value);
                    return size;
                }
                case RoomListEntriesUpdate_Tags.Remove: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(9);
                    size += FfiConverterUInt32.allocationSize(inner.index);
                    return size;
                }
                case RoomListEntriesUpdate_Tags.Truncate: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(10);
                    size += FfiConverterUInt32.allocationSize(inner.length);
                    return size;
                }
                case RoomListEntriesUpdate_Tags.Reset: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(11);
                    size += FfiConverterArrayTypeRoom.allocationSize(inner.values);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Error type: RoomListError
// Enum: RoomListError
export var RoomListError_Tags;
(function (RoomListError_Tags) {
    RoomListError_Tags["SlidingSync"] = "SlidingSync";
    RoomListError_Tags["UnknownList"] = "UnknownList";
    RoomListError_Tags["InputCannotBeApplied"] = "InputCannotBeApplied";
    RoomListError_Tags["RoomNotFound"] = "RoomNotFound";
    RoomListError_Tags["InvalidRoomId"] = "InvalidRoomId";
    RoomListError_Tags["EventCache"] = "EventCache";
    RoomListError_Tags["IncorrectRoomMembership"] = "IncorrectRoomMembership";
})(RoomListError_Tags || (RoomListError_Tags = {}));
export const RoomListError = (() => {
    class SlidingSync_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListError";
        tag = RoomListError_Tags.SlidingSync;
        inner;
        constructor(inner) {
            super("RoomListError", "SlidingSync");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new SlidingSync_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomListError_Tags.SlidingSync;
        }
        static hasInner(obj) {
            return SlidingSync_.instanceOf(obj);
        }
        static getInner(obj) {
            return obj.inner;
        }
    }
    class UnknownList_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListError";
        tag = RoomListError_Tags.UnknownList;
        inner;
        constructor(inner) {
            super("RoomListError", "UnknownList");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new UnknownList_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomListError_Tags.UnknownList;
        }
        static hasInner(obj) {
            return UnknownList_.instanceOf(obj);
        }
        static getInner(obj) {
            return obj.inner;
        }
    }
    class InputCannotBeApplied_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListError";
        tag = RoomListError_Tags.InputCannotBeApplied;
        constructor() {
            super("RoomListError", "InputCannotBeApplied");
        }
        static new() {
            return new InputCannotBeApplied_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomListError_Tags.InputCannotBeApplied;
        }
        static hasInner(obj) {
            return false;
        }
    }
    class RoomNotFound_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListError";
        tag = RoomListError_Tags.RoomNotFound;
        inner;
        constructor(inner) {
            super("RoomListError", "RoomNotFound");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new RoomNotFound_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomListError_Tags.RoomNotFound;
        }
        static hasInner(obj) {
            return RoomNotFound_.instanceOf(obj);
        }
        static getInner(obj) {
            return obj.inner;
        }
    }
    class InvalidRoomId_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListError";
        tag = RoomListError_Tags.InvalidRoomId;
        inner;
        constructor(inner) {
            super("RoomListError", "InvalidRoomId");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new InvalidRoomId_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomListError_Tags.InvalidRoomId;
        }
        static hasInner(obj) {
            return InvalidRoomId_.instanceOf(obj);
        }
        static getInner(obj) {
            return obj.inner;
        }
    }
    class EventCache_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListError";
        tag = RoomListError_Tags.EventCache;
        inner;
        constructor(inner) {
            super("RoomListError", "EventCache");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new EventCache_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomListError_Tags.EventCache;
        }
        static hasInner(obj) {
            return EventCache_.instanceOf(obj);
        }
        static getInner(obj) {
            return obj.inner;
        }
    }
    class IncorrectRoomMembership_ extends UniffiError {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListError";
        tag = RoomListError_Tags.IncorrectRoomMembership;
        inner;
        constructor(inner) {
            super("RoomListError", "IncorrectRoomMembership");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new IncorrectRoomMembership_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomListError_Tags.IncorrectRoomMembership;
        }
        static hasInner(obj) {
            return IncorrectRoomMembership_.instanceOf(obj);
        }
        static getInner(obj) {
            return obj.inner;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "RoomListError";
    }
    return Object.freeze({
        instanceOf,
        SlidingSync: SlidingSync_,
        UnknownList: UnknownList_,
        InputCannotBeApplied: InputCannotBeApplied_,
        RoomNotFound: RoomNotFound_,
        InvalidRoomId: InvalidRoomId_,
        EventCache: EventCache_,
        IncorrectRoomMembership: IncorrectRoomMembership_
    });
})();
// FfiConverter for enum RoomListError
const FfiConverterTypeRoomListError = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new RoomListError.SlidingSync({ error: FfiConverterString.read(from) });
                case 2: return new RoomListError.UnknownList({ listName: FfiConverterString.read(from) });
                case 3: return new RoomListError.InputCannotBeApplied();
                case 4: return new RoomListError.RoomNotFound({ roomName: FfiConverterString.read(from) });
                case 5: return new RoomListError.InvalidRoomId({ error: FfiConverterString.read(from) });
                case 6: return new RoomListError.EventCache({ error: FfiConverterString.read(from) });
                case 7: return new RoomListError.IncorrectRoomMembership({ expected: FfiConverterArrayTypeMembership.read(from), actual: FfiConverterTypeMembership.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case RoomListError_Tags.SlidingSync: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.error, into);
                    return;
                }
                case RoomListError_Tags.UnknownList: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.listName, into);
                    return;
                }
                case RoomListError_Tags.InputCannotBeApplied: {
                    ordinalConverter.write(3, into);
                    return;
                }
                case RoomListError_Tags.RoomNotFound: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.roomName, into);
                    return;
                }
                case RoomListError_Tags.InvalidRoomId: {
                    ordinalConverter.write(5, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.error, into);
                    return;
                }
                case RoomListError_Tags.EventCache: {
                    ordinalConverter.write(6, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.error, into);
                    return;
                }
                case RoomListError_Tags.IncorrectRoomMembership: {
                    ordinalConverter.write(7, into);
                    const inner = value.inner;
                    FfiConverterArrayTypeMembership.write(inner.expected, into);
                    FfiConverterTypeMembership.write(inner.actual, into);
                    return;
                }
                default:
                    // Throwing from here means that RoomListError_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case RoomListError_Tags.SlidingSync: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterString.allocationSize(inner.error);
                    return size;
                }
                case RoomListError_Tags.UnknownList: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterString.allocationSize(inner.listName);
                    return size;
                }
                case RoomListError_Tags.InputCannotBeApplied: {
                    return ordinalConverter.allocationSize(3);
                }
                case RoomListError_Tags.RoomNotFound: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterString.allocationSize(inner.roomName);
                    return size;
                }
                case RoomListError_Tags.InvalidRoomId: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(5);
                    size += FfiConverterString.allocationSize(inner.error);
                    return size;
                }
                case RoomListError_Tags.EventCache: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(6);
                    size += FfiConverterString.allocationSize(inner.error);
                    return size;
                }
                case RoomListError_Tags.IncorrectRoomMembership: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(7);
                    size += FfiConverterArrayTypeMembership.allocationSize(inner.expected);
                    size += FfiConverterTypeMembership.allocationSize(inner.actual);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
export var RoomListFilterCategory;
(function (RoomListFilterCategory) {
    RoomListFilterCategory[RoomListFilterCategory["Group"] = 0] = "Group";
    RoomListFilterCategory[RoomListFilterCategory["People"] = 1] = "People";
})(RoomListFilterCategory || (RoomListFilterCategory = {}));
const FfiConverterTypeRoomListFilterCategory = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return RoomListFilterCategory.Group;
                case 2: return RoomListFilterCategory.People;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case RoomListFilterCategory.Group: return ordinalConverter.write(1, into);
                case RoomListFilterCategory.People: return ordinalConverter.write(2, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Enum: RoomListLoadingState
export var RoomListLoadingState_Tags;
(function (RoomListLoadingState_Tags) {
    RoomListLoadingState_Tags["NotLoaded"] = "NotLoaded";
    RoomListLoadingState_Tags["Loaded"] = "Loaded";
})(RoomListLoadingState_Tags || (RoomListLoadingState_Tags = {}));
export const RoomListLoadingState = (() => {
    class NotLoaded_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListLoadingState";
        tag = RoomListLoadingState_Tags.NotLoaded;
        constructor() {
            super("RoomListLoadingState", "NotLoaded");
        }
        static new() {
            return new NotLoaded_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomListLoadingState_Tags.NotLoaded;
        }
    }
    class Loaded_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomListLoadingState";
        tag = RoomListLoadingState_Tags.Loaded;
        inner;
        constructor(inner) {
            super("RoomListLoadingState", "Loaded");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Loaded_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomListLoadingState_Tags.Loaded;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "RoomListLoadingState";
    }
    return Object.freeze({
        instanceOf,
        NotLoaded: NotLoaded_,
        Loaded: Loaded_
    });
})();
// FfiConverter for enum RoomListLoadingState
const FfiConverterTypeRoomListLoadingState = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new RoomListLoadingState.NotLoaded();
                case 2: return new RoomListLoadingState.Loaded({ maximumNumberOfRooms: FfiConverterOptionalUInt32.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case RoomListLoadingState_Tags.NotLoaded: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case RoomListLoadingState_Tags.Loaded: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterOptionalUInt32.write(inner.maximumNumberOfRooms, into);
                    return;
                }
                default:
                    // Throwing from here means that RoomListLoadingState_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case RoomListLoadingState_Tags.NotLoaded: {
                    return ordinalConverter.allocationSize(1);
                }
                case RoomListLoadingState_Tags.Loaded: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterOptionalUInt32.allocationSize(inner.maximumNumberOfRooms);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
export var RoomListServiceState;
(function (RoomListServiceState) {
    RoomListServiceState[RoomListServiceState["Initial"] = 0] = "Initial";
    RoomListServiceState[RoomListServiceState["SettingUp"] = 1] = "SettingUp";
    RoomListServiceState[RoomListServiceState["Recovering"] = 2] = "Recovering";
    RoomListServiceState[RoomListServiceState["Running"] = 3] = "Running";
    RoomListServiceState[RoomListServiceState["Error"] = 4] = "Error";
    RoomListServiceState[RoomListServiceState["Terminated"] = 5] = "Terminated";
})(RoomListServiceState || (RoomListServiceState = {}));
const FfiConverterTypeRoomListServiceState = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return RoomListServiceState.Initial;
                case 2: return RoomListServiceState.SettingUp;
                case 3: return RoomListServiceState.Recovering;
                case 4: return RoomListServiceState.Running;
                case 5: return RoomListServiceState.Error;
                case 6: return RoomListServiceState.Terminated;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case RoomListServiceState.Initial: return ordinalConverter.write(1, into);
                case RoomListServiceState.SettingUp: return ordinalConverter.write(2, into);
                case RoomListServiceState.Recovering: return ordinalConverter.write(3, into);
                case RoomListServiceState.Running: return ordinalConverter.write(4, into);
                case RoomListServiceState.Error: return ordinalConverter.write(5, into);
                case RoomListServiceState.Terminated: return ordinalConverter.write(6, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
export var RoomListServiceSyncIndicator;
(function (RoomListServiceSyncIndicator) {
    RoomListServiceSyncIndicator[RoomListServiceSyncIndicator["Show"] = 0] = "Show";
    RoomListServiceSyncIndicator[RoomListServiceSyncIndicator["Hide"] = 1] = "Hide";
})(RoomListServiceSyncIndicator || (RoomListServiceSyncIndicator = {}));
const FfiConverterTypeRoomListServiceSyncIndicator = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return RoomListServiceSyncIndicator.Show;
                case 2: return RoomListServiceSyncIndicator.Hide;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case RoomListServiceSyncIndicator.Show: return ordinalConverter.write(1, into);
                case RoomListServiceSyncIndicator.Hide: return ordinalConverter.write(2, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Enum: RoomLoadSettings
export var RoomLoadSettings_Tags;
(function (RoomLoadSettings_Tags) {
    RoomLoadSettings_Tags["All"] = "All";
    RoomLoadSettings_Tags["One"] = "One";
})(RoomLoadSettings_Tags || (RoomLoadSettings_Tags = {}));
/**
 * Configure how many rooms will be restored when restoring the session with
 * [`Client::restore_session_with`].
 *
 * Please, see the documentation of [`matrix_sdk::store::RoomLoadSettings`] to
 * learn more.
 */
export const RoomLoadSettings = (() => {
    /**
     * Load all rooms from the `StateStore` into the in-memory state store
     * `BaseStateStore`.
     */
    class All_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomLoadSettings";
        tag = RoomLoadSettings_Tags.All;
        constructor() {
            super("RoomLoadSettings", "All");
        }
        static new() {
            return new All_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomLoadSettings_Tags.All;
        }
    }
    /**
     * Load a single room from the `StateStore` into the in-memory state
     * store `BaseStateStore`.
     *
     * Please, be careful with this option. Read the documentation of
     * [`RoomLoadSettings`].
     */
    class One_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomLoadSettings";
        tag = RoomLoadSettings_Tags.One;
        inner;
        constructor(inner) {
            super("RoomLoadSettings", "One");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new One_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomLoadSettings_Tags.One;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "RoomLoadSettings";
    }
    return Object.freeze({
        instanceOf,
        All: All_,
        One: One_
    });
})();
// FfiConverter for enum RoomLoadSettings
const FfiConverterTypeRoomLoadSettings = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new RoomLoadSettings.All();
                case 2: return new RoomLoadSettings.One({ roomId: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case RoomLoadSettings_Tags.All: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case RoomLoadSettings_Tags.One: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.roomId, into);
                    return;
                }
                default:
                    // Throwing from here means that RoomLoadSettings_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case RoomLoadSettings_Tags.All: {
                    return ordinalConverter.allocationSize(1);
                }
                case RoomLoadSettings_Tags.One: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterString.allocationSize(inner.roomId);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
export var RoomMessageEventMessageType;
(function (RoomMessageEventMessageType) {
    RoomMessageEventMessageType[RoomMessageEventMessageType["Audio"] = 0] = "Audio";
    RoomMessageEventMessageType[RoomMessageEventMessageType["Emote"] = 1] = "Emote";
    RoomMessageEventMessageType[RoomMessageEventMessageType["File"] = 2] = "File";
    RoomMessageEventMessageType[RoomMessageEventMessageType["Image"] = 3] = "Image";
    RoomMessageEventMessageType[RoomMessageEventMessageType["Location"] = 4] = "Location";
    RoomMessageEventMessageType[RoomMessageEventMessageType["Notice"] = 5] = "Notice";
    RoomMessageEventMessageType[RoomMessageEventMessageType["ServerNotice"] = 6] = "ServerNotice";
    RoomMessageEventMessageType[RoomMessageEventMessageType["Text"] = 7] = "Text";
    RoomMessageEventMessageType[RoomMessageEventMessageType["Video"] = 8] = "Video";
    RoomMessageEventMessageType[RoomMessageEventMessageType["VerificationRequest"] = 9] = "VerificationRequest";
    RoomMessageEventMessageType[RoomMessageEventMessageType["Other"] = 10] = "Other";
})(RoomMessageEventMessageType || (RoomMessageEventMessageType = {}));
const FfiConverterTypeRoomMessageEventMessageType = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return RoomMessageEventMessageType.Audio;
                case 2: return RoomMessageEventMessageType.Emote;
                case 3: return RoomMessageEventMessageType.File;
                case 4: return RoomMessageEventMessageType.Image;
                case 5: return RoomMessageEventMessageType.Location;
                case 6: return RoomMessageEventMessageType.Notice;
                case 7: return RoomMessageEventMessageType.ServerNotice;
                case 8: return RoomMessageEventMessageType.Text;
                case 9: return RoomMessageEventMessageType.Video;
                case 10: return RoomMessageEventMessageType.VerificationRequest;
                case 11: return RoomMessageEventMessageType.Other;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case RoomMessageEventMessageType.Audio: return ordinalConverter.write(1, into);
                case RoomMessageEventMessageType.Emote: return ordinalConverter.write(2, into);
                case RoomMessageEventMessageType.File: return ordinalConverter.write(3, into);
                case RoomMessageEventMessageType.Image: return ordinalConverter.write(4, into);
                case RoomMessageEventMessageType.Location: return ordinalConverter.write(5, into);
                case RoomMessageEventMessageType.Notice: return ordinalConverter.write(6, into);
                case RoomMessageEventMessageType.ServerNotice: return ordinalConverter.write(7, into);
                case RoomMessageEventMessageType.Text: return ordinalConverter.write(8, into);
                case RoomMessageEventMessageType.Video: return ordinalConverter.write(9, into);
                case RoomMessageEventMessageType.VerificationRequest: return ordinalConverter.write(10, into);
                case RoomMessageEventMessageType.Other: return ordinalConverter.write(11, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
/**
 * Enum representing the push notification modes for a room.
 */
export var RoomNotificationMode;
(function (RoomNotificationMode) {
    /**
     * Receive notifications for all messages.
     */
    RoomNotificationMode[RoomNotificationMode["AllMessages"] = 0] = "AllMessages";
    /**
     * Receive notifications for mentions and keywords only.
     */
    RoomNotificationMode[RoomNotificationMode["MentionsAndKeywordsOnly"] = 1] = "MentionsAndKeywordsOnly";
    /**
     * Do not receive any notifications.
     */
    RoomNotificationMode[RoomNotificationMode["Mute"] = 2] = "Mute";
})(RoomNotificationMode || (RoomNotificationMode = {}));
const FfiConverterTypeRoomNotificationMode = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return RoomNotificationMode.AllMessages;
                case 2: return RoomNotificationMode.MentionsAndKeywordsOnly;
                case 3: return RoomNotificationMode.Mute;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case RoomNotificationMode.AllMessages: return ordinalConverter.write(1, into);
                case RoomNotificationMode.MentionsAndKeywordsOnly: return ordinalConverter.write(2, into);
                case RoomNotificationMode.Mute: return ordinalConverter.write(3, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
export var RoomPreset;
(function (RoomPreset) {
    /**
     * `join_rules` is set to `invite` and `history_visibility` is set to
     * `shared`.
     */
    RoomPreset[RoomPreset["PrivateChat"] = 0] = "PrivateChat";
    /**
     * `join_rules` is set to `public` and `history_visibility` is set to
     * `shared`.
     */
    RoomPreset[RoomPreset["PublicChat"] = 1] = "PublicChat";
    /**
     * Same as `PrivateChat`, but all initial invitees get the same power level
     * as the creator.
     */
    RoomPreset[RoomPreset["TrustedPrivateChat"] = 2] = "TrustedPrivateChat";
})(RoomPreset || (RoomPreset = {}));
const FfiConverterTypeRoomPreset = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return RoomPreset.PrivateChat;
                case 2: return RoomPreset.PublicChat;
                case 3: return RoomPreset.TrustedPrivateChat;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case RoomPreset.PrivateChat: return ordinalConverter.write(1, into);
                case RoomPreset.PublicChat: return ordinalConverter.write(2, into);
                case RoomPreset.TrustedPrivateChat: return ordinalConverter.write(3, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Enum: RoomSendQueueUpdate
export var RoomSendQueueUpdate_Tags;
(function (RoomSendQueueUpdate_Tags) {
    RoomSendQueueUpdate_Tags["NewLocalEvent"] = "NewLocalEvent";
    RoomSendQueueUpdate_Tags["CancelledLocalEvent"] = "CancelledLocalEvent";
    RoomSendQueueUpdate_Tags["ReplacedLocalEvent"] = "ReplacedLocalEvent";
    RoomSendQueueUpdate_Tags["SendError"] = "SendError";
    RoomSendQueueUpdate_Tags["RetryEvent"] = "RetryEvent";
    RoomSendQueueUpdate_Tags["SentEvent"] = "SentEvent";
    RoomSendQueueUpdate_Tags["MediaUpload"] = "MediaUpload";
})(RoomSendQueueUpdate_Tags || (RoomSendQueueUpdate_Tags = {}));
/**
 * An update to a room send queue.
 */
export const RoomSendQueueUpdate = (() => {
    /**
     * A new local event is being sent.
     */
    class NewLocalEvent_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomSendQueueUpdate";
        tag = RoomSendQueueUpdate_Tags.NewLocalEvent;
        inner;
        constructor(inner) {
            super("RoomSendQueueUpdate", "NewLocalEvent");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new NewLocalEvent_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomSendQueueUpdate_Tags.NewLocalEvent;
        }
    }
    /**
     * A local event that hadn't been sent to the server yet has been cancelled
     * before sending.
     */
    class CancelledLocalEvent_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomSendQueueUpdate";
        tag = RoomSendQueueUpdate_Tags.CancelledLocalEvent;
        inner;
        constructor(inner) {
            super("RoomSendQueueUpdate", "CancelledLocalEvent");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new CancelledLocalEvent_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomSendQueueUpdate_Tags.CancelledLocalEvent;
        }
    }
    /**
     * A local event's content has been replaced with something else.
     */
    class ReplacedLocalEvent_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomSendQueueUpdate";
        tag = RoomSendQueueUpdate_Tags.ReplacedLocalEvent;
        inner;
        constructor(inner) {
            super("RoomSendQueueUpdate", "ReplacedLocalEvent");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new ReplacedLocalEvent_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomSendQueueUpdate_Tags.ReplacedLocalEvent;
        }
    }
    /**
     * An error happened when an event was being sent.
     *
     * The event has not been removed from the queue. All the send queues
     * will be disabled after this happens, and must be manually re-enabled.
     */
    class SendError_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomSendQueueUpdate";
        tag = RoomSendQueueUpdate_Tags.SendError;
        inner;
        constructor(inner) {
            super("RoomSendQueueUpdate", "SendError");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new SendError_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomSendQueueUpdate_Tags.SendError;
        }
    }
    /**
     * The event has been unwedged and sending is now being retried.
     */
    class RetryEvent_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomSendQueueUpdate";
        tag = RoomSendQueueUpdate_Tags.RetryEvent;
        inner;
        constructor(inner) {
            super("RoomSendQueueUpdate", "RetryEvent");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new RetryEvent_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomSendQueueUpdate_Tags.RetryEvent;
        }
    }
    /**
     * The event has been sent to the server, and the query returned
     * successfully.
     */
    class SentEvent_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomSendQueueUpdate";
        tag = RoomSendQueueUpdate_Tags.SentEvent;
        inner;
        constructor(inner) {
            super("RoomSendQueueUpdate", "SentEvent");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new SentEvent_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomSendQueueUpdate_Tags.SentEvent;
        }
    }
    /**
     * A media upload (consisting of a file and possibly a thumbnail) has made
     * progress.
     */
    class MediaUpload_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomSendQueueUpdate";
        tag = RoomSendQueueUpdate_Tags.MediaUpload;
        inner;
        constructor(inner) {
            super("RoomSendQueueUpdate", "MediaUpload");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new MediaUpload_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomSendQueueUpdate_Tags.MediaUpload;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "RoomSendQueueUpdate";
    }
    return Object.freeze({
        instanceOf,
        NewLocalEvent: NewLocalEvent_,
        CancelledLocalEvent: CancelledLocalEvent_,
        ReplacedLocalEvent: ReplacedLocalEvent_,
        SendError: SendError_,
        RetryEvent: RetryEvent_,
        SentEvent: SentEvent_,
        MediaUpload: MediaUpload_
    });
})();
// FfiConverter for enum RoomSendQueueUpdate
const FfiConverterTypeRoomSendQueueUpdate = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new RoomSendQueueUpdate.NewLocalEvent({ transactionId: FfiConverterString.read(from) });
                case 2: return new RoomSendQueueUpdate.CancelledLocalEvent({ transactionId: FfiConverterString.read(from) });
                case 3: return new RoomSendQueueUpdate.ReplacedLocalEvent({ transactionId: FfiConverterString.read(from) });
                case 4: return new RoomSendQueueUpdate.SendError({ transactionId: FfiConverterString.read(from), error: FfiConverterTypeQueueWedgeError.read(from), isRecoverable: FfiConverterBool.read(from) });
                case 5: return new RoomSendQueueUpdate.RetryEvent({ transactionId: FfiConverterString.read(from) });
                case 6: return new RoomSendQueueUpdate.SentEvent({ transactionId: FfiConverterString.read(from), eventId: FfiConverterString.read(from) });
                case 7: return new RoomSendQueueUpdate.MediaUpload({ relatedTo: FfiConverterString.read(from), file: FfiConverterOptionalTypeMediaSource.read(from), index: FfiConverterUInt64.read(from), progress: FfiConverterTypeAbstractProgress.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case RoomSendQueueUpdate_Tags.NewLocalEvent: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.transactionId, into);
                    return;
                }
                case RoomSendQueueUpdate_Tags.CancelledLocalEvent: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.transactionId, into);
                    return;
                }
                case RoomSendQueueUpdate_Tags.ReplacedLocalEvent: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.transactionId, into);
                    return;
                }
                case RoomSendQueueUpdate_Tags.SendError: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.transactionId, into);
                    FfiConverterTypeQueueWedgeError.write(inner.error, into);
                    FfiConverterBool.write(inner.isRecoverable, into);
                    return;
                }
                case RoomSendQueueUpdate_Tags.RetryEvent: {
                    ordinalConverter.write(5, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.transactionId, into);
                    return;
                }
                case RoomSendQueueUpdate_Tags.SentEvent: {
                    ordinalConverter.write(6, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.transactionId, into);
                    FfiConverterString.write(inner.eventId, into);
                    return;
                }
                case RoomSendQueueUpdate_Tags.MediaUpload: {
                    ordinalConverter.write(7, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.relatedTo, into);
                    FfiConverterOptionalTypeMediaSource.write(inner.file, into);
                    FfiConverterUInt64.write(inner.index, into);
                    FfiConverterTypeAbstractProgress.write(inner.progress, into);
                    return;
                }
                default:
                    // Throwing from here means that RoomSendQueueUpdate_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case RoomSendQueueUpdate_Tags.NewLocalEvent: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterString.allocationSize(inner.transactionId);
                    return size;
                }
                case RoomSendQueueUpdate_Tags.CancelledLocalEvent: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterString.allocationSize(inner.transactionId);
                    return size;
                }
                case RoomSendQueueUpdate_Tags.ReplacedLocalEvent: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterString.allocationSize(inner.transactionId);
                    return size;
                }
                case RoomSendQueueUpdate_Tags.SendError: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterString.allocationSize(inner.transactionId);
                    size += FfiConverterTypeQueueWedgeError.allocationSize(inner.error);
                    size += FfiConverterBool.allocationSize(inner.isRecoverable);
                    return size;
                }
                case RoomSendQueueUpdate_Tags.RetryEvent: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(5);
                    size += FfiConverterString.allocationSize(inner.transactionId);
                    return size;
                }
                case RoomSendQueueUpdate_Tags.SentEvent: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(6);
                    size += FfiConverterString.allocationSize(inner.transactionId);
                    size += FfiConverterString.allocationSize(inner.eventId);
                    return size;
                }
                case RoomSendQueueUpdate_Tags.MediaUpload: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(7);
                    size += FfiConverterString.allocationSize(inner.relatedTo);
                    size += FfiConverterOptionalTypeMediaSource.allocationSize(inner.file);
                    size += FfiConverterUInt64.allocationSize(inner.index);
                    size += FfiConverterTypeAbstractProgress.allocationSize(inner.progress);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: RoomType
export var RoomType_Tags;
(function (RoomType_Tags) {
    RoomType_Tags["Room"] = "Room";
    RoomType_Tags["Space"] = "Space";
    RoomType_Tags["Custom"] = "Custom";
})(RoomType_Tags || (RoomType_Tags = {}));
/**
 * The type of room for a [`RoomPreviewInfo`].
 */
export const RoomType = (() => {
    /**
     * It's a plain chat room.
     */
    class Room_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomType";
        tag = RoomType_Tags.Room;
        constructor() {
            super("RoomType", "Room");
        }
        static new() {
            return new Room_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomType_Tags.Room;
        }
    }
    /**
     * It's a space that can group several rooms.
     */
    class Space_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomType";
        tag = RoomType_Tags.Space;
        constructor() {
            super("RoomType", "Space");
        }
        static new() {
            return new Space_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomType_Tags.Space;
        }
    }
    /**
     * It's a custom implementation.
     */
    class Custom_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomType";
        tag = RoomType_Tags.Custom;
        inner;
        constructor(inner) {
            super("RoomType", "Custom");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Custom_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomType_Tags.Custom;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "RoomType";
    }
    return Object.freeze({
        instanceOf,
        Room: Room_,
        Space: Space_,
        Custom: Custom_
    });
})();
// FfiConverter for enum RoomType
const FfiConverterTypeRoomType = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new RoomType.Room();
                case 2: return new RoomType.Space();
                case 3: return new RoomType.Custom({ value: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case RoomType_Tags.Room: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case RoomType_Tags.Space: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case RoomType_Tags.Custom: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.value, into);
                    return;
                }
                default:
                    // Throwing from here means that RoomType_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case RoomType_Tags.Room: {
                    return ordinalConverter.allocationSize(1);
                }
                case RoomType_Tags.Space: {
                    return ordinalConverter.allocationSize(2);
                }
                case RoomType_Tags.Custom: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterString.allocationSize(inner.value);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: RoomVisibility
export var RoomVisibility_Tags;
(function (RoomVisibility_Tags) {
    RoomVisibility_Tags["Public"] = "Public";
    RoomVisibility_Tags["Private"] = "Private";
    RoomVisibility_Tags["Custom"] = "Custom";
})(RoomVisibility_Tags || (RoomVisibility_Tags = {}));
export const RoomVisibility = (() => {
    /**
     * Indicates that the room will be shown in the published room list.
     */
    class Public_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomVisibility";
        tag = RoomVisibility_Tags.Public;
        constructor() {
            super("RoomVisibility", "Public");
        }
        static new() {
            return new Public_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomVisibility_Tags.Public;
        }
    }
    /**
     * Indicates that the room will not be shown in the published room list.
     */
    class Private_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomVisibility";
        tag = RoomVisibility_Tags.Private;
        constructor() {
            super("RoomVisibility", "Private");
        }
        static new() {
            return new Private_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomVisibility_Tags.Private;
        }
    }
    /**
     * A custom value that's not present in the spec.
     */
    class Custom_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomVisibility";
        tag = RoomVisibility_Tags.Custom;
        inner;
        constructor(inner) {
            super("RoomVisibility", "Custom");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Custom_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomVisibility_Tags.Custom;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "RoomVisibility";
    }
    return Object.freeze({
        instanceOf,
        Public: Public_,
        Private: Private_,
        Custom: Custom_
    });
})();
// FfiConverter for enum RoomVisibility
const FfiConverterTypeRoomVisibility = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new RoomVisibility.Public();
                case 2: return new RoomVisibility.Private();
                case 3: return new RoomVisibility.Custom({ value: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case RoomVisibility_Tags.Public: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case RoomVisibility_Tags.Private: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case RoomVisibility_Tags.Custom: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.value, into);
                    return;
                }
                default:
                    // Throwing from here means that RoomVisibility_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case RoomVisibility_Tags.Public: {
                    return ordinalConverter.allocationSize(1);
                }
                case RoomVisibility_Tags.Private: {
                    return ordinalConverter.allocationSize(2);
                }
                case RoomVisibility_Tags.Custom: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterString.allocationSize(inner.value);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
export var RtcNotificationType;
(function (RtcNotificationType) {
    RtcNotificationType[RtcNotificationType["Ring"] = 0] = "Ring";
    RtcNotificationType[RtcNotificationType["Notification"] = 1] = "Notification";
})(RtcNotificationType || (RtcNotificationType = {}));
const FfiConverterTypeRtcNotificationType = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return RtcNotificationType.Ring;
                case 2: return RtcNotificationType.Notification;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case RtcNotificationType.Ring: return ordinalConverter.write(1, into);
                case RtcNotificationType.Notification: return ordinalConverter.write(2, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Enum: RuleKind
export var RuleKind_Tags;
(function (RuleKind_Tags) {
    RuleKind_Tags["Override"] = "Override";
    RuleKind_Tags["Underride"] = "Underride";
    RuleKind_Tags["Sender"] = "Sender";
    RuleKind_Tags["Room"] = "Room";
    RuleKind_Tags["Content"] = "Content";
    RuleKind_Tags["Custom"] = "Custom";
})(RuleKind_Tags || (RuleKind_Tags = {}));
export const RuleKind = (() => {
    /**
     * User-configured rules that override all other kinds.
     */
    class Override_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RuleKind";
        tag = RuleKind_Tags.Override;
        constructor() {
            super("RuleKind", "Override");
        }
        static new() {
            return new Override_();
        }
        static instanceOf(obj) {
            return obj.tag === RuleKind_Tags.Override;
        }
    }
    /**
     * Lowest priority user-defined rules.
     */
    class Underride_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RuleKind";
        tag = RuleKind_Tags.Underride;
        constructor() {
            super("RuleKind", "Underride");
        }
        static new() {
            return new Underride_();
        }
        static instanceOf(obj) {
            return obj.tag === RuleKind_Tags.Underride;
        }
    }
    /**
     * Sender-specific rules.
     */
    class Sender_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RuleKind";
        tag = RuleKind_Tags.Sender;
        constructor() {
            super("RuleKind", "Sender");
        }
        static new() {
            return new Sender_();
        }
        static instanceOf(obj) {
            return obj.tag === RuleKind_Tags.Sender;
        }
    }
    /**
     * Room-specific rules.
     */
    class Room_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RuleKind";
        tag = RuleKind_Tags.Room;
        constructor() {
            super("RuleKind", "Room");
        }
        static new() {
            return new Room_();
        }
        static instanceOf(obj) {
            return obj.tag === RuleKind_Tags.Room;
        }
    }
    /**
     * Content-specific rules.
     */
    class Content_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RuleKind";
        tag = RuleKind_Tags.Content;
        constructor() {
            super("RuleKind", "Content");
        }
        static new() {
            return new Content_();
        }
        static instanceOf(obj) {
            return obj.tag === RuleKind_Tags.Content;
        }
    }
    class Custom_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RuleKind";
        tag = RuleKind_Tags.Custom;
        inner;
        constructor(inner) {
            super("RuleKind", "Custom");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Custom_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RuleKind_Tags.Custom;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "RuleKind";
    }
    return Object.freeze({
        instanceOf,
        Override: Override_,
        Underride: Underride_,
        Sender: Sender_,
        Room: Room_,
        Content: Content_,
        Custom: Custom_
    });
})();
// FfiConverter for enum RuleKind
const FfiConverterTypeRuleKind = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new RuleKind.Override();
                case 2: return new RuleKind.Underride();
                case 3: return new RuleKind.Sender();
                case 4: return new RuleKind.Room();
                case 5: return new RuleKind.Content();
                case 6: return new RuleKind.Custom({ value: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case RuleKind_Tags.Override: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case RuleKind_Tags.Underride: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case RuleKind_Tags.Sender: {
                    ordinalConverter.write(3, into);
                    return;
                }
                case RuleKind_Tags.Room: {
                    ordinalConverter.write(4, into);
                    return;
                }
                case RuleKind_Tags.Content: {
                    ordinalConverter.write(5, into);
                    return;
                }
                case RuleKind_Tags.Custom: {
                    ordinalConverter.write(6, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.value, into);
                    return;
                }
                default:
                    // Throwing from here means that RuleKind_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case RuleKind_Tags.Override: {
                    return ordinalConverter.allocationSize(1);
                }
                case RuleKind_Tags.Underride: {
                    return ordinalConverter.allocationSize(2);
                }
                case RuleKind_Tags.Sender: {
                    return ordinalConverter.allocationSize(3);
                }
                case RuleKind_Tags.Room: {
                    return ordinalConverter.allocationSize(4);
                }
                case RuleKind_Tags.Content: {
                    return ordinalConverter.allocationSize(5);
                }
                case RuleKind_Tags.Custom: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(6);
                    size += FfiConverterString.allocationSize(inner.value);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: SecretStorageEncryptionAlgorithm
export var SecretStorageEncryptionAlgorithm_Tags;
(function (SecretStorageEncryptionAlgorithm_Tags) {
    SecretStorageEncryptionAlgorithm_Tags["V1AesHmacSha2"] = "V1AesHmacSha2";
})(SecretStorageEncryptionAlgorithm_Tags || (SecretStorageEncryptionAlgorithm_Tags = {}));
/**
 * An algorithm and its properties, used to encrypt a secret.
 */
export const SecretStorageEncryptionAlgorithm = (() => {
    /**
     * Encrypted using the `m.secret_storage.v1.aes-hmac-sha2` algorithm.
     *
     * Secrets using this method are encrypted using AES-CTR-256 and
     * authenticated using HMAC-SHA-256.
     */
    class V1AesHmacSha2_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "SecretStorageEncryptionAlgorithm";
        tag = SecretStorageEncryptionAlgorithm_Tags.V1AesHmacSha2;
        inner;
        constructor(inner) {
            super("SecretStorageEncryptionAlgorithm", "V1AesHmacSha2");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new V1AesHmacSha2_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === SecretStorageEncryptionAlgorithm_Tags.V1AesHmacSha2;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "SecretStorageEncryptionAlgorithm";
    }
    return Object.freeze({
        instanceOf,
        V1AesHmacSha2: V1AesHmacSha2_
    });
})();
// FfiConverter for enum SecretStorageEncryptionAlgorithm
const FfiConverterTypeSecretStorageEncryptionAlgorithm = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new SecretStorageEncryptionAlgorithm.V1AesHmacSha2({ properties: FfiConverterTypeSecretStorageV1AesHmacSha2Properties.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case SecretStorageEncryptionAlgorithm_Tags.V1AesHmacSha2: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterTypeSecretStorageV1AesHmacSha2Properties.write(inner.properties, into);
                    return;
                }
                default:
                    // Throwing from here means that SecretStorageEncryptionAlgorithm_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case SecretStorageEncryptionAlgorithm_Tags.V1AesHmacSha2: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterTypeSecretStorageV1AesHmacSha2Properties.allocationSize(inner.properties);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: SessionVerificationData
export var SessionVerificationData_Tags;
(function (SessionVerificationData_Tags) {
    SessionVerificationData_Tags["Emojis"] = "Emojis";
    SessionVerificationData_Tags["Decimals"] = "Decimals";
})(SessionVerificationData_Tags || (SessionVerificationData_Tags = {}));
export const SessionVerificationData = (() => {
    class Emojis_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "SessionVerificationData";
        tag = SessionVerificationData_Tags.Emojis;
        inner;
        constructor(inner) {
            super("SessionVerificationData", "Emojis");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Emojis_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === SessionVerificationData_Tags.Emojis;
        }
    }
    class Decimals_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "SessionVerificationData";
        tag = SessionVerificationData_Tags.Decimals;
        inner;
        constructor(inner) {
            super("SessionVerificationData", "Decimals");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Decimals_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === SessionVerificationData_Tags.Decimals;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "SessionVerificationData";
    }
    return Object.freeze({
        instanceOf,
        Emojis: Emojis_,
        Decimals: Decimals_
    });
})();
// FfiConverter for enum SessionVerificationData
const FfiConverterTypeSessionVerificationData = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new SessionVerificationData.Emojis({ emojis: FfiConverterArrayTypeSessionVerificationEmoji.read(from), indices: FfiConverterArrayBuffer.read(from) });
                case 2: return new SessionVerificationData.Decimals({ values: FfiConverterArrayUInt16.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case SessionVerificationData_Tags.Emojis: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterArrayTypeSessionVerificationEmoji.write(inner.emojis, into);
                    FfiConverterArrayBuffer.write(inner.indices, into);
                    return;
                }
                case SessionVerificationData_Tags.Decimals: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterArrayUInt16.write(inner.values, into);
                    return;
                }
                default:
                    // Throwing from here means that SessionVerificationData_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case SessionVerificationData_Tags.Emojis: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterArrayTypeSessionVerificationEmoji.allocationSize(inner.emojis);
                    size += FfiConverterArrayBuffer.allocationSize(inner.indices);
                    return size;
                }
                case SessionVerificationData_Tags.Decimals: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterArrayUInt16.allocationSize(inner.values);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: ShieldState
export var ShieldState_Tags;
(function (ShieldState_Tags) {
    ShieldState_Tags["Red"] = "Red";
    ShieldState_Tags["Grey"] = "Grey";
    ShieldState_Tags["None"] = "None";
})(ShieldState_Tags || (ShieldState_Tags = {}));
/**
 * Recommended decorations for decrypted messages, representing the message's
 * authenticity properties.
 */
export const ShieldState = (() => {
    /**
     * A red shield with a tooltip containing the associated message should be
     * presented.
     */
    class Red_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ShieldState";
        tag = ShieldState_Tags.Red;
        inner;
        constructor(inner) {
            super("ShieldState", "Red");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Red_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === ShieldState_Tags.Red;
        }
    }
    /**
     * A grey shield with a tooltip containing the associated message should be
     * presented.
     */
    class Grey_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ShieldState";
        tag = ShieldState_Tags.Grey;
        inner;
        constructor(inner) {
            super("ShieldState", "Grey");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Grey_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === ShieldState_Tags.Grey;
        }
    }
    /**
     * No shield should be presented.
     */
    class None_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "ShieldState";
        tag = ShieldState_Tags.None;
        constructor() {
            super("ShieldState", "None");
        }
        static new() {
            return new None_();
        }
        static instanceOf(obj) {
            return obj.tag === ShieldState_Tags.None;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "ShieldState";
    }
    return Object.freeze({
        instanceOf,
        Red: Red_,
        Grey: Grey_,
        None: None_
    });
})();
// FfiConverter for enum ShieldState
const FfiConverterTypeShieldState = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new ShieldState.Red({ code: FfiConverterTypeShieldStateCode.read(from), message: FfiConverterString.read(from) });
                case 2: return new ShieldState.Grey({ code: FfiConverterTypeShieldStateCode.read(from), message: FfiConverterString.read(from) });
                case 3: return new ShieldState.None();
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case ShieldState_Tags.Red: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterTypeShieldStateCode.write(inner.code, into);
                    FfiConverterString.write(inner.message, into);
                    return;
                }
                case ShieldState_Tags.Grey: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterTypeShieldStateCode.write(inner.code, into);
                    FfiConverterString.write(inner.message, into);
                    return;
                }
                case ShieldState_Tags.None: {
                    ordinalConverter.write(3, into);
                    return;
                }
                default:
                    // Throwing from here means that ShieldState_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case ShieldState_Tags.Red: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterTypeShieldStateCode.allocationSize(inner.code);
                    size += FfiConverterString.allocationSize(inner.message);
                    return size;
                }
                case ShieldState_Tags.Grey: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterTypeShieldStateCode.allocationSize(inner.code);
                    size += FfiConverterString.allocationSize(inner.message);
                    return size;
                }
                case ShieldState_Tags.None: {
                    return ordinalConverter.allocationSize(3);
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
export var SlidingSyncVersion;
(function (SlidingSyncVersion) {
    SlidingSyncVersion[SlidingSyncVersion["None"] = 0] = "None";
    SlidingSyncVersion[SlidingSyncVersion["Native"] = 1] = "Native";
})(SlidingSyncVersion || (SlidingSyncVersion = {}));
const FfiConverterTypeSlidingSyncVersion = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return SlidingSyncVersion.None;
                case 2: return SlidingSyncVersion.Native;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case SlidingSyncVersion.None: return ordinalConverter.write(1, into);
                case SlidingSyncVersion.Native: return ordinalConverter.write(2, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
export var SlidingSyncVersionBuilder;
(function (SlidingSyncVersionBuilder) {
    SlidingSyncVersionBuilder[SlidingSyncVersionBuilder["None"] = 0] = "None";
    SlidingSyncVersionBuilder[SlidingSyncVersionBuilder["Native"] = 1] = "Native";
    SlidingSyncVersionBuilder[SlidingSyncVersionBuilder["DiscoverNative"] = 2] = "DiscoverNative";
})(SlidingSyncVersionBuilder || (SlidingSyncVersionBuilder = {}));
const FfiConverterTypeSlidingSyncVersionBuilder = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return SlidingSyncVersionBuilder.None;
                case 2: return SlidingSyncVersionBuilder.Native;
                case 3: return SlidingSyncVersionBuilder.DiscoverNative;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case SlidingSyncVersionBuilder.None: return ordinalConverter.write(1, into);
                case SlidingSyncVersionBuilder.Native: return ordinalConverter.write(2, into);
                case SlidingSyncVersionBuilder.DiscoverNative: return ordinalConverter.write(3, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Enum: SpaceListUpdate
export var SpaceListUpdate_Tags;
(function (SpaceListUpdate_Tags) {
    SpaceListUpdate_Tags["Append"] = "Append";
    SpaceListUpdate_Tags["Clear"] = "Clear";
    SpaceListUpdate_Tags["PushFront"] = "PushFront";
    SpaceListUpdate_Tags["PushBack"] = "PushBack";
    SpaceListUpdate_Tags["PopFront"] = "PopFront";
    SpaceListUpdate_Tags["PopBack"] = "PopBack";
    SpaceListUpdate_Tags["Insert"] = "Insert";
    SpaceListUpdate_Tags["Set"] = "Set";
    SpaceListUpdate_Tags["Remove"] = "Remove";
    SpaceListUpdate_Tags["Truncate"] = "Truncate";
    SpaceListUpdate_Tags["Reset"] = "Reset";
})(SpaceListUpdate_Tags || (SpaceListUpdate_Tags = {}));
export const SpaceListUpdate = (() => {
    class Append_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "SpaceListUpdate";
        tag = SpaceListUpdate_Tags.Append;
        inner;
        constructor(inner) {
            super("SpaceListUpdate", "Append");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Append_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === SpaceListUpdate_Tags.Append;
        }
    }
    class Clear_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "SpaceListUpdate";
        tag = SpaceListUpdate_Tags.Clear;
        constructor() {
            super("SpaceListUpdate", "Clear");
        }
        static new() {
            return new Clear_();
        }
        static instanceOf(obj) {
            return obj.tag === SpaceListUpdate_Tags.Clear;
        }
    }
    class PushFront_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "SpaceListUpdate";
        tag = SpaceListUpdate_Tags.PushFront;
        inner;
        constructor(inner) {
            super("SpaceListUpdate", "PushFront");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new PushFront_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === SpaceListUpdate_Tags.PushFront;
        }
    }
    class PushBack_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "SpaceListUpdate";
        tag = SpaceListUpdate_Tags.PushBack;
        inner;
        constructor(inner) {
            super("SpaceListUpdate", "PushBack");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new PushBack_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === SpaceListUpdate_Tags.PushBack;
        }
    }
    class PopFront_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "SpaceListUpdate";
        tag = SpaceListUpdate_Tags.PopFront;
        constructor() {
            super("SpaceListUpdate", "PopFront");
        }
        static new() {
            return new PopFront_();
        }
        static instanceOf(obj) {
            return obj.tag === SpaceListUpdate_Tags.PopFront;
        }
    }
    class PopBack_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "SpaceListUpdate";
        tag = SpaceListUpdate_Tags.PopBack;
        constructor() {
            super("SpaceListUpdate", "PopBack");
        }
        static new() {
            return new PopBack_();
        }
        static instanceOf(obj) {
            return obj.tag === SpaceListUpdate_Tags.PopBack;
        }
    }
    class Insert_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "SpaceListUpdate";
        tag = SpaceListUpdate_Tags.Insert;
        inner;
        constructor(inner) {
            super("SpaceListUpdate", "Insert");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Insert_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === SpaceListUpdate_Tags.Insert;
        }
    }
    class Set_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "SpaceListUpdate";
        tag = SpaceListUpdate_Tags.Set;
        inner;
        constructor(inner) {
            super("SpaceListUpdate", "Set");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Set_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === SpaceListUpdate_Tags.Set;
        }
    }
    class Remove_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "SpaceListUpdate";
        tag = SpaceListUpdate_Tags.Remove;
        inner;
        constructor(inner) {
            super("SpaceListUpdate", "Remove");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Remove_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === SpaceListUpdate_Tags.Remove;
        }
    }
    class Truncate_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "SpaceListUpdate";
        tag = SpaceListUpdate_Tags.Truncate;
        inner;
        constructor(inner) {
            super("SpaceListUpdate", "Truncate");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Truncate_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === SpaceListUpdate_Tags.Truncate;
        }
    }
    class Reset_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "SpaceListUpdate";
        tag = SpaceListUpdate_Tags.Reset;
        inner;
        constructor(inner) {
            super("SpaceListUpdate", "Reset");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Reset_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === SpaceListUpdate_Tags.Reset;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "SpaceListUpdate";
    }
    return Object.freeze({
        instanceOf,
        Append: Append_,
        Clear: Clear_,
        PushFront: PushFront_,
        PushBack: PushBack_,
        PopFront: PopFront_,
        PopBack: PopBack_,
        Insert: Insert_,
        Set: Set_,
        Remove: Remove_,
        Truncate: Truncate_,
        Reset: Reset_
    });
})();
// FfiConverter for enum SpaceListUpdate
const FfiConverterTypeSpaceListUpdate = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new SpaceListUpdate.Append({ values: FfiConverterArrayTypeSpaceRoom.read(from) });
                case 2: return new SpaceListUpdate.Clear();
                case 3: return new SpaceListUpdate.PushFront({ value: FfiConverterTypeSpaceRoom.read(from) });
                case 4: return new SpaceListUpdate.PushBack({ value: FfiConverterTypeSpaceRoom.read(from) });
                case 5: return new SpaceListUpdate.PopFront();
                case 6: return new SpaceListUpdate.PopBack();
                case 7: return new SpaceListUpdate.Insert({ index: FfiConverterUInt32.read(from), value: FfiConverterTypeSpaceRoom.read(from) });
                case 8: return new SpaceListUpdate.Set({ index: FfiConverterUInt32.read(from), value: FfiConverterTypeSpaceRoom.read(from) });
                case 9: return new SpaceListUpdate.Remove({ index: FfiConverterUInt32.read(from) });
                case 10: return new SpaceListUpdate.Truncate({ length: FfiConverterUInt32.read(from) });
                case 11: return new SpaceListUpdate.Reset({ values: FfiConverterArrayTypeSpaceRoom.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case SpaceListUpdate_Tags.Append: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterArrayTypeSpaceRoom.write(inner.values, into);
                    return;
                }
                case SpaceListUpdate_Tags.Clear: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case SpaceListUpdate_Tags.PushFront: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterTypeSpaceRoom.write(inner.value, into);
                    return;
                }
                case SpaceListUpdate_Tags.PushBack: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterTypeSpaceRoom.write(inner.value, into);
                    return;
                }
                case SpaceListUpdate_Tags.PopFront: {
                    ordinalConverter.write(5, into);
                    return;
                }
                case SpaceListUpdate_Tags.PopBack: {
                    ordinalConverter.write(6, into);
                    return;
                }
                case SpaceListUpdate_Tags.Insert: {
                    ordinalConverter.write(7, into);
                    const inner = value.inner;
                    FfiConverterUInt32.write(inner.index, into);
                    FfiConverterTypeSpaceRoom.write(inner.value, into);
                    return;
                }
                case SpaceListUpdate_Tags.Set: {
                    ordinalConverter.write(8, into);
                    const inner = value.inner;
                    FfiConverterUInt32.write(inner.index, into);
                    FfiConverterTypeSpaceRoom.write(inner.value, into);
                    return;
                }
                case SpaceListUpdate_Tags.Remove: {
                    ordinalConverter.write(9, into);
                    const inner = value.inner;
                    FfiConverterUInt32.write(inner.index, into);
                    return;
                }
                case SpaceListUpdate_Tags.Truncate: {
                    ordinalConverter.write(10, into);
                    const inner = value.inner;
                    FfiConverterUInt32.write(inner.length, into);
                    return;
                }
                case SpaceListUpdate_Tags.Reset: {
                    ordinalConverter.write(11, into);
                    const inner = value.inner;
                    FfiConverterArrayTypeSpaceRoom.write(inner.values, into);
                    return;
                }
                default:
                    // Throwing from here means that SpaceListUpdate_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case SpaceListUpdate_Tags.Append: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterArrayTypeSpaceRoom.allocationSize(inner.values);
                    return size;
                }
                case SpaceListUpdate_Tags.Clear: {
                    return ordinalConverter.allocationSize(2);
                }
                case SpaceListUpdate_Tags.PushFront: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterTypeSpaceRoom.allocationSize(inner.value);
                    return size;
                }
                case SpaceListUpdate_Tags.PushBack: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterTypeSpaceRoom.allocationSize(inner.value);
                    return size;
                }
                case SpaceListUpdate_Tags.PopFront: {
                    return ordinalConverter.allocationSize(5);
                }
                case SpaceListUpdate_Tags.PopBack: {
                    return ordinalConverter.allocationSize(6);
                }
                case SpaceListUpdate_Tags.Insert: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(7);
                    size += FfiConverterUInt32.allocationSize(inner.index);
                    size += FfiConverterTypeSpaceRoom.allocationSize(inner.value);
                    return size;
                }
                case SpaceListUpdate_Tags.Set: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(8);
                    size += FfiConverterUInt32.allocationSize(inner.index);
                    size += FfiConverterTypeSpaceRoom.allocationSize(inner.value);
                    return size;
                }
                case SpaceListUpdate_Tags.Remove: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(9);
                    size += FfiConverterUInt32.allocationSize(inner.index);
                    return size;
                }
                case SpaceListUpdate_Tags.Truncate: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(10);
                    size += FfiConverterUInt32.allocationSize(inner.length);
                    return size;
                }
                case SpaceListUpdate_Tags.Reset: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(11);
                    size += FfiConverterArrayTypeSpaceRoom.allocationSize(inner.values);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Flat error type: SsoError
export var SsoError_Tags;
(function (SsoError_Tags) {
    SsoError_Tags["CallbackUrlInvalid"] = "CallbackUrlInvalid";
    SsoError_Tags["LoginWithTokenFailed"] = "LoginWithTokenFailed";
    SsoError_Tags["Generic"] = "Generic";
})(SsoError_Tags || (SsoError_Tags = {}));
export const SsoError = (() => {
    class CallbackUrlInvalid extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "SsoError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 1;
        tag = SsoError_Tags.CallbackUrlInvalid;
        constructor(message) {
            super("SsoError", "CallbackUrlInvalid", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 1);
        }
    }
    class LoginWithTokenFailed extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "SsoError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 2;
        tag = SsoError_Tags.LoginWithTokenFailed;
        constructor(message) {
            super("SsoError", "LoginWithTokenFailed", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 2);
        }
    }
    class Generic extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "SsoError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 3;
        tag = SsoError_Tags.Generic;
        constructor(message) {
            super("SsoError", "Generic", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 3);
        }
    }
    // Utility function which does not rely on instanceof.
    function instanceOf(e) {
        return e[uniffiTypeNameSymbol] === "SsoError";
    }
    return {
        CallbackUrlInvalid,
        LoginWithTokenFailed,
        Generic,
        instanceOf,
    };
})();
const FfiConverterTypeSsoError = (() => {
    const intConverter = FfiConverterInt32;
    class FfiConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (intConverter.read(from)) {
                case 1: return new SsoError.CallbackUrlInvalid(FfiConverterString.read(from));
                case 2: return new SsoError.LoginWithTokenFailed(FfiConverterString.read(from));
                case 3: return new SsoError.Generic(FfiConverterString.read(from));
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            const obj = value;
            const index = obj[variantOrdinalSymbol];
            intConverter.write(index, into);
        }
        allocationSize(value) {
            return intConverter.allocationSize(0);
        }
    }
    return new FfiConverter();
})();
// Enum: StateEventContent
export var StateEventContent_Tags;
(function (StateEventContent_Tags) {
    StateEventContent_Tags["PolicyRuleRoom"] = "PolicyRuleRoom";
    StateEventContent_Tags["PolicyRuleServer"] = "PolicyRuleServer";
    StateEventContent_Tags["PolicyRuleUser"] = "PolicyRuleUser";
    StateEventContent_Tags["RoomAliases"] = "RoomAliases";
    StateEventContent_Tags["RoomAvatar"] = "RoomAvatar";
    StateEventContent_Tags["RoomCanonicalAlias"] = "RoomCanonicalAlias";
    StateEventContent_Tags["RoomCreate"] = "RoomCreate";
    StateEventContent_Tags["RoomEncryption"] = "RoomEncryption";
    StateEventContent_Tags["RoomGuestAccess"] = "RoomGuestAccess";
    StateEventContent_Tags["RoomHistoryVisibility"] = "RoomHistoryVisibility";
    StateEventContent_Tags["RoomJoinRules"] = "RoomJoinRules";
    StateEventContent_Tags["RoomMemberContent"] = "RoomMemberContent";
    StateEventContent_Tags["RoomName"] = "RoomName";
    StateEventContent_Tags["RoomPinnedEvents"] = "RoomPinnedEvents";
    StateEventContent_Tags["RoomPowerLevels"] = "RoomPowerLevels";
    StateEventContent_Tags["RoomServerAcl"] = "RoomServerAcl";
    StateEventContent_Tags["RoomThirdPartyInvite"] = "RoomThirdPartyInvite";
    StateEventContent_Tags["RoomTombstone"] = "RoomTombstone";
    StateEventContent_Tags["RoomTopic"] = "RoomTopic";
    StateEventContent_Tags["SpaceChild"] = "SpaceChild";
    StateEventContent_Tags["SpaceParent"] = "SpaceParent";
})(StateEventContent_Tags || (StateEventContent_Tags = {}));
export const StateEventContent = (() => {
    class PolicyRuleRoom_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "StateEventContent";
        tag = StateEventContent_Tags.PolicyRuleRoom;
        constructor() {
            super("StateEventContent", "PolicyRuleRoom");
        }
        static new() {
            return new PolicyRuleRoom_();
        }
        static instanceOf(obj) {
            return obj.tag === StateEventContent_Tags.PolicyRuleRoom;
        }
    }
    class PolicyRuleServer_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "StateEventContent";
        tag = StateEventContent_Tags.PolicyRuleServer;
        constructor() {
            super("StateEventContent", "PolicyRuleServer");
        }
        static new() {
            return new PolicyRuleServer_();
        }
        static instanceOf(obj) {
            return obj.tag === StateEventContent_Tags.PolicyRuleServer;
        }
    }
    class PolicyRuleUser_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "StateEventContent";
        tag = StateEventContent_Tags.PolicyRuleUser;
        constructor() {
            super("StateEventContent", "PolicyRuleUser");
        }
        static new() {
            return new PolicyRuleUser_();
        }
        static instanceOf(obj) {
            return obj.tag === StateEventContent_Tags.PolicyRuleUser;
        }
    }
    class RoomAliases_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "StateEventContent";
        tag = StateEventContent_Tags.RoomAliases;
        constructor() {
            super("StateEventContent", "RoomAliases");
        }
        static new() {
            return new RoomAliases_();
        }
        static instanceOf(obj) {
            return obj.tag === StateEventContent_Tags.RoomAliases;
        }
    }
    class RoomAvatar_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "StateEventContent";
        tag = StateEventContent_Tags.RoomAvatar;
        constructor() {
            super("StateEventContent", "RoomAvatar");
        }
        static new() {
            return new RoomAvatar_();
        }
        static instanceOf(obj) {
            return obj.tag === StateEventContent_Tags.RoomAvatar;
        }
    }
    class RoomCanonicalAlias_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "StateEventContent";
        tag = StateEventContent_Tags.RoomCanonicalAlias;
        constructor() {
            super("StateEventContent", "RoomCanonicalAlias");
        }
        static new() {
            return new RoomCanonicalAlias_();
        }
        static instanceOf(obj) {
            return obj.tag === StateEventContent_Tags.RoomCanonicalAlias;
        }
    }
    class RoomCreate_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "StateEventContent";
        tag = StateEventContent_Tags.RoomCreate;
        constructor() {
            super("StateEventContent", "RoomCreate");
        }
        static new() {
            return new RoomCreate_();
        }
        static instanceOf(obj) {
            return obj.tag === StateEventContent_Tags.RoomCreate;
        }
    }
    class RoomEncryption_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "StateEventContent";
        tag = StateEventContent_Tags.RoomEncryption;
        constructor() {
            super("StateEventContent", "RoomEncryption");
        }
        static new() {
            return new RoomEncryption_();
        }
        static instanceOf(obj) {
            return obj.tag === StateEventContent_Tags.RoomEncryption;
        }
    }
    class RoomGuestAccess_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "StateEventContent";
        tag = StateEventContent_Tags.RoomGuestAccess;
        constructor() {
            super("StateEventContent", "RoomGuestAccess");
        }
        static new() {
            return new RoomGuestAccess_();
        }
        static instanceOf(obj) {
            return obj.tag === StateEventContent_Tags.RoomGuestAccess;
        }
    }
    class RoomHistoryVisibility_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "StateEventContent";
        tag = StateEventContent_Tags.RoomHistoryVisibility;
        constructor() {
            super("StateEventContent", "RoomHistoryVisibility");
        }
        static new() {
            return new RoomHistoryVisibility_();
        }
        static instanceOf(obj) {
            return obj.tag === StateEventContent_Tags.RoomHistoryVisibility;
        }
    }
    class RoomJoinRules_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "StateEventContent";
        tag = StateEventContent_Tags.RoomJoinRules;
        constructor() {
            super("StateEventContent", "RoomJoinRules");
        }
        static new() {
            return new RoomJoinRules_();
        }
        static instanceOf(obj) {
            return obj.tag === StateEventContent_Tags.RoomJoinRules;
        }
    }
    class RoomMemberContent_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "StateEventContent";
        tag = StateEventContent_Tags.RoomMemberContent;
        inner;
        constructor(inner) {
            super("StateEventContent", "RoomMemberContent");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new RoomMemberContent_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === StateEventContent_Tags.RoomMemberContent;
        }
    }
    class RoomName_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "StateEventContent";
        tag = StateEventContent_Tags.RoomName;
        constructor() {
            super("StateEventContent", "RoomName");
        }
        static new() {
            return new RoomName_();
        }
        static instanceOf(obj) {
            return obj.tag === StateEventContent_Tags.RoomName;
        }
    }
    class RoomPinnedEvents_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "StateEventContent";
        tag = StateEventContent_Tags.RoomPinnedEvents;
        constructor() {
            super("StateEventContent", "RoomPinnedEvents");
        }
        static new() {
            return new RoomPinnedEvents_();
        }
        static instanceOf(obj) {
            return obj.tag === StateEventContent_Tags.RoomPinnedEvents;
        }
    }
    class RoomPowerLevels_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "StateEventContent";
        tag = StateEventContent_Tags.RoomPowerLevels;
        constructor() {
            super("StateEventContent", "RoomPowerLevels");
        }
        static new() {
            return new RoomPowerLevels_();
        }
        static instanceOf(obj) {
            return obj.tag === StateEventContent_Tags.RoomPowerLevels;
        }
    }
    class RoomServerAcl_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "StateEventContent";
        tag = StateEventContent_Tags.RoomServerAcl;
        constructor() {
            super("StateEventContent", "RoomServerAcl");
        }
        static new() {
            return new RoomServerAcl_();
        }
        static instanceOf(obj) {
            return obj.tag === StateEventContent_Tags.RoomServerAcl;
        }
    }
    class RoomThirdPartyInvite_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "StateEventContent";
        tag = StateEventContent_Tags.RoomThirdPartyInvite;
        constructor() {
            super("StateEventContent", "RoomThirdPartyInvite");
        }
        static new() {
            return new RoomThirdPartyInvite_();
        }
        static instanceOf(obj) {
            return obj.tag === StateEventContent_Tags.RoomThirdPartyInvite;
        }
    }
    class RoomTombstone_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "StateEventContent";
        tag = StateEventContent_Tags.RoomTombstone;
        constructor() {
            super("StateEventContent", "RoomTombstone");
        }
        static new() {
            return new RoomTombstone_();
        }
        static instanceOf(obj) {
            return obj.tag === StateEventContent_Tags.RoomTombstone;
        }
    }
    class RoomTopic_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "StateEventContent";
        tag = StateEventContent_Tags.RoomTopic;
        inner;
        constructor(inner) {
            super("StateEventContent", "RoomTopic");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new RoomTopic_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === StateEventContent_Tags.RoomTopic;
        }
    }
    class SpaceChild_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "StateEventContent";
        tag = StateEventContent_Tags.SpaceChild;
        constructor() {
            super("StateEventContent", "SpaceChild");
        }
        static new() {
            return new SpaceChild_();
        }
        static instanceOf(obj) {
            return obj.tag === StateEventContent_Tags.SpaceChild;
        }
    }
    class SpaceParent_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "StateEventContent";
        tag = StateEventContent_Tags.SpaceParent;
        constructor() {
            super("StateEventContent", "SpaceParent");
        }
        static new() {
            return new SpaceParent_();
        }
        static instanceOf(obj) {
            return obj.tag === StateEventContent_Tags.SpaceParent;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "StateEventContent";
    }
    return Object.freeze({
        instanceOf,
        PolicyRuleRoom: PolicyRuleRoom_,
        PolicyRuleServer: PolicyRuleServer_,
        PolicyRuleUser: PolicyRuleUser_,
        RoomAliases: RoomAliases_,
        RoomAvatar: RoomAvatar_,
        RoomCanonicalAlias: RoomCanonicalAlias_,
        RoomCreate: RoomCreate_,
        RoomEncryption: RoomEncryption_,
        RoomGuestAccess: RoomGuestAccess_,
        RoomHistoryVisibility: RoomHistoryVisibility_,
        RoomJoinRules: RoomJoinRules_,
        RoomMemberContent: RoomMemberContent_,
        RoomName: RoomName_,
        RoomPinnedEvents: RoomPinnedEvents_,
        RoomPowerLevels: RoomPowerLevels_,
        RoomServerAcl: RoomServerAcl_,
        RoomThirdPartyInvite: RoomThirdPartyInvite_,
        RoomTombstone: RoomTombstone_,
        RoomTopic: RoomTopic_,
        SpaceChild: SpaceChild_,
        SpaceParent: SpaceParent_
    });
})();
// FfiConverter for enum StateEventContent
const FfiConverterTypeStateEventContent = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new StateEventContent.PolicyRuleRoom();
                case 2: return new StateEventContent.PolicyRuleServer();
                case 3: return new StateEventContent.PolicyRuleUser();
                case 4: return new StateEventContent.RoomAliases();
                case 5: return new StateEventContent.RoomAvatar();
                case 6: return new StateEventContent.RoomCanonicalAlias();
                case 7: return new StateEventContent.RoomCreate();
                case 8: return new StateEventContent.RoomEncryption();
                case 9: return new StateEventContent.RoomGuestAccess();
                case 10: return new StateEventContent.RoomHistoryVisibility();
                case 11: return new StateEventContent.RoomJoinRules();
                case 12: return new StateEventContent.RoomMemberContent({ userId: FfiConverterString.read(from), membershipState: FfiConverterTypeMembershipState.read(from) });
                case 13: return new StateEventContent.RoomName();
                case 14: return new StateEventContent.RoomPinnedEvents();
                case 15: return new StateEventContent.RoomPowerLevels();
                case 16: return new StateEventContent.RoomServerAcl();
                case 17: return new StateEventContent.RoomThirdPartyInvite();
                case 18: return new StateEventContent.RoomTombstone();
                case 19: return new StateEventContent.RoomTopic({ topic: FfiConverterString.read(from) });
                case 20: return new StateEventContent.SpaceChild();
                case 21: return new StateEventContent.SpaceParent();
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case StateEventContent_Tags.PolicyRuleRoom: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case StateEventContent_Tags.PolicyRuleServer: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case StateEventContent_Tags.PolicyRuleUser: {
                    ordinalConverter.write(3, into);
                    return;
                }
                case StateEventContent_Tags.RoomAliases: {
                    ordinalConverter.write(4, into);
                    return;
                }
                case StateEventContent_Tags.RoomAvatar: {
                    ordinalConverter.write(5, into);
                    return;
                }
                case StateEventContent_Tags.RoomCanonicalAlias: {
                    ordinalConverter.write(6, into);
                    return;
                }
                case StateEventContent_Tags.RoomCreate: {
                    ordinalConverter.write(7, into);
                    return;
                }
                case StateEventContent_Tags.RoomEncryption: {
                    ordinalConverter.write(8, into);
                    return;
                }
                case StateEventContent_Tags.RoomGuestAccess: {
                    ordinalConverter.write(9, into);
                    return;
                }
                case StateEventContent_Tags.RoomHistoryVisibility: {
                    ordinalConverter.write(10, into);
                    return;
                }
                case StateEventContent_Tags.RoomJoinRules: {
                    ordinalConverter.write(11, into);
                    return;
                }
                case StateEventContent_Tags.RoomMemberContent: {
                    ordinalConverter.write(12, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.userId, into);
                    FfiConverterTypeMembershipState.write(inner.membershipState, into);
                    return;
                }
                case StateEventContent_Tags.RoomName: {
                    ordinalConverter.write(13, into);
                    return;
                }
                case StateEventContent_Tags.RoomPinnedEvents: {
                    ordinalConverter.write(14, into);
                    return;
                }
                case StateEventContent_Tags.RoomPowerLevels: {
                    ordinalConverter.write(15, into);
                    return;
                }
                case StateEventContent_Tags.RoomServerAcl: {
                    ordinalConverter.write(16, into);
                    return;
                }
                case StateEventContent_Tags.RoomThirdPartyInvite: {
                    ordinalConverter.write(17, into);
                    return;
                }
                case StateEventContent_Tags.RoomTombstone: {
                    ordinalConverter.write(18, into);
                    return;
                }
                case StateEventContent_Tags.RoomTopic: {
                    ordinalConverter.write(19, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.topic, into);
                    return;
                }
                case StateEventContent_Tags.SpaceChild: {
                    ordinalConverter.write(20, into);
                    return;
                }
                case StateEventContent_Tags.SpaceParent: {
                    ordinalConverter.write(21, into);
                    return;
                }
                default:
                    // Throwing from here means that StateEventContent_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case StateEventContent_Tags.PolicyRuleRoom: {
                    return ordinalConverter.allocationSize(1);
                }
                case StateEventContent_Tags.PolicyRuleServer: {
                    return ordinalConverter.allocationSize(2);
                }
                case StateEventContent_Tags.PolicyRuleUser: {
                    return ordinalConverter.allocationSize(3);
                }
                case StateEventContent_Tags.RoomAliases: {
                    return ordinalConverter.allocationSize(4);
                }
                case StateEventContent_Tags.RoomAvatar: {
                    return ordinalConverter.allocationSize(5);
                }
                case StateEventContent_Tags.RoomCanonicalAlias: {
                    return ordinalConverter.allocationSize(6);
                }
                case StateEventContent_Tags.RoomCreate: {
                    return ordinalConverter.allocationSize(7);
                }
                case StateEventContent_Tags.RoomEncryption: {
                    return ordinalConverter.allocationSize(8);
                }
                case StateEventContent_Tags.RoomGuestAccess: {
                    return ordinalConverter.allocationSize(9);
                }
                case StateEventContent_Tags.RoomHistoryVisibility: {
                    return ordinalConverter.allocationSize(10);
                }
                case StateEventContent_Tags.RoomJoinRules: {
                    return ordinalConverter.allocationSize(11);
                }
                case StateEventContent_Tags.RoomMemberContent: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(12);
                    size += FfiConverterString.allocationSize(inner.userId);
                    size += FfiConverterTypeMembershipState.allocationSize(inner.membershipState);
                    return size;
                }
                case StateEventContent_Tags.RoomName: {
                    return ordinalConverter.allocationSize(13);
                }
                case StateEventContent_Tags.RoomPinnedEvents: {
                    return ordinalConverter.allocationSize(14);
                }
                case StateEventContent_Tags.RoomPowerLevels: {
                    return ordinalConverter.allocationSize(15);
                }
                case StateEventContent_Tags.RoomServerAcl: {
                    return ordinalConverter.allocationSize(16);
                }
                case StateEventContent_Tags.RoomThirdPartyInvite: {
                    return ordinalConverter.allocationSize(17);
                }
                case StateEventContent_Tags.RoomTombstone: {
                    return ordinalConverter.allocationSize(18);
                }
                case StateEventContent_Tags.RoomTopic: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(19);
                    size += FfiConverterString.allocationSize(inner.topic);
                    return size;
                }
                case StateEventContent_Tags.SpaceChild: {
                    return ordinalConverter.allocationSize(20);
                }
                case StateEventContent_Tags.SpaceParent: {
                    return ordinalConverter.allocationSize(21);
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
export var StateEventType;
(function (StateEventType) {
    StateEventType[StateEventType["CallMember"] = 0] = "CallMember";
    StateEventType[StateEventType["PolicyRuleRoom"] = 1] = "PolicyRuleRoom";
    StateEventType[StateEventType["PolicyRuleServer"] = 2] = "PolicyRuleServer";
    StateEventType[StateEventType["PolicyRuleUser"] = 3] = "PolicyRuleUser";
    StateEventType[StateEventType["RoomAliases"] = 4] = "RoomAliases";
    StateEventType[StateEventType["RoomAvatar"] = 5] = "RoomAvatar";
    StateEventType[StateEventType["RoomCanonicalAlias"] = 6] = "RoomCanonicalAlias";
    StateEventType[StateEventType["RoomCreate"] = 7] = "RoomCreate";
    StateEventType[StateEventType["RoomEncryption"] = 8] = "RoomEncryption";
    StateEventType[StateEventType["RoomGuestAccess"] = 9] = "RoomGuestAccess";
    StateEventType[StateEventType["RoomHistoryVisibility"] = 10] = "RoomHistoryVisibility";
    StateEventType[StateEventType["RoomJoinRules"] = 11] = "RoomJoinRules";
    StateEventType[StateEventType["RoomMemberEvent"] = 12] = "RoomMemberEvent";
    StateEventType[StateEventType["RoomName"] = 13] = "RoomName";
    StateEventType[StateEventType["RoomPinnedEvents"] = 14] = "RoomPinnedEvents";
    StateEventType[StateEventType["RoomPowerLevels"] = 15] = "RoomPowerLevels";
    StateEventType[StateEventType["RoomServerAcl"] = 16] = "RoomServerAcl";
    StateEventType[StateEventType["RoomThirdPartyInvite"] = 17] = "RoomThirdPartyInvite";
    StateEventType[StateEventType["RoomTombstone"] = 18] = "RoomTombstone";
    StateEventType[StateEventType["RoomTopic"] = 19] = "RoomTopic";
    StateEventType[StateEventType["SpaceChild"] = 20] = "SpaceChild";
    StateEventType[StateEventType["SpaceParent"] = 21] = "SpaceParent";
})(StateEventType || (StateEventType = {}));
const FfiConverterTypeStateEventType = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return StateEventType.CallMember;
                case 2: return StateEventType.PolicyRuleRoom;
                case 3: return StateEventType.PolicyRuleServer;
                case 4: return StateEventType.PolicyRuleUser;
                case 5: return StateEventType.RoomAliases;
                case 6: return StateEventType.RoomAvatar;
                case 7: return StateEventType.RoomCanonicalAlias;
                case 8: return StateEventType.RoomCreate;
                case 9: return StateEventType.RoomEncryption;
                case 10: return StateEventType.RoomGuestAccess;
                case 11: return StateEventType.RoomHistoryVisibility;
                case 12: return StateEventType.RoomJoinRules;
                case 13: return StateEventType.RoomMemberEvent;
                case 14: return StateEventType.RoomName;
                case 15: return StateEventType.RoomPinnedEvents;
                case 16: return StateEventType.RoomPowerLevels;
                case 17: return StateEventType.RoomServerAcl;
                case 18: return StateEventType.RoomThirdPartyInvite;
                case 19: return StateEventType.RoomTombstone;
                case 20: return StateEventType.RoomTopic;
                case 21: return StateEventType.SpaceChild;
                case 22: return StateEventType.SpaceParent;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case StateEventType.CallMember: return ordinalConverter.write(1, into);
                case StateEventType.PolicyRuleRoom: return ordinalConverter.write(2, into);
                case StateEventType.PolicyRuleServer: return ordinalConverter.write(3, into);
                case StateEventType.PolicyRuleUser: return ordinalConverter.write(4, into);
                case StateEventType.RoomAliases: return ordinalConverter.write(5, into);
                case StateEventType.RoomAvatar: return ordinalConverter.write(6, into);
                case StateEventType.RoomCanonicalAlias: return ordinalConverter.write(7, into);
                case StateEventType.RoomCreate: return ordinalConverter.write(8, into);
                case StateEventType.RoomEncryption: return ordinalConverter.write(9, into);
                case StateEventType.RoomGuestAccess: return ordinalConverter.write(10, into);
                case StateEventType.RoomHistoryVisibility: return ordinalConverter.write(11, into);
                case StateEventType.RoomJoinRules: return ordinalConverter.write(12, into);
                case StateEventType.RoomMemberEvent: return ordinalConverter.write(13, into);
                case StateEventType.RoomName: return ordinalConverter.write(14, into);
                case StateEventType.RoomPinnedEvents: return ordinalConverter.write(15, into);
                case StateEventType.RoomPowerLevels: return ordinalConverter.write(16, into);
                case StateEventType.RoomServerAcl: return ordinalConverter.write(17, into);
                case StateEventType.RoomThirdPartyInvite: return ordinalConverter.write(18, into);
                case StateEventType.RoomTombstone: return ordinalConverter.write(19, into);
                case StateEventType.RoomTopic: return ordinalConverter.write(20, into);
                case StateEventType.SpaceChild: return ordinalConverter.write(21, into);
                case StateEventType.SpaceParent: return ordinalConverter.write(22, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Flat error type: SteadyStateError
export var SteadyStateError_Tags;
(function (SteadyStateError_Tags) {
    SteadyStateError_Tags["BackupDisabled"] = "BackupDisabled";
    SteadyStateError_Tags["Connection"] = "Connection";
    SteadyStateError_Tags["Lagged"] = "Lagged";
})(SteadyStateError_Tags || (SteadyStateError_Tags = {}));
export const SteadyStateError = (() => {
    class BackupDisabled extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "SteadyStateError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 1;
        tag = SteadyStateError_Tags.BackupDisabled;
        constructor(message) {
            super("SteadyStateError", "BackupDisabled", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 1);
        }
    }
    class Connection extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "SteadyStateError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 2;
        tag = SteadyStateError_Tags.Connection;
        constructor(message) {
            super("SteadyStateError", "Connection", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 2);
        }
    }
    class Lagged extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "SteadyStateError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 3;
        tag = SteadyStateError_Tags.Lagged;
        constructor(message) {
            super("SteadyStateError", "Lagged", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 3);
        }
    }
    // Utility function which does not rely on instanceof.
    function instanceOf(e) {
        return e[uniffiTypeNameSymbol] === "SteadyStateError";
    }
    return {
        BackupDisabled,
        Connection,
        Lagged,
        instanceOf,
    };
})();
const FfiConverterTypeSteadyStateError = (() => {
    const intConverter = FfiConverterInt32;
    class FfiConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (intConverter.read(from)) {
                case 1: return new SteadyStateError.BackupDisabled(FfiConverterString.read(from));
                case 2: return new SteadyStateError.Connection(FfiConverterString.read(from));
                case 3: return new SteadyStateError.Lagged(FfiConverterString.read(from));
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            const obj = value;
            const index = obj[variantOrdinalSymbol];
            intConverter.write(index, into);
        }
        allocationSize(value) {
            return intConverter.allocationSize(0);
        }
    }
    return new FfiConverter();
})();
export var SyncServiceState;
(function (SyncServiceState) {
    SyncServiceState[SyncServiceState["Idle"] = 0] = "Idle";
    SyncServiceState[SyncServiceState["Running"] = 1] = "Running";
    SyncServiceState[SyncServiceState["Terminated"] = 2] = "Terminated";
    SyncServiceState[SyncServiceState["Error"] = 3] = "Error";
    SyncServiceState[SyncServiceState["Offline"] = 4] = "Offline";
})(SyncServiceState || (SyncServiceState = {}));
const FfiConverterTypeSyncServiceState = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return SyncServiceState.Idle;
                case 2: return SyncServiceState.Running;
                case 3: return SyncServiceState.Terminated;
                case 4: return SyncServiceState.Error;
                case 5: return SyncServiceState.Offline;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case SyncServiceState.Idle: return ordinalConverter.write(1, into);
                case SyncServiceState.Running: return ordinalConverter.write(2, into);
                case SyncServiceState.Terminated: return ordinalConverter.write(3, into);
                case SyncServiceState.Error: return ordinalConverter.write(4, into);
                case SyncServiceState.Offline: return ordinalConverter.write(5, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Enum: TagName
export var TagName_Tags;
(function (TagName_Tags) {
    TagName_Tags["Favorite"] = "Favorite";
    TagName_Tags["LowPriority"] = "LowPriority";
    TagName_Tags["ServerNotice"] = "ServerNotice";
    TagName_Tags["User"] = "User";
})(TagName_Tags || (TagName_Tags = {}));
/**
 * The name of a tag.
 */
export const TagName = (() => {
    /**
     * `m.favourite`: The user's favorite rooms.
     */
    class Favorite_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TagName";
        tag = TagName_Tags.Favorite;
        constructor() {
            super("TagName", "Favorite");
        }
        static new() {
            return new Favorite_();
        }
        static instanceOf(obj) {
            return obj.tag === TagName_Tags.Favorite;
        }
    }
    /**
     * `m.lowpriority`: These should be shown with lower precedence than
     * others.
     */
    class LowPriority_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TagName";
        tag = TagName_Tags.LowPriority;
        constructor() {
            super("TagName", "LowPriority");
        }
        static new() {
            return new LowPriority_();
        }
        static instanceOf(obj) {
            return obj.tag === TagName_Tags.LowPriority;
        }
    }
    /**
     * `m.server_notice`: Used to identify
     */
    class ServerNotice_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TagName";
        tag = TagName_Tags.ServerNotice;
        constructor() {
            super("TagName", "ServerNotice");
        }
        static new() {
            return new ServerNotice_();
        }
        static instanceOf(obj) {
            return obj.tag === TagName_Tags.ServerNotice;
        }
    }
    /**
     * `u.*`: User-defined tag
     */
    class User_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TagName";
        tag = TagName_Tags.User;
        inner;
        constructor(inner) {
            super("TagName", "User");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new User_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === TagName_Tags.User;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "TagName";
    }
    return Object.freeze({
        instanceOf,
        Favorite: Favorite_,
        LowPriority: LowPriority_,
        ServerNotice: ServerNotice_,
        User: User_
    });
})();
// FfiConverter for enum TagName
const FfiConverterTypeTagName = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new TagName.Favorite();
                case 2: return new TagName.LowPriority();
                case 3: return new TagName.ServerNotice();
                case 4: return new TagName.User({ name: FfiConverterTypeUserTagName.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case TagName_Tags.Favorite: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case TagName_Tags.LowPriority: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case TagName_Tags.ServerNotice: {
                    ordinalConverter.write(3, into);
                    return;
                }
                case TagName_Tags.User: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterTypeUserTagName.write(inner.name, into);
                    return;
                }
                default:
                    // Throwing from here means that TagName_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case TagName_Tags.Favorite: {
                    return ordinalConverter.allocationSize(1);
                }
                case TagName_Tags.LowPriority: {
                    return ordinalConverter.allocationSize(2);
                }
                case TagName_Tags.ServerNotice: {
                    return ordinalConverter.allocationSize(3);
                }
                case TagName_Tags.User: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterTypeUserTagName.allocationSize(inner.name);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: TimelineDiff
export var TimelineDiff_Tags;
(function (TimelineDiff_Tags) {
    TimelineDiff_Tags["Append"] = "Append";
    TimelineDiff_Tags["Clear"] = "Clear";
    TimelineDiff_Tags["PushFront"] = "PushFront";
    TimelineDiff_Tags["PushBack"] = "PushBack";
    TimelineDiff_Tags["PopFront"] = "PopFront";
    TimelineDiff_Tags["PopBack"] = "PopBack";
    TimelineDiff_Tags["Insert"] = "Insert";
    TimelineDiff_Tags["Set"] = "Set";
    TimelineDiff_Tags["Remove"] = "Remove";
    TimelineDiff_Tags["Truncate"] = "Truncate";
    TimelineDiff_Tags["Reset"] = "Reset";
})(TimelineDiff_Tags || (TimelineDiff_Tags = {}));
export const TimelineDiff = (() => {
    class Append_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineDiff";
        tag = TimelineDiff_Tags.Append;
        inner;
        constructor(inner) {
            super("TimelineDiff", "Append");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Append_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === TimelineDiff_Tags.Append;
        }
    }
    class Clear_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineDiff";
        tag = TimelineDiff_Tags.Clear;
        constructor() {
            super("TimelineDiff", "Clear");
        }
        static new() {
            return new Clear_();
        }
        static instanceOf(obj) {
            return obj.tag === TimelineDiff_Tags.Clear;
        }
    }
    class PushFront_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineDiff";
        tag = TimelineDiff_Tags.PushFront;
        inner;
        constructor(inner) {
            super("TimelineDiff", "PushFront");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new PushFront_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === TimelineDiff_Tags.PushFront;
        }
    }
    class PushBack_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineDiff";
        tag = TimelineDiff_Tags.PushBack;
        inner;
        constructor(inner) {
            super("TimelineDiff", "PushBack");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new PushBack_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === TimelineDiff_Tags.PushBack;
        }
    }
    class PopFront_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineDiff";
        tag = TimelineDiff_Tags.PopFront;
        constructor() {
            super("TimelineDiff", "PopFront");
        }
        static new() {
            return new PopFront_();
        }
        static instanceOf(obj) {
            return obj.tag === TimelineDiff_Tags.PopFront;
        }
    }
    class PopBack_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineDiff";
        tag = TimelineDiff_Tags.PopBack;
        constructor() {
            super("TimelineDiff", "PopBack");
        }
        static new() {
            return new PopBack_();
        }
        static instanceOf(obj) {
            return obj.tag === TimelineDiff_Tags.PopBack;
        }
    }
    class Insert_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineDiff";
        tag = TimelineDiff_Tags.Insert;
        inner;
        constructor(inner) {
            super("TimelineDiff", "Insert");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Insert_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === TimelineDiff_Tags.Insert;
        }
    }
    class Set_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineDiff";
        tag = TimelineDiff_Tags.Set;
        inner;
        constructor(inner) {
            super("TimelineDiff", "Set");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Set_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === TimelineDiff_Tags.Set;
        }
    }
    class Remove_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineDiff";
        tag = TimelineDiff_Tags.Remove;
        inner;
        constructor(inner) {
            super("TimelineDiff", "Remove");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Remove_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === TimelineDiff_Tags.Remove;
        }
    }
    class Truncate_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineDiff";
        tag = TimelineDiff_Tags.Truncate;
        inner;
        constructor(inner) {
            super("TimelineDiff", "Truncate");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Truncate_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === TimelineDiff_Tags.Truncate;
        }
    }
    class Reset_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineDiff";
        tag = TimelineDiff_Tags.Reset;
        inner;
        constructor(inner) {
            super("TimelineDiff", "Reset");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Reset_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === TimelineDiff_Tags.Reset;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "TimelineDiff";
    }
    return Object.freeze({
        instanceOf,
        Append: Append_,
        Clear: Clear_,
        PushFront: PushFront_,
        PushBack: PushBack_,
        PopFront: PopFront_,
        PopBack: PopBack_,
        Insert: Insert_,
        Set: Set_,
        Remove: Remove_,
        Truncate: Truncate_,
        Reset: Reset_
    });
})();
// FfiConverter for enum TimelineDiff
const FfiConverterTypeTimelineDiff = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new TimelineDiff.Append({ values: FfiConverterArrayTypeTimelineItem.read(from) });
                case 2: return new TimelineDiff.Clear();
                case 3: return new TimelineDiff.PushFront({ value: FfiConverterTypeTimelineItem.read(from) });
                case 4: return new TimelineDiff.PushBack({ value: FfiConverterTypeTimelineItem.read(from) });
                case 5: return new TimelineDiff.PopFront();
                case 6: return new TimelineDiff.PopBack();
                case 7: return new TimelineDiff.Insert({ index: FfiConverterUInt32.read(from), value: FfiConverterTypeTimelineItem.read(from) });
                case 8: return new TimelineDiff.Set({ index: FfiConverterUInt32.read(from), value: FfiConverterTypeTimelineItem.read(from) });
                case 9: return new TimelineDiff.Remove({ index: FfiConverterUInt32.read(from) });
                case 10: return new TimelineDiff.Truncate({ length: FfiConverterUInt32.read(from) });
                case 11: return new TimelineDiff.Reset({ values: FfiConverterArrayTypeTimelineItem.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case TimelineDiff_Tags.Append: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterArrayTypeTimelineItem.write(inner.values, into);
                    return;
                }
                case TimelineDiff_Tags.Clear: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case TimelineDiff_Tags.PushFront: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterTypeTimelineItem.write(inner.value, into);
                    return;
                }
                case TimelineDiff_Tags.PushBack: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterTypeTimelineItem.write(inner.value, into);
                    return;
                }
                case TimelineDiff_Tags.PopFront: {
                    ordinalConverter.write(5, into);
                    return;
                }
                case TimelineDiff_Tags.PopBack: {
                    ordinalConverter.write(6, into);
                    return;
                }
                case TimelineDiff_Tags.Insert: {
                    ordinalConverter.write(7, into);
                    const inner = value.inner;
                    FfiConverterUInt32.write(inner.index, into);
                    FfiConverterTypeTimelineItem.write(inner.value, into);
                    return;
                }
                case TimelineDiff_Tags.Set: {
                    ordinalConverter.write(8, into);
                    const inner = value.inner;
                    FfiConverterUInt32.write(inner.index, into);
                    FfiConverterTypeTimelineItem.write(inner.value, into);
                    return;
                }
                case TimelineDiff_Tags.Remove: {
                    ordinalConverter.write(9, into);
                    const inner = value.inner;
                    FfiConverterUInt32.write(inner.index, into);
                    return;
                }
                case TimelineDiff_Tags.Truncate: {
                    ordinalConverter.write(10, into);
                    const inner = value.inner;
                    FfiConverterUInt32.write(inner.length, into);
                    return;
                }
                case TimelineDiff_Tags.Reset: {
                    ordinalConverter.write(11, into);
                    const inner = value.inner;
                    FfiConverterArrayTypeTimelineItem.write(inner.values, into);
                    return;
                }
                default:
                    // Throwing from here means that TimelineDiff_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case TimelineDiff_Tags.Append: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterArrayTypeTimelineItem.allocationSize(inner.values);
                    return size;
                }
                case TimelineDiff_Tags.Clear: {
                    return ordinalConverter.allocationSize(2);
                }
                case TimelineDiff_Tags.PushFront: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterTypeTimelineItem.allocationSize(inner.value);
                    return size;
                }
                case TimelineDiff_Tags.PushBack: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterTypeTimelineItem.allocationSize(inner.value);
                    return size;
                }
                case TimelineDiff_Tags.PopFront: {
                    return ordinalConverter.allocationSize(5);
                }
                case TimelineDiff_Tags.PopBack: {
                    return ordinalConverter.allocationSize(6);
                }
                case TimelineDiff_Tags.Insert: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(7);
                    size += FfiConverterUInt32.allocationSize(inner.index);
                    size += FfiConverterTypeTimelineItem.allocationSize(inner.value);
                    return size;
                }
                case TimelineDiff_Tags.Set: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(8);
                    size += FfiConverterUInt32.allocationSize(inner.index);
                    size += FfiConverterTypeTimelineItem.allocationSize(inner.value);
                    return size;
                }
                case TimelineDiff_Tags.Remove: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(9);
                    size += FfiConverterUInt32.allocationSize(inner.index);
                    return size;
                }
                case TimelineDiff_Tags.Truncate: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(10);
                    size += FfiConverterUInt32.allocationSize(inner.length);
                    return size;
                }
                case TimelineDiff_Tags.Reset: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(11);
                    size += FfiConverterArrayTypeTimelineItem.allocationSize(inner.values);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: TimelineEventType
export var TimelineEventType_Tags;
(function (TimelineEventType_Tags) {
    TimelineEventType_Tags["MessageLike"] = "MessageLike";
    TimelineEventType_Tags["State"] = "State";
})(TimelineEventType_Tags || (TimelineEventType_Tags = {}));
export const TimelineEventType = (() => {
    class MessageLike_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineEventType";
        tag = TimelineEventType_Tags.MessageLike;
        inner;
        constructor(inner) {
            super("TimelineEventType", "MessageLike");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new MessageLike_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === TimelineEventType_Tags.MessageLike;
        }
    }
    class State_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineEventType";
        tag = TimelineEventType_Tags.State;
        inner;
        constructor(inner) {
            super("TimelineEventType", "State");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new State_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === TimelineEventType_Tags.State;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "TimelineEventType";
    }
    return Object.freeze({
        instanceOf,
        MessageLike: MessageLike_,
        State: State_
    });
})();
// FfiConverter for enum TimelineEventType
const FfiConverterTypeTimelineEventType = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new TimelineEventType.MessageLike({ content: FfiConverterTypeMessageLikeEventContent.read(from) });
                case 2: return new TimelineEventType.State({ content: FfiConverterTypeStateEventContent.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case TimelineEventType_Tags.MessageLike: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterTypeMessageLikeEventContent.write(inner.content, into);
                    return;
                }
                case TimelineEventType_Tags.State: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterTypeStateEventContent.write(inner.content, into);
                    return;
                }
                default:
                    // Throwing from here means that TimelineEventType_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case TimelineEventType_Tags.MessageLike: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterTypeMessageLikeEventContent.allocationSize(inner.content);
                    return size;
                }
                case TimelineEventType_Tags.State: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterTypeStateEventContent.allocationSize(inner.content);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: TimelineFilter
export var TimelineFilter_Tags;
(function (TimelineFilter_Tags) {
    TimelineFilter_Tags["All"] = "All";
    TimelineFilter_Tags["OnlyMessage"] = "OnlyMessage";
    TimelineFilter_Tags["EventTypeFilter"] = "EventTypeFilter";
})(TimelineFilter_Tags || (TimelineFilter_Tags = {}));
export const TimelineFilter = (() => {
    /**
     * Show all the events in the timeline, independent of their type.
     */
    class All_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineFilter";
        tag = TimelineFilter_Tags.All;
        constructor() {
            super("TimelineFilter", "All");
        }
        static new() {
            return new All_();
        }
        static instanceOf(obj) {
            return obj.tag === TimelineFilter_Tags.All;
        }
    }
    /**
     * Show only `m.room.messages` of the given room message types.
     */
    class OnlyMessage_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineFilter";
        tag = TimelineFilter_Tags.OnlyMessage;
        inner;
        constructor(inner) {
            super("TimelineFilter", "OnlyMessage");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new OnlyMessage_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === TimelineFilter_Tags.OnlyMessage;
        }
    }
    /**
     * Show only events which match this filter.
     */
    class EventTypeFilter_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineFilter";
        tag = TimelineFilter_Tags.EventTypeFilter;
        inner;
        constructor(inner) {
            super("TimelineFilter", "EventTypeFilter");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new EventTypeFilter_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === TimelineFilter_Tags.EventTypeFilter;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "TimelineFilter";
    }
    return Object.freeze({
        instanceOf,
        All: All_,
        OnlyMessage: OnlyMessage_,
        EventTypeFilter: EventTypeFilter_
    });
})();
// FfiConverter for enum TimelineFilter
const FfiConverterTypeTimelineFilter = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new TimelineFilter.All();
                case 2: return new TimelineFilter.OnlyMessage({ types: FfiConverterArrayTypeRoomMessageEventMessageType.read(from) });
                case 3: return new TimelineFilter.EventTypeFilter({ filter: FfiConverterTypeTimelineEventTypeFilter.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case TimelineFilter_Tags.All: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case TimelineFilter_Tags.OnlyMessage: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterArrayTypeRoomMessageEventMessageType.write(inner.types, into);
                    return;
                }
                case TimelineFilter_Tags.EventTypeFilter: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterTypeTimelineEventTypeFilter.write(inner.filter, into);
                    return;
                }
                default:
                    // Throwing from here means that TimelineFilter_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case TimelineFilter_Tags.All: {
                    return ordinalConverter.allocationSize(1);
                }
                case TimelineFilter_Tags.OnlyMessage: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterArrayTypeRoomMessageEventMessageType.allocationSize(inner.types);
                    return size;
                }
                case TimelineFilter_Tags.EventTypeFilter: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterTypeTimelineEventTypeFilter.allocationSize(inner.filter);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: TimelineFocus
export var TimelineFocus_Tags;
(function (TimelineFocus_Tags) {
    TimelineFocus_Tags["Live"] = "Live";
    TimelineFocus_Tags["Event"] = "Event";
    TimelineFocus_Tags["Thread"] = "Thread";
    TimelineFocus_Tags["PinnedEvents"] = "PinnedEvents";
})(TimelineFocus_Tags || (TimelineFocus_Tags = {}));
export const TimelineFocus = (() => {
    class Live_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineFocus";
        tag = TimelineFocus_Tags.Live;
        inner;
        constructor(inner) {
            super("TimelineFocus", "Live");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Live_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === TimelineFocus_Tags.Live;
        }
    }
    class Event_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineFocus";
        tag = TimelineFocus_Tags.Event;
        inner;
        constructor(inner) {
            super("TimelineFocus", "Event");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Event_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === TimelineFocus_Tags.Event;
        }
    }
    class Thread_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineFocus";
        tag = TimelineFocus_Tags.Thread;
        inner;
        constructor(inner) {
            super("TimelineFocus", "Thread");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Thread_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === TimelineFocus_Tags.Thread;
        }
    }
    class PinnedEvents_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineFocus";
        tag = TimelineFocus_Tags.PinnedEvents;
        inner;
        constructor(inner) {
            super("TimelineFocus", "PinnedEvents");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new PinnedEvents_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === TimelineFocus_Tags.PinnedEvents;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "TimelineFocus";
    }
    return Object.freeze({
        instanceOf,
        Live: Live_,
        Event: Event_,
        Thread: Thread_,
        PinnedEvents: PinnedEvents_
    });
})();
// FfiConverter for enum TimelineFocus
const FfiConverterTypeTimelineFocus = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new TimelineFocus.Live({ hideThreadedEvents: FfiConverterBool.read(from) });
                case 2: return new TimelineFocus.Event({ eventId: FfiConverterString.read(from), numContextEvents: FfiConverterUInt16.read(from), hideThreadedEvents: FfiConverterBool.read(from) });
                case 3: return new TimelineFocus.Thread({ rootEventId: FfiConverterString.read(from) });
                case 4: return new TimelineFocus.PinnedEvents({ maxEventsToLoad: FfiConverterUInt16.read(from), maxConcurrentRequests: FfiConverterUInt16.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case TimelineFocus_Tags.Live: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterBool.write(inner.hideThreadedEvents, into);
                    return;
                }
                case TimelineFocus_Tags.Event: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.eventId, into);
                    FfiConverterUInt16.write(inner.numContextEvents, into);
                    FfiConverterBool.write(inner.hideThreadedEvents, into);
                    return;
                }
                case TimelineFocus_Tags.Thread: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.rootEventId, into);
                    return;
                }
                case TimelineFocus_Tags.PinnedEvents: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterUInt16.write(inner.maxEventsToLoad, into);
                    FfiConverterUInt16.write(inner.maxConcurrentRequests, into);
                    return;
                }
                default:
                    // Throwing from here means that TimelineFocus_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case TimelineFocus_Tags.Live: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterBool.allocationSize(inner.hideThreadedEvents);
                    return size;
                }
                case TimelineFocus_Tags.Event: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterString.allocationSize(inner.eventId);
                    size += FfiConverterUInt16.allocationSize(inner.numContextEvents);
                    size += FfiConverterBool.allocationSize(inner.hideThreadedEvents);
                    return size;
                }
                case TimelineFocus_Tags.Thread: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterString.allocationSize(inner.rootEventId);
                    return size;
                }
                case TimelineFocus_Tags.PinnedEvents: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterUInt16.allocationSize(inner.maxEventsToLoad);
                    size += FfiConverterUInt16.allocationSize(inner.maxConcurrentRequests);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: TimelineItemContent
export var TimelineItemContent_Tags;
(function (TimelineItemContent_Tags) {
    TimelineItemContent_Tags["MsgLike"] = "MsgLike";
    TimelineItemContent_Tags["CallInvite"] = "CallInvite";
    TimelineItemContent_Tags["RtcNotification"] = "RtcNotification";
    TimelineItemContent_Tags["RoomMembership"] = "RoomMembership";
    TimelineItemContent_Tags["ProfileChange"] = "ProfileChange";
    TimelineItemContent_Tags["State"] = "State";
    TimelineItemContent_Tags["FailedToParseMessageLike"] = "FailedToParseMessageLike";
    TimelineItemContent_Tags["FailedToParseState"] = "FailedToParseState";
})(TimelineItemContent_Tags || (TimelineItemContent_Tags = {}));
export const TimelineItemContent = (() => {
    class MsgLike_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineItemContent";
        tag = TimelineItemContent_Tags.MsgLike;
        inner;
        constructor(inner) {
            super("TimelineItemContent", "MsgLike");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new MsgLike_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === TimelineItemContent_Tags.MsgLike;
        }
    }
    class CallInvite_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineItemContent";
        tag = TimelineItemContent_Tags.CallInvite;
        constructor() {
            super("TimelineItemContent", "CallInvite");
        }
        static new() {
            return new CallInvite_();
        }
        static instanceOf(obj) {
            return obj.tag === TimelineItemContent_Tags.CallInvite;
        }
    }
    class RtcNotification_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineItemContent";
        tag = TimelineItemContent_Tags.RtcNotification;
        constructor() {
            super("TimelineItemContent", "RtcNotification");
        }
        static new() {
            return new RtcNotification_();
        }
        static instanceOf(obj) {
            return obj.tag === TimelineItemContent_Tags.RtcNotification;
        }
    }
    class RoomMembership_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineItemContent";
        tag = TimelineItemContent_Tags.RoomMembership;
        inner;
        constructor(inner) {
            super("TimelineItemContent", "RoomMembership");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new RoomMembership_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === TimelineItemContent_Tags.RoomMembership;
        }
    }
    class ProfileChange_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineItemContent";
        tag = TimelineItemContent_Tags.ProfileChange;
        inner;
        constructor(inner) {
            super("TimelineItemContent", "ProfileChange");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new ProfileChange_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === TimelineItemContent_Tags.ProfileChange;
        }
    }
    class State_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineItemContent";
        tag = TimelineItemContent_Tags.State;
        inner;
        constructor(inner) {
            super("TimelineItemContent", "State");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new State_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === TimelineItemContent_Tags.State;
        }
    }
    class FailedToParseMessageLike_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineItemContent";
        tag = TimelineItemContent_Tags.FailedToParseMessageLike;
        inner;
        constructor(inner) {
            super("TimelineItemContent", "FailedToParseMessageLike");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new FailedToParseMessageLike_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === TimelineItemContent_Tags.FailedToParseMessageLike;
        }
    }
    class FailedToParseState_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "TimelineItemContent";
        tag = TimelineItemContent_Tags.FailedToParseState;
        inner;
        constructor(inner) {
            super("TimelineItemContent", "FailedToParseState");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new FailedToParseState_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === TimelineItemContent_Tags.FailedToParseState;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "TimelineItemContent";
    }
    return Object.freeze({
        instanceOf,
        MsgLike: MsgLike_,
        CallInvite: CallInvite_,
        RtcNotification: RtcNotification_,
        RoomMembership: RoomMembership_,
        ProfileChange: ProfileChange_,
        State: State_,
        FailedToParseMessageLike: FailedToParseMessageLike_,
        FailedToParseState: FailedToParseState_
    });
})();
// FfiConverter for enum TimelineItemContent
const FfiConverterTypeTimelineItemContent = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new TimelineItemContent.MsgLike({ content: FfiConverterTypeMsgLikeContent.read(from) });
                case 2: return new TimelineItemContent.CallInvite();
                case 3: return new TimelineItemContent.RtcNotification();
                case 4: return new TimelineItemContent.RoomMembership({ userId: FfiConverterString.read(from), userDisplayName: FfiConverterOptionalString.read(from), change: FfiConverterOptionalTypeMembershipChange.read(from), reason: FfiConverterOptionalString.read(from) });
                case 5: return new TimelineItemContent.ProfileChange({ displayName: FfiConverterOptionalString.read(from), prevDisplayName: FfiConverterOptionalString.read(from), avatarUrl: FfiConverterOptionalString.read(from), prevAvatarUrl: FfiConverterOptionalString.read(from) });
                case 6: return new TimelineItemContent.State({ stateKey: FfiConverterString.read(from), content: FfiConverterTypeOtherState.read(from) });
                case 7: return new TimelineItemContent.FailedToParseMessageLike({ eventType: FfiConverterString.read(from), error: FfiConverterString.read(from) });
                case 8: return new TimelineItemContent.FailedToParseState({ eventType: FfiConverterString.read(from), stateKey: FfiConverterString.read(from), error: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case TimelineItemContent_Tags.MsgLike: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterTypeMsgLikeContent.write(inner.content, into);
                    return;
                }
                case TimelineItemContent_Tags.CallInvite: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case TimelineItemContent_Tags.RtcNotification: {
                    ordinalConverter.write(3, into);
                    return;
                }
                case TimelineItemContent_Tags.RoomMembership: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.userId, into);
                    FfiConverterOptionalString.write(inner.userDisplayName, into);
                    FfiConverterOptionalTypeMembershipChange.write(inner.change, into);
                    FfiConverterOptionalString.write(inner.reason, into);
                    return;
                }
                case TimelineItemContent_Tags.ProfileChange: {
                    ordinalConverter.write(5, into);
                    const inner = value.inner;
                    FfiConverterOptionalString.write(inner.displayName, into);
                    FfiConverterOptionalString.write(inner.prevDisplayName, into);
                    FfiConverterOptionalString.write(inner.avatarUrl, into);
                    FfiConverterOptionalString.write(inner.prevAvatarUrl, into);
                    return;
                }
                case TimelineItemContent_Tags.State: {
                    ordinalConverter.write(6, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.stateKey, into);
                    FfiConverterTypeOtherState.write(inner.content, into);
                    return;
                }
                case TimelineItemContent_Tags.FailedToParseMessageLike: {
                    ordinalConverter.write(7, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.eventType, into);
                    FfiConverterString.write(inner.error, into);
                    return;
                }
                case TimelineItemContent_Tags.FailedToParseState: {
                    ordinalConverter.write(8, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.eventType, into);
                    FfiConverterString.write(inner.stateKey, into);
                    FfiConverterString.write(inner.error, into);
                    return;
                }
                default:
                    // Throwing from here means that TimelineItemContent_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case TimelineItemContent_Tags.MsgLike: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterTypeMsgLikeContent.allocationSize(inner.content);
                    return size;
                }
                case TimelineItemContent_Tags.CallInvite: {
                    return ordinalConverter.allocationSize(2);
                }
                case TimelineItemContent_Tags.RtcNotification: {
                    return ordinalConverter.allocationSize(3);
                }
                case TimelineItemContent_Tags.RoomMembership: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterString.allocationSize(inner.userId);
                    size += FfiConverterOptionalString.allocationSize(inner.userDisplayName);
                    size += FfiConverterOptionalTypeMembershipChange.allocationSize(inner.change);
                    size += FfiConverterOptionalString.allocationSize(inner.reason);
                    return size;
                }
                case TimelineItemContent_Tags.ProfileChange: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(5);
                    size += FfiConverterOptionalString.allocationSize(inner.displayName);
                    size += FfiConverterOptionalString.allocationSize(inner.prevDisplayName);
                    size += FfiConverterOptionalString.allocationSize(inner.avatarUrl);
                    size += FfiConverterOptionalString.allocationSize(inner.prevAvatarUrl);
                    return size;
                }
                case TimelineItemContent_Tags.State: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(6);
                    size += FfiConverterString.allocationSize(inner.stateKey);
                    size += FfiConverterTypeOtherState.allocationSize(inner.content);
                    return size;
                }
                case TimelineItemContent_Tags.FailedToParseMessageLike: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(7);
                    size += FfiConverterString.allocationSize(inner.eventType);
                    size += FfiConverterString.allocationSize(inner.error);
                    return size;
                }
                case TimelineItemContent_Tags.FailedToParseState: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(8);
                    size += FfiConverterString.allocationSize(inner.eventType);
                    size += FfiConverterString.allocationSize(inner.stateKey);
                    size += FfiConverterString.allocationSize(inner.error);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
/**
 * A log pack can be used to set the trace log level for a group of multiple
 * log targets at once, for debugging purposes.
 */
export var TraceLogPacks;
(function (TraceLogPacks) {
    /**
     * Enables all the logs relevant to the event cache.
     */
    TraceLogPacks[TraceLogPacks["EventCache"] = 0] = "EventCache";
    /**
     * Enables all the logs relevant to the send queue.
     */
    TraceLogPacks[TraceLogPacks["SendQueue"] = 1] = "SendQueue";
    /**
     * Enables all the logs relevant to the timeline.
     */
    TraceLogPacks[TraceLogPacks["Timeline"] = 2] = "Timeline";
    /**
     * Enables all the logs relevant to the notification client.
     */
    TraceLogPacks[TraceLogPacks["NotificationClient"] = 3] = "NotificationClient";
    /**
     * Enables all the logs relevant to sync profiling.
     */
    TraceLogPacks[TraceLogPacks["SyncProfiling"] = 4] = "SyncProfiling";
})(TraceLogPacks || (TraceLogPacks = {}));
const FfiConverterTypeTraceLogPacks = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return TraceLogPacks.EventCache;
                case 2: return TraceLogPacks.SendQueue;
                case 3: return TraceLogPacks.Timeline;
                case 4: return TraceLogPacks.NotificationClient;
                case 5: return TraceLogPacks.SyncProfiling;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case TraceLogPacks.EventCache: return ordinalConverter.write(1, into);
                case TraceLogPacks.SendQueue: return ordinalConverter.write(2, into);
                case TraceLogPacks.Timeline: return ordinalConverter.write(3, into);
                case TraceLogPacks.NotificationClient: return ordinalConverter.write(4, into);
                case TraceLogPacks.SyncProfiling: return ordinalConverter.write(5, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Enum: Tweak
export var Tweak_Tags;
(function (Tweak_Tags) {
    Tweak_Tags["Sound"] = "Sound";
    Tweak_Tags["Highlight"] = "Highlight";
    Tweak_Tags["Custom"] = "Custom";
})(Tweak_Tags || (Tweak_Tags = {}));
/**
 * Enum representing the push notification tweaks for a rule.
 */
export const Tweak = (() => {
    /**
     * A string representing the sound to be played when this notification
     * arrives.
     *
     * A value of "default" means to play a default sound. A device may choose
     * to alert the user by some other means if appropriate, eg. vibration.
     */
    class Sound_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "Tweak";
        tag = Tweak_Tags.Sound;
        inner;
        constructor(inner) {
            super("Tweak", "Sound");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Sound_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === Tweak_Tags.Sound;
        }
    }
    /**
     * A boolean representing whether or not this message should be highlighted
     * in the UI.
     */
    class Highlight_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "Tweak";
        tag = Tweak_Tags.Highlight;
        inner;
        constructor(inner) {
            super("Tweak", "Highlight");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Highlight_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === Tweak_Tags.Highlight;
        }
    }
    /**
     * A custom tweak
     */
    class Custom_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "Tweak";
        tag = Tweak_Tags.Custom;
        inner;
        constructor(inner) {
            super("Tweak", "Custom");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Custom_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === Tweak_Tags.Custom;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "Tweak";
    }
    return Object.freeze({
        instanceOf,
        Sound: Sound_,
        Highlight: Highlight_,
        Custom: Custom_
    });
})();
// FfiConverter for enum Tweak
const FfiConverterTypeTweak = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new Tweak.Sound({ value: FfiConverterString.read(from) });
                case 2: return new Tweak.Highlight({ value: FfiConverterBool.read(from) });
                case 3: return new Tweak.Custom({ name: FfiConverterString.read(from), value: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case Tweak_Tags.Sound: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.value, into);
                    return;
                }
                case Tweak_Tags.Highlight: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterBool.write(inner.value, into);
                    return;
                }
                case Tweak_Tags.Custom: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.name, into);
                    FfiConverterString.write(inner.value, into);
                    return;
                }
                default:
                    // Throwing from here means that Tweak_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case Tweak_Tags.Sound: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterString.allocationSize(inner.value);
                    return size;
                }
                case Tweak_Tags.Highlight: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterBool.allocationSize(inner.value);
                    return size;
                }
                case Tweak_Tags.Custom: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterString.allocationSize(inner.name);
                    size += FfiConverterString.allocationSize(inner.value);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: UploadSource
export var UploadSource_Tags;
(function (UploadSource_Tags) {
    UploadSource_Tags["File"] = "File";
    UploadSource_Tags["Data"] = "Data";
})(UploadSource_Tags || (UploadSource_Tags = {}));
/**
 * A source for uploading a file
 */
export const UploadSource = (() => {
    /**
     * Upload source is a file on disk
     */
    class File_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "UploadSource";
        tag = UploadSource_Tags.File;
        inner;
        constructor(inner) {
            super("UploadSource", "File");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new File_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === UploadSource_Tags.File;
        }
    }
    /**
     * Upload source is data in memory
     */
    class Data_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "UploadSource";
        tag = UploadSource_Tags.Data;
        inner;
        constructor(inner) {
            super("UploadSource", "Data");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Data_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === UploadSource_Tags.Data;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "UploadSource";
    }
    return Object.freeze({
        instanceOf,
        File: File_,
        Data: Data_
    });
})();
// FfiConverter for enum UploadSource
const FfiConverterTypeUploadSource = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new UploadSource.File({ filename: FfiConverterString.read(from) });
                case 2: return new UploadSource.Data({ bytes: FfiConverterArrayBuffer.read(from), filename: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case UploadSource_Tags.File: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.filename, into);
                    return;
                }
                case UploadSource_Tags.Data: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterArrayBuffer.write(inner.bytes, into);
                    FfiConverterString.write(inner.filename, into);
                    return;
                }
                default:
                    // Throwing from here means that UploadSource_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case UploadSource_Tags.File: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterString.allocationSize(inner.filename);
                    return size;
                }
                case UploadSource_Tags.Data: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterArrayBuffer.allocationSize(inner.bytes);
                    size += FfiConverterString.allocationSize(inner.filename);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
export var VerificationState;
(function (VerificationState) {
    VerificationState[VerificationState["Unknown"] = 0] = "Unknown";
    VerificationState[VerificationState["Verified"] = 1] = "Verified";
    VerificationState[VerificationState["Unverified"] = 2] = "Unverified";
})(VerificationState || (VerificationState = {}));
const FfiConverterTypeVerificationState = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return VerificationState.Unknown;
                case 2: return VerificationState.Verified;
                case 3: return VerificationState.Unverified;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case VerificationState.Unknown: return ordinalConverter.write(1, into);
                case VerificationState.Verified: return ordinalConverter.write(2, into);
                case VerificationState.Unverified: return ordinalConverter.write(3, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Enum: VirtualTimelineItem
export var VirtualTimelineItem_Tags;
(function (VirtualTimelineItem_Tags) {
    VirtualTimelineItem_Tags["DateDivider"] = "DateDivider";
    VirtualTimelineItem_Tags["ReadMarker"] = "ReadMarker";
    VirtualTimelineItem_Tags["TimelineStart"] = "TimelineStart";
})(VirtualTimelineItem_Tags || (VirtualTimelineItem_Tags = {}));
/**
 * A [`TimelineItem`](super::TimelineItem) that doesn't correspond to an event.
 */
export const VirtualTimelineItem = (() => {
    /**
     * A divider between messages of different day or month depending on
     * timeline settings.
     */
    class DateDivider_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "VirtualTimelineItem";
        tag = VirtualTimelineItem_Tags.DateDivider;
        inner;
        constructor(inner) {
            super("VirtualTimelineItem", "DateDivider");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new DateDivider_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === VirtualTimelineItem_Tags.DateDivider;
        }
    }
    /**
     * The user's own read marker.
     */
    class ReadMarker_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "VirtualTimelineItem";
        tag = VirtualTimelineItem_Tags.ReadMarker;
        constructor() {
            super("VirtualTimelineItem", "ReadMarker");
        }
        static new() {
            return new ReadMarker_();
        }
        static instanceOf(obj) {
            return obj.tag === VirtualTimelineItem_Tags.ReadMarker;
        }
    }
    /**
     * The timeline start, that is, the *oldest* event in time for that room.
     */
    class TimelineStart_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "VirtualTimelineItem";
        tag = VirtualTimelineItem_Tags.TimelineStart;
        constructor() {
            super("VirtualTimelineItem", "TimelineStart");
        }
        static new() {
            return new TimelineStart_();
        }
        static instanceOf(obj) {
            return obj.tag === VirtualTimelineItem_Tags.TimelineStart;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "VirtualTimelineItem";
    }
    return Object.freeze({
        instanceOf,
        DateDivider: DateDivider_,
        ReadMarker: ReadMarker_,
        TimelineStart: TimelineStart_
    });
})();
// FfiConverter for enum VirtualTimelineItem
const FfiConverterTypeVirtualTimelineItem = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new VirtualTimelineItem.DateDivider({ ts: FfiConverterTypeTimestamp.read(from) });
                case 2: return new VirtualTimelineItem.ReadMarker();
                case 3: return new VirtualTimelineItem.TimelineStart();
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case VirtualTimelineItem_Tags.DateDivider: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterTypeTimestamp.write(inner.ts, into);
                    return;
                }
                case VirtualTimelineItem_Tags.ReadMarker: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case VirtualTimelineItem_Tags.TimelineStart: {
                    ordinalConverter.write(3, into);
                    return;
                }
                default:
                    // Throwing from here means that VirtualTimelineItem_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case VirtualTimelineItem_Tags.DateDivider: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterTypeTimestamp.allocationSize(inner.ts);
                    return size;
                }
                case VirtualTimelineItem_Tags.ReadMarker: {
                    return ordinalConverter.allocationSize(2);
                }
                case VirtualTimelineItem_Tags.TimelineStart: {
                    return ordinalConverter.allocationSize(3);
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// Enum: WidgetEventFilter
export var WidgetEventFilter_Tags;
(function (WidgetEventFilter_Tags) {
    WidgetEventFilter_Tags["MessageLikeWithType"] = "MessageLikeWithType";
    WidgetEventFilter_Tags["RoomMessageWithMsgtype"] = "RoomMessageWithMsgtype";
    WidgetEventFilter_Tags["StateWithType"] = "StateWithType";
    WidgetEventFilter_Tags["StateWithTypeAndStateKey"] = "StateWithTypeAndStateKey";
    WidgetEventFilter_Tags["ToDevice"] = "ToDevice";
})(WidgetEventFilter_Tags || (WidgetEventFilter_Tags = {}));
/**
 * Different kinds of filters that could be applied to the timeline events.
 */
export const WidgetEventFilter = (() => {
    /**
     * Matches message-like events with the given `type`.
     */
    class MessageLikeWithType_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "WidgetEventFilter";
        tag = WidgetEventFilter_Tags.MessageLikeWithType;
        inner;
        constructor(inner) {
            super("WidgetEventFilter", "MessageLikeWithType");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new MessageLikeWithType_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === WidgetEventFilter_Tags.MessageLikeWithType;
        }
    }
    /**
     * Matches `m.room.message` events with the given `msgtype`.
     */
    class RoomMessageWithMsgtype_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "WidgetEventFilter";
        tag = WidgetEventFilter_Tags.RoomMessageWithMsgtype;
        inner;
        constructor(inner) {
            super("WidgetEventFilter", "RoomMessageWithMsgtype");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new RoomMessageWithMsgtype_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === WidgetEventFilter_Tags.RoomMessageWithMsgtype;
        }
    }
    /**
     * Matches state events with the given `type`, regardless of `state_key`.
     */
    class StateWithType_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "WidgetEventFilter";
        tag = WidgetEventFilter_Tags.StateWithType;
        inner;
        constructor(inner) {
            super("WidgetEventFilter", "StateWithType");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new StateWithType_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === WidgetEventFilter_Tags.StateWithType;
        }
    }
    /**
     * Matches state events with the given `type` and `state_key`.
     */
    class StateWithTypeAndStateKey_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "WidgetEventFilter";
        tag = WidgetEventFilter_Tags.StateWithTypeAndStateKey;
        inner;
        constructor(inner) {
            super("WidgetEventFilter", "StateWithTypeAndStateKey");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new StateWithTypeAndStateKey_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === WidgetEventFilter_Tags.StateWithTypeAndStateKey;
        }
    }
    /**
     * Matches to-device events with the given `event_type`.
     */
    class ToDevice_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "WidgetEventFilter";
        tag = WidgetEventFilter_Tags.ToDevice;
        inner;
        constructor(inner) {
            super("WidgetEventFilter", "ToDevice");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new ToDevice_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === WidgetEventFilter_Tags.ToDevice;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "WidgetEventFilter";
    }
    return Object.freeze({
        instanceOf,
        MessageLikeWithType: MessageLikeWithType_,
        RoomMessageWithMsgtype: RoomMessageWithMsgtype_,
        StateWithType: StateWithType_,
        StateWithTypeAndStateKey: StateWithTypeAndStateKey_,
        ToDevice: ToDevice_
    });
})();
// FfiConverter for enum WidgetEventFilter
const FfiConverterTypeWidgetEventFilter = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new WidgetEventFilter.MessageLikeWithType({ eventType: FfiConverterString.read(from) });
                case 2: return new WidgetEventFilter.RoomMessageWithMsgtype({ msgtype: FfiConverterString.read(from) });
                case 3: return new WidgetEventFilter.StateWithType({ eventType: FfiConverterString.read(from) });
                case 4: return new WidgetEventFilter.StateWithTypeAndStateKey({ eventType: FfiConverterString.read(from), stateKey: FfiConverterString.read(from) });
                case 5: return new WidgetEventFilter.ToDevice({ eventType: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case WidgetEventFilter_Tags.MessageLikeWithType: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.eventType, into);
                    return;
                }
                case WidgetEventFilter_Tags.RoomMessageWithMsgtype: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.msgtype, into);
                    return;
                }
                case WidgetEventFilter_Tags.StateWithType: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.eventType, into);
                    return;
                }
                case WidgetEventFilter_Tags.StateWithTypeAndStateKey: {
                    ordinalConverter.write(4, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.eventType, into);
                    FfiConverterString.write(inner.stateKey, into);
                    return;
                }
                case WidgetEventFilter_Tags.ToDevice: {
                    ordinalConverter.write(5, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.eventType, into);
                    return;
                }
                default:
                    // Throwing from here means that WidgetEventFilter_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case WidgetEventFilter_Tags.MessageLikeWithType: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterString.allocationSize(inner.eventType);
                    return size;
                }
                case WidgetEventFilter_Tags.RoomMessageWithMsgtype: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterString.allocationSize(inner.msgtype);
                    return size;
                }
                case WidgetEventFilter_Tags.StateWithType: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterString.allocationSize(inner.eventType);
                    return size;
                }
                case WidgetEventFilter_Tags.StateWithTypeAndStateKey: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(4);
                    size += FfiConverterString.allocationSize(inner.eventType);
                    size += FfiConverterString.allocationSize(inner.stateKey);
                    return size;
                }
                case WidgetEventFilter_Tags.ToDevice: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(5);
                    size += FfiConverterString.allocationSize(inner.eventType);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
// FfiConverter for Map<string, /*i32*/number>
const FfiConverterMapStringInt32 = new FfiConverterMap(FfiConverterString, FfiConverterInt32);
// FfiConverter for Map<string, /*i64*/bigint>
const FfiConverterMapStringInt64 = new FfiConverterMap(FfiConverterString, FfiConverterInt64);
// FfiConverter for Map<string, IgnoredUser>
const FfiConverterMapStringTypeIgnoredUser = new FfiConverterMap(FfiConverterString, FfiConverterTypeIgnoredUser);
// FfiConverter for Map<string, Receipt>
const FfiConverterMapStringTypeReceipt = new FfiConverterMap(FfiConverterString, FfiConverterTypeReceipt);
// FfiConverter for Map<string, string>
const FfiConverterMapStringString = new FfiConverterMap(FfiConverterString, FfiConverterString);
/**
 * Used to pass back the [`CheckCode`] entered by the user to verify that the
 * secure channel is indeed secure.
 */
export class CheckCodeSender extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "CheckCodeSender";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeCheckCodeSenderObjectFactory.bless(pointer);
    }
    /**
     * Send the [`CheckCode`].
     *
     * Calling this method more than once will result in an error.
     *
     * # Arguments
     *
     * * `check_code` - The check code in digits representation.
     */
    async send(code, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_checkcodesender_send(uniffiTypeCheckCodeSenderObjectFactory.clonePointer(this), FfiConverterUInt8.lower(code));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeHumanQrLoginError.lift.bind(FfiConverterTypeHumanQrLoginError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeCheckCodeSenderObjectFactory.pointer(this);
            uniffiTypeCheckCodeSenderObjectFactory.freePointer(pointer);
            uniffiTypeCheckCodeSenderObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeCheckCodeSenderObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeCheckCodeSenderObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeCheckCodeSenderObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(CheckCodeSender.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "CheckCodeSender";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_checkcodesender(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_checkcodesender(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "CheckCodeSender";
        },
    };
})();
// FfiConverter for CheckCodeSenderInterface
const FfiConverterTypeCheckCodeSender = new FfiConverterObject(uniffiTypeCheckCodeSenderObjectFactory);
export class Client extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "Client";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeClientObjectFactory.bless(pointer);
    }
    /**
     * Aborts an existing OIDC login operation that might have been cancelled,
     * failed etc.
     */
    async abortOidcAuth(authorizationData, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_abort_oidc_auth(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterTypeOAuthAuthorizationData.lower(authorizationData));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Get the content of the event of the given type out of the account data
     * store.
     *
     * It will be returned as a JSON string.
     */
    async accountData(eventType, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_account_data(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(eventType));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterOptionalString.lift.bind(FfiConverterOptionalString), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async accountUrl(action, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_account_url(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterOptionalTypeAccountManagementAction.lower(action));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterOptionalString.lift.bind(FfiConverterOptionalString), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Find all sliding sync versions that are available.
     *
     * Be careful: This method may hit the store and will send new requests for
     * each call. It can be costly to call it repeatedly.
     *
     * If `.well-known` or `/versions` is unreachable, it will simply move
     * potential sliding sync versions aside. No error will be reported.
     */
    async availableSlidingSyncVersions(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_available_sliding_sync_versions(uniffiTypeClientObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterArrayTypeSlidingSyncVersion.lift.bind(FfiConverterArrayTypeSlidingSyncVersion), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Sends a request to retrieve the avatar URL. Will fill the cache used by
     * [`Self::cached_avatar_url`] on success.
     */
    async avatarUrl(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_avatar_url(uniffiTypeClientObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterOptionalString.lift.bind(FfiConverterOptionalString), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Waits until an at least partially synced room is received, and returns
     * it.
     *
     * **Note: this function will loop endlessly until either it finds the room
     * or an externally set timeout happens.**
     */
    async awaitRoomRemoteEcho(roomId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_await_room_remote_echo(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(roomId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeRoom.lift.bind(FfiConverterTypeRoom), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Retrieves an avatar cached from a previous call to [`Self::avatar_url`].
     */
    async cachedAvatarUrl(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_cached_avatar_url(uniffiTypeClientObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterOptionalString.lift.bind(FfiConverterOptionalString), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Lets the user know whether this is an `m.login.password` based
     * auth and if the account can actually be deactivated
     */
    canDeactivateAccount() {
        return FfiConverterBool.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_can_deactivate_account(uniffiTypeClientObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Clear all the non-critical caches for this Client instance.
     *
     * WARNING: This will clear all the caches, including the base store (state
     * store), so callers must make sure that the Client is at rest before
     * calling it.
     *
     * In particular, if a [`SyncService`] is running, it must be passed here
     * as a parameter, or stopped before calling this method. Ideally, the
     * send queues should have been disabled and must all be inactive (i.e.
     * not sending events); this method will disable them, but it might not
     * be enough if the queues are still processing events.
     *
     * After the method returns, the Client will be in an unstable
     * state, and it is required that the caller reinstantiates a new
     * Client instance, be it via dropping the previous and re-creating it,
     * restarting their application, or any other similar means.
     *
     * - This will get rid of the backing state store file, if provided.
     * - This will empty all the room's persisted event caches, so all rooms
     * will start as if they were empty.
     * - This will empty the media cache according to the current media
     * retention policy.
     */
    async clearCaches(syncService, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_clear_caches(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterOptionalTypeSyncService.lower(syncService));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async createRoom(request, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_create_room(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterTypeCreateRoomParameters.lower(request));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Login using JWT
     * This is an implementation of the custom_login https://docs.rs/matrix-sdk/latest/matrix_sdk/matrix_auth/struct.MatrixAuth.html#method.login_custom
     * For more information on logging in with JWT: https://element-hq.github.io/synapse/latest/jwt.html
     */
    async customLoginWithJwt(jwt, initialDeviceName, deviceId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_custom_login_with_jwt(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(jwt), FfiConverterOptionalString.lower(initialDeviceName), FfiConverterOptionalString.lower(deviceId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Deactivate this account definitively.
     * Similarly to `encryption::reset_identity` this
     * will only work with password-based authentication (`m.login.password`)
     *
     * # Arguments
     *
     * * `auth_data` - This request uses the [User-Interactive Authentication
     * API][uiaa]. The first request needs to set this to `None` and will
     * always fail and the same request needs to be made but this time with
     * some `auth_data` provided.
     */
    async deactivateAccount(authData, eraseData, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_deactivate_account(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterOptionalTypeAuthData.lower(authData), FfiConverterBool.lower(eraseData));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Deletes a pusher of given pusher ids
     */
    async deletePusher(identifiers, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_delete_pusher(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterTypePusherIdentifiers.lower(identifiers));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    deviceId() {
        return FfiConverterString.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_device_id(uniffiTypeClientObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    async displayName(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_display_name(uniffiTypeClientObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Enables or disables all the room send queues at once.
     *
     * When connectivity is lost on a device, it is recommended to disable the
     * room sending queues.
     *
     * This can be controlled for individual rooms, using
     * [`Room::enable_send_queue`].
     */
    async enableAllSendQueues(enable, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_enable_all_send_queues(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterBool.lower(enable));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Enables or disables progress reporting for media uploads in the send
     * queue.
     */
    enableSendQueueUploadProgress(enable) {
        uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_enable_send_queue_upload_progress(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterBool.lower(enable), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift);
    }
    encryption() {
        return FfiConverterTypeEncryption.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_encryption(uniffiTypeClientObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Fetch the media preview configuration from the server.
     */
    async fetchMediaPreviewConfig(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_fetch_media_preview_config(uniffiTypeClientObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterOptionalTypeMediaPreviewConfig.lift.bind(FfiConverterOptionalTypeMediaPreviewConfig), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    getDmRoom(userId) {
        return FfiConverterOptionalTypeRoom.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_dm_room(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(userId), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Get the invite request avatars display policy
     * currently stored in the cache.
     */
    async getInviteAvatarsDisplayPolicy(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_invite_avatars_display_policy(uniffiTypeClientObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterOptionalTypeInviteAvatars.lift.bind(FfiConverterOptionalTypeInviteAvatars), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Gets the `max_upload_size` value from the homeserver, which controls the
     * max size a media upload request can have.
     */
    async getMaxMediaUploadSize(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_max_media_upload_size(uniffiTypeClientObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_u64, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_u64, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_u64, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_u64, 
            /*liftFunc:*/ FfiConverterUInt64.lift.bind(FfiConverterUInt64), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async getMediaContent(mediaSource, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_media_content(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterTypeMediaSource.lower(mediaSource));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterArrayBuffer.lift.bind(FfiConverterArrayBuffer), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Retrieves a media file from the media source
     *
     * Not available on Wasm platforms, due to lack of accessible file system.
     */
    async getMediaFile(mediaSource, filename, mimeType, useCache, tempDir, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_media_file(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterTypeMediaSource.lower(mediaSource), FfiConverterOptionalString.lower(filename), FfiConverterString.lower(mimeType), FfiConverterBool.lower(useCache), FfiConverterOptionalString.lower(tempDir));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeMediaFileHandle.lift.bind(FfiConverterTypeMediaFileHandle), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Get the media previews timeline display policy
     * currently stored in the cache.
     */
    async getMediaPreviewDisplayPolicy(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_media_preview_display_policy(uniffiTypeClientObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterOptionalTypeMediaPreviews.lift.bind(FfiConverterOptionalTypeMediaPreviews), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async getMediaThumbnail(mediaSource, width, height, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_media_thumbnail(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterTypeMediaSource.lower(mediaSource), FfiConverterUInt64.lower(width), FfiConverterUInt64.lower(height));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterArrayBuffer.lift.bind(FfiConverterArrayBuffer), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async getNotificationSettings(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_notification_settings(uniffiTypeClientObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeNotificationSettings.lift.bind(FfiConverterTypeNotificationSettings), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async getProfile(userId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_profile(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(userId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterTypeUserProfile.lift.bind(FfiConverterTypeUserProfile), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async getRecentlyVisitedRooms(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_recently_visited_rooms(uniffiTypeClientObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterArrayString.lift.bind(FfiConverterArrayString), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Get a room by its ID.
     *
     * # Arguments
     *
     * * `room_id` - The ID of the room to get.
     *
     * # Returns
     *
     * A `Result` containing an optional room, or a `ClientError`.
     * This method will not initialize the room's timeline or populate it with
     * events.
     */
    getRoom(roomId) {
        return FfiConverterOptionalTypeRoom.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_room(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(roomId), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Given a room alias, get the preview of a room, to interact with it.
     */
    async getRoomPreviewFromRoomAlias(roomAlias, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_room_preview_from_room_alias(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(roomAlias));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeRoomPreview.lift.bind(FfiConverterTypeRoomPreview), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Given a room id, get the preview of a room, to interact with it.
     *
     * The list of `via_servers` must be a list of servers that know
     * about the room and can resolve it, and that may appear as a `via`
     * parameter in e.g. a permalink URL. This list can be empty.
     */
    async getRoomPreviewFromRoomId(roomId, viaServers, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_room_preview_from_room_id(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(roomId), FfiConverterArrayString.lower(viaServers));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeRoomPreview.lift.bind(FfiConverterTypeRoomPreview), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async getSessionVerificationController(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_session_verification_controller(uniffiTypeClientObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeSessionVerificationController.lift.bind(FfiConverterTypeSessionVerificationController), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Allows generic GET requests to be made through the SDK's internal HTTP
     * client. This is useful when the caller's native HTTP client wouldn't
     * have the same configuration (such as certificates, proxies, etc.) This
     * method returns the raw bytes of the response, so that any kind of
     * resource can be fetched including images, files, etc.
     *
     * Note: When an HTTP error occurs, the error response can be found in the
     * `ClientError::Generic`'s `details` field.
     */
    async getUrl(url, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_get_url(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(url));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterArrayBuffer.lift.bind(FfiConverterArrayBuffer), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * The homeserver this client is configured to use.
     */
    homeserver() {
        return FfiConverterString.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_homeserver(uniffiTypeClientObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Information about login options for the client's homeserver.
     */
    async homeserverLoginDetails(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_homeserver_login_details(uniffiTypeClientObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeHomeserverLoginDetails.lift.bind(FfiConverterTypeHomeserverLoginDetails), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async ignoreUser(userId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_ignore_user(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(userId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async ignoredUsers(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_ignored_users(uniffiTypeClientObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterArrayString.lift.bind(FfiConverterArrayString), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Checks if the server supports the LiveKit RTC focus for placing calls.
     */
    async isLivekitRtcSupported(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_is_livekit_rtc_supported(uniffiTypeClientObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Checks if the server supports the report room API.
     */
    async isReportRoomApiSupported(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_is_report_room_api_supported(uniffiTypeClientObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Checks if a room alias is not in use yet.
     *
     * Returns:
     * - `Ok(true)` if the room alias is available.
     * - `Ok(false)` if it's not (the resolve alias request returned a `404`
     * status code).
     * - An `Err` otherwise.
     */
    async isRoomAliasAvailable(alias, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_is_room_alias_available(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(alias));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Join a room by its ID.
     *
     * Use this method when the homeserver already knows of the given room ID.
     * Otherwise use `join_room_by_id_or_alias` so you can pass a list of
     * server names for the homeserver to find the room.
     */
    async joinRoomById(roomId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_join_room_by_id(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(roomId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeRoom.lift.bind(FfiConverterTypeRoom), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Join a room by its ID or alias.
     *
     * When supplying the room's ID, you can also supply a list of server names
     * for the homeserver to find the room. Typically these server names
     * come from a permalink's `via` parameters, or from resolving a room's
     * alias into an ID.
     */
    async joinRoomByIdOrAlias(roomIdOrAlias, serverNames, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_join_room_by_id_or_alias(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(roomIdOrAlias), FfiConverterArrayString.lower(serverNames));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeRoom.lift.bind(FfiConverterTypeRoom), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Knock on a room to join it using its ID or alias.
     */
    async knock(roomIdOrAlias, reason, serverNames, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_knock(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(roomIdOrAlias), FfiConverterOptionalString.lower(reason), FfiConverterArrayString.lower(serverNames));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeRoom.lift.bind(FfiConverterTypeRoom), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Login using a username and password.
     */
    async login(username, password, initialDeviceName, deviceId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_login(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(username), FfiConverterString.lower(password), FfiConverterOptionalString.lower(initialDeviceName), FfiConverterOptionalString.lower(deviceId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Login using an email and password.
     */
    async loginWithEmail(email, password, initialDeviceName, deviceId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_login_with_email(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(email), FfiConverterString.lower(password), FfiConverterOptionalString.lower(initialDeviceName), FfiConverterOptionalString.lower(deviceId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Completes the OIDC login process.
     */
    async loginWithOidcCallback(callbackUrl, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_login_with_oidc_callback(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(callbackUrl));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeOidcError.lift.bind(FfiConverterTypeOidcError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Log the current user out.
     */
    async logout(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_logout(uniffiTypeClientObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Create a handler for granting login from this device to a new device by
     * way of a QR code.
     */
    newGrantLoginWithQrCodeHandler() {
        return FfiConverterTypeGrantLoginWithQrCodeHandler.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_new_grant_login_with_qr_code_handler(uniffiTypeClientObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Create a handler for requesting an existing device to grant login to
     * this device by way of a QR code.
     *
     * # Arguments
     *
     * * `oidc_configuration` - The data to restore or register the client with
     * the server.
     */
    newLoginWithQrCodeHandler(oidcConfiguration) {
        return FfiConverterTypeLoginWithQrCodeHandler.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_new_login_with_qr_code_handler(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterTypeOidcConfiguration.lower(oidcConfiguration), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    async notificationClient(processSetup, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_notification_client(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterTypeNotificationProcessSetup.lower(processSetup));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeNotificationClient.lift.bind(FfiConverterTypeNotificationClient), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Subscribe to updates of global account data events.
     *
     * Be careful that only the most recent value can be observed. Subscribers
     * are notified when a new value is sent, but there is no guarantee that
     * they will see all values.
     */
    observeAccountDataEvent(eventType, listener) {
        return FfiConverterTypeTaskHandle.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_observe_account_data_event(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterTypeAccountDataEventType.lower(eventType), FfiConverterTypeAccountDataListener.lower(listener), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Subscribe to updates of room account data events.
     *
     * Be careful that only the most recent value can be observed. Subscribers
     * are notified when a new value is sent, but there is no guarantee that
     * they will see all values.
     */
    observeRoomAccountDataEvent(roomId, eventType, listener) {
        return FfiConverterTypeTaskHandle.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_observe_room_account_data_event(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(roomId), FfiConverterTypeRoomAccountDataEventType.lower(eventType), FfiConverterTypeRoomAccountDataListener.lower(listener), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Register a handler for notifications generated from sync responses.
     *
     * The handler will be called during sync for each event that triggers
     * a notification based on the user's push rules.
     *
     * The handler receives:
     * - The notification with push actions and event data
     * - The room ID where the notification occurred
     *
     * This is useful for implementing custom notification logic, such as
     * displaying local notifications or updating notification badges.
     */
    async registerNotificationHandler(listener, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_register_notification_handler(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterTypeSyncNotificationListener.lower(listener));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async removeAvatar(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_remove_avatar(uniffiTypeClientObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Empty the server version and unstable features cache.
     *
     * Since the SDK caches server info (versions, unstable features,
     * well-known etc), it's possible to have a stale entry in the cache.
     * This functions makes it possible to force reset it.
     */
    async resetServerInfo(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_reset_server_info(uniffiTypeClientObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Resolves the given room alias to a room ID (and a list of servers), if
     * possible.
     */
    async resolveRoomAlias(roomAlias, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_resolve_room_alias(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(roomAlias));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterOptionalTypeResolvedRoomAlias.lift.bind(FfiConverterOptionalTypeResolvedRoomAlias), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Restores the client from a `Session`.
     *
     * It reloads the entire set of rooms from the previous session.
     *
     * If you want to control the amount of rooms to reloads, check
     * [`Client::restore_session_with`].
     */
    async restoreSession(session, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_restore_session(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterTypeSession.lower(session));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Restores the client from a `Session`.
     *
     * It reloads a set of rooms controlled by [`RoomLoadSettings`].
     */
    async restoreSessionWith(session, roomLoadSettings, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_restore_session_with(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterTypeSession.lower(session), FfiConverterTypeRoomLoadSettings.lower(roomLoadSettings));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Checks if a room alias exists in the current homeserver.
     */
    async roomAliasExists(roomAlias, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_room_alias_exists(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(roomAlias));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    roomDirectorySearch() {
        return FfiConverterTypeRoomDirectorySearch.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_room_directory_search(uniffiTypeClientObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    rooms() {
        return FfiConverterArrayTypeRoom.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_rooms(uniffiTypeClientObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    async searchUsers(searchTerm, limit, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_search_users(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(searchTerm), FfiConverterUInt64.lower(limit));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterTypeSearchUsersResults.lift.bind(FfiConverterTypeSearchUsersResults), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * The URL of the server.
     *
     * Not to be confused with the `Self::homeserver`. `server` is usually
     * the server part in a user ID, e.g. with `@mnt_io:matrix.org`, here
     * `matrix.org` is the server, whilst `matrix-client.matrix.org` is the
     * homeserver (at the time of writing  2024-08-28).
     *
     * This value is optional depending on how the `Client` has been built.
     * If it's been built from a homeserver URL directly, we don't know the
     * server. However, if the `Client` has been built from a server URL or
     * name, then the homeserver has been discovered, and we know both.
     */
    server() {
        return FfiConverterOptionalString.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_server(uniffiTypeClientObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Get server vendor information from the federation API.
     *
     * This method retrieves information about the server's name and version
     * by calling the `/_matrix/federation/v1/version` endpoint.
     */
    async serverVendorInfo(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_server_vendor_info(uniffiTypeClientObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterTypeServerVendorInfo.lift.bind(FfiConverterTypeServerVendorInfo), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    session() {
        return FfiConverterTypeSession.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_session(uniffiTypeClientObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Set the given account data content for the given event type.
     *
     * It should be supplied as a JSON string.
     */
    async setAccountData(eventType, content, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_set_account_data(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(eventType), FfiConverterString.lower(content));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Sets the [ClientDelegate] which will inform about authentication errors.
     * Returns an error if the delegate was already set.
     */
    setDelegate(delegate) {
        return FfiConverterOptionalTypeTaskHandle.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_set_delegate(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterOptionalTypeClientDelegate.lower(delegate), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    async setDisplayName(name, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_set_display_name(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(name));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Set the invite request avatars display policy
     */
    async setInviteAvatarsDisplayPolicy(policy, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_set_invite_avatars_display_policy(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterTypeInviteAvatars.lower(policy));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Set the media previews timeline display policy
     */
    async setMediaPreviewDisplayPolicy(policy, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_set_media_preview_display_policy(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterTypeMediaPreviews.lower(policy));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Set the media retention policy.
     */
    async setMediaRetentionPolicy(policy, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_set_media_retention_policy(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterTypeMediaRetentionPolicy.lower(policy));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Registers a pusher with given parameters
     */
    async setPusher(identifiers, kind, appDisplayName, deviceDisplayName, profileTag, lang, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_set_pusher(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterTypePusherIdentifiers.lower(identifiers), FfiConverterTypePusherKind.lower(kind), FfiConverterString.lower(appDisplayName), FfiConverterString.lower(deviceDisplayName), FfiConverterOptionalString.lower(profileTag), FfiConverterString.lower(lang));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Sets the [UnableToDecryptDelegate] which will inform about UTDs.
     * Returns an error if the delegate was already set.
     */
    async setUtdDelegate(utdDelegate, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_set_utd_delegate(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterTypeUnableToDecryptDelegate.lower(utdDelegate));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * The sliding sync version.
     */
    slidingSyncVersion() {
        return FfiConverterTypeSlidingSyncVersion.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_sliding_sync_version(uniffiTypeClientObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    spaceService() {
        return FfiConverterTypeSpaceService.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_space_service(uniffiTypeClientObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Returns a handler to start the SSO login process.
     */
    async startSsoLogin(redirectUrl, idpId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_start_sso_login(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(redirectUrl), FfiConverterOptionalString.lower(idpId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeSsoHandler.lift.bind(FfiConverterTypeSsoHandler), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeSsoError.lift.bind(FfiConverterTypeSsoError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    subscribeToIgnoredUsers(listener) {
        return FfiConverterTypeTaskHandle.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_ignored_users(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterTypeIgnoredUsersListener.lower(listener), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Subscribe to changes in the media preview configuration.
     */
    async subscribeToMediaPreviewConfig(listener, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_media_preview_config(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterTypeMediaPreviewConfigListener.lower(listener));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeTaskHandle.lift.bind(FfiConverterTypeTaskHandle), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Subscribe to [`RoomInfo`] updates given a provided [`RoomId`].
     *
     * This works even for rooms we haven't received yet, so we can subscribe
     * to this and wait until we receive updates from them when sync responses
     * are processed.
     *
     * Note this method should be used sparingly since using callback
     * interfaces is expensive, as well as keeping them alive for a long
     * time. Usages of this method should be short-lived and dropped as
     * soon as possible.
     */
    async subscribeToRoomInfo(roomId, listener, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_room_info(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(roomId), FfiConverterTypeRoomInfoListener.lower(listener));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeTaskHandle.lift.bind(FfiConverterTypeTaskHandle), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Subscribe to the global enablement status of the send queue, at the
     * client-wide level.
     *
     * The given listener will be immediately called with the initial value of
     * the enablement status.
     */
    subscribeToSendQueueStatus(listener) {
        return FfiConverterTypeTaskHandle.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_send_queue_status(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterTypeSendQueueRoomErrorListener.lower(listener), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Subscribe to the global send queue update reporter, at the
     * client-wide level.
     *
     * The given listener will be immediately called with
     * `RoomSendQueueUpdate::NewLocalEvent` for each local echo existing in
     * the queue.
     */
    async subscribeToSendQueueUpdates(listener, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_send_queue_updates(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterTypeSendQueueRoomUpdateListener.lower(listener));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeTaskHandle.lift.bind(FfiConverterTypeTaskHandle), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    syncService() {
        return FfiConverterTypeSyncServiceBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_sync_service(uniffiTypeClientObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    async trackRecentlyVisitedRoom(room, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_track_recently_visited_room(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(room));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async unignoreUser(userId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_unignore_user(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(userId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async uploadAvatar(mimeType, data, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_upload_avatar(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(mimeType), FfiConverterArrayBuffer.lower(data));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async uploadMedia(mimeType, data, progressWatcher, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_upload_media(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterString.lower(mimeType), FfiConverterArrayBuffer.lower(data), FfiConverterOptionalTypeProgressWatcher.lower(progressWatcher));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Requests the URL needed for opening a web view using OIDC. Once the web
     * view has succeeded, call `login_with_oidc_callback` with the callback it
     * returns. If a failure occurs and a callback isn't available, make sure
     * to call `abort_oidc_auth` to inform the client of this.
     *
     * # Arguments
     *
     * * `oidc_configuration` - The configuration used to load the credentials
     * of the client if it is already registered with the authorization
     * server, or register the client and store its credentials if it isn't.
     *
     * * `prompt` - The desired user experience in the web UI. No value means
     * that the user wishes to login into an existing account, and a value of
     * `Create` means that the user wishes to register a new account.
     *
     * * `login_hint` - A generic login hint that an identity provider can use
     * to pre-fill the login form. The format of this hint is not restricted
     * by the spec as external providers all have their own way to handle the hint.
     * However, it should be noted that when providing a user ID as a hint
     * for MAS (with no upstream provider), then the format to use is defined
     * by [MSC4198]: https://github.com/matrix-org/matrix-spec-proposals/pull/4198
     *
     * * `device_id` - The unique ID that will be associated with the session.
     * If not set, a random one will be generated. It can be an existing
     * device ID from a previous login call. Note that this should be done
     * only if the client also holds the corresponding encryption keys.
     *
     * * `additional_scopes` - Additional scopes to request from the
     * authorization server, e.g. "urn:matrix:client:com.example.msc9999.foo".
     * The scopes for API access and the device ID according to the
     * [specification](https://spec.matrix.org/v1.15/client-server-api/#allocated-scope-tokens)
     * are always requested.
     */
    async urlForOidc(oidcConfiguration, prompt, loginHint, deviceId, additionalScopes, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_url_for_oidc(uniffiTypeClientObjectFactory.clonePointer(this), FfiConverterTypeOidcConfiguration.lower(oidcConfiguration), FfiConverterOptionalTypeOidcPrompt.lower(prompt), FfiConverterOptionalString.lower(loginHint), FfiConverterOptionalString.lower(deviceId), FfiConverterOptionalArrayString.lower(additionalScopes));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeOAuthAuthorizationData.lift.bind(FfiConverterTypeOAuthAuthorizationData), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeOidcError.lift.bind(FfiConverterTypeOidcError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    userId() {
        return FfiConverterString.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_user_id(uniffiTypeClientObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * The server name part of the current user ID
     */
    userIdServerName() {
        return FfiConverterString.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_client_user_id_server_name(uniffiTypeClientObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeClientObjectFactory.pointer(this);
            uniffiTypeClientObjectFactory.freePointer(pointer);
            uniffiTypeClientObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeClientObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeClientObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeClientObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(Client.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "Client";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_client(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_client(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "Client";
        },
    };
})();
// FfiConverter for ClientInterface
const FfiConverterTypeClient = new FfiConverterObject(uniffiTypeClientObjectFactory);
export class ClientBuilder extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "ClientBuilder";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    constructor() {
        super();
        const pointer = uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_clientbuilder_new(callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift);
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeClientBuilderObjectFactory.bless(pointer);
    }
    addRootCertificates(certificates) {
        return FfiConverterTypeClientBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_add_root_certificates(uniffiTypeClientBuilderObjectFactory.clonePointer(this), FfiConverterArrayArrayBuffer.lower(certificates), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Automatically create a backup version if no backup exists.
     */
    autoEnableBackups(autoEnableBackups) {
        return FfiConverterTypeClientBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_auto_enable_backups(uniffiTypeClientBuilderObjectFactory.clonePointer(this), FfiConverterBool.lower(autoEnableBackups), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    autoEnableCrossSigning(autoEnableCrossSigning) {
        return FfiConverterTypeClientBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_auto_enable_cross_signing(uniffiTypeClientBuilderObjectFactory.clonePointer(this), FfiConverterBool.lower(autoEnableCrossSigning), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Select a strategy to download room keys from the backup. By default
     * we download after a decryption failure.
     *
     * Take a look at the [`BackupDownloadStrategy`] enum for more options.
     */
    backupDownloadStrategy(backupDownloadStrategy) {
        return FfiConverterTypeClientBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_backup_download_strategy(uniffiTypeClientBuilderObjectFactory.clonePointer(this), FfiConverterTypeBackupDownloadStrategy.lower(backupDownloadStrategy), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    async build(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_build(uniffiTypeClientBuilderObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeClient.lift.bind(FfiConverterTypeClient), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientBuildError.lift.bind(FfiConverterTypeClientBuildError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    crossProcessStoreLocksHolderName(holderName) {
        return FfiConverterTypeClientBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_cross_process_store_locks_holder_name(uniffiTypeClientBuilderObjectFactory.clonePointer(this), FfiConverterString.lower(holderName), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Set the trust requirement to be used when decrypting events.
     */
    decryptionSettings(decryptionSettings) {
        return FfiConverterTypeClientBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_decryption_settings(uniffiTypeClientBuilderObjectFactory.clonePointer(this), FfiConverterTypeDecryptionSettings.lower(decryptionSettings), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    disableAutomaticTokenRefresh() {
        return FfiConverterTypeClientBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_automatic_token_refresh(uniffiTypeClientBuilderObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Don't trust any system root certificates, only trust the certificates
     * provided through
     * [`add_root_certificates`][ClientBuilder::add_root_certificates].
     */
    disableBuiltInRootCertificates() {
        return FfiConverterTypeClientBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_built_in_root_certificates(uniffiTypeClientBuilderObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    disableSslVerification() {
        return FfiConverterTypeClientBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_ssl_verification(uniffiTypeClientBuilderObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    enableOidcRefreshLock() {
        return FfiConverterTypeClientBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_enable_oidc_refresh_lock(uniffiTypeClientBuilderObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Set whether to enable the experimental support for sending and receiving
     * encrypted room history on invite, per [MSC4268].
     *
     * [MSC4268]: https://github.com/matrix-org/matrix-spec-proposals/pull/4268
     */
    enableShareHistoryOnInvite(enableShareHistoryOnInvite) {
        return FfiConverterTypeClientBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_enable_share_history_on_invite(uniffiTypeClientBuilderObjectFactory.clonePointer(this), FfiConverterBool.lower(enableShareHistoryOnInvite), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    homeserverUrl(url) {
        return FfiConverterTypeClientBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_homeserver_url(uniffiTypeClientBuilderObjectFactory.clonePointer(this), FfiConverterString.lower(url), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Use in-memory session storage.
     */
    inMemoryStore() {
        return FfiConverterTypeClientBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_in_memory_store(uniffiTypeClientBuilderObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Use IndexedDB as the session storage.
     */
    indexeddbStore(config) {
        return FfiConverterTypeClientBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_indexeddb_store(uniffiTypeClientBuilderObjectFactory.clonePointer(this), FfiConverterTypeIndexedDbStoreBuilder.lower(config), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    proxy(url) {
        return FfiConverterTypeClientBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_proxy(uniffiTypeClientBuilderObjectFactory.clonePointer(this), FfiConverterString.lower(url), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Add a default request config to this client.
     */
    requestConfig(config) {
        return FfiConverterTypeClientBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_request_config(uniffiTypeClientBuilderObjectFactory.clonePointer(this), FfiConverterTypeRequestConfig.lower(config), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Set the strategy to be used for picking recipient devices when sending
     * an encrypted message.
     */
    roomKeyRecipientStrategy(strategy) {
        return FfiConverterTypeClientBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_room_key_recipient_strategy(uniffiTypeClientBuilderObjectFactory.clonePointer(this), FfiConverterTypeCollectStrategy.lower(strategy), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    serverName(serverName) {
        return FfiConverterTypeClientBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_name(uniffiTypeClientBuilderObjectFactory.clonePointer(this), FfiConverterString.lower(serverName), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    serverNameOrHomeserverUrl(serverNameOrUrl) {
        return FfiConverterTypeClientBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_name_or_homeserver_url(uniffiTypeClientBuilderObjectFactory.clonePointer(this), FfiConverterString.lower(serverNameOrUrl), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    setSessionDelegate(sessionDelegate) {
        return FfiConverterTypeClientBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_set_session_delegate(uniffiTypeClientBuilderObjectFactory.clonePointer(this), FfiConverterTypeClientSessionDelegate.lower(sessionDelegate), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    slidingSyncVersionBuilder(versionBuilder) {
        return FfiConverterTypeClientBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_sliding_sync_version_builder(uniffiTypeClientBuilderObjectFactory.clonePointer(this), FfiConverterTypeSlidingSyncVersionBuilder.lower(versionBuilder), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Tell the client that the system is memory constrained, like in a push
     * notification process for example.
     *
     * So far, at the time of writing (2025-04-07), it changes the defaults of
     * `matrix_sdk::SqliteStoreConfig` (if the `sqlite` feature is enabled).
     * Please check
     * `matrix_sdk::SqliteStoreConfig::with_low_memory_config`.
     */
    systemIsMemoryConstrained() {
        return FfiConverterTypeClientBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_system_is_memory_constrained(uniffiTypeClientBuilderObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Whether the client should support threads client-side or not, and enable
     * experimental support for MSC4306 (threads subscriptions) or not.
     */
    threadsEnabled(enabled, threadSubscriptions) {
        return FfiConverterTypeClientBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_threads_enabled(uniffiTypeClientBuilderObjectFactory.clonePointer(this), FfiConverterBool.lower(enabled), FfiConverterBool.lower(threadSubscriptions), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    userAgent(userAgent) {
        return FfiConverterTypeClientBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_user_agent(uniffiTypeClientBuilderObjectFactory.clonePointer(this), FfiConverterString.lower(userAgent), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    username(username) {
        return FfiConverterTypeClientBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_clientbuilder_username(uniffiTypeClientBuilderObjectFactory.clonePointer(this), FfiConverterString.lower(username), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeClientBuilderObjectFactory.pointer(this);
            uniffiTypeClientBuilderObjectFactory.freePointer(pointer);
            uniffiTypeClientBuilderObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeClientBuilderObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeClientBuilderObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeClientBuilderObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(ClientBuilder.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "ClientBuilder";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_clientbuilder(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_clientbuilder(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "ClientBuilder";
        },
    };
})();
// FfiConverter for ClientBuilderInterface
const FfiConverterTypeClientBuilder = new FfiConverterObject(uniffiTypeClientBuilderObjectFactory);
export class Encryption extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "Encryption";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeEncryptionObjectFactory.bless(pointer);
    }
    /**
     * Does a backup exist on the server?
     *
     * Because the homeserver doesn't notify us about changes to the backup
     * version, the [`BackupState`] and its listener are a bit crippled.
     * The `BackupState::Unknown` state might mean there is no backup at all or
     * a backup exists but we don't have access to it.
     *
     * Therefore it is necessary to poll the server for an answer every time
     * you want to differentiate between those two states.
     */
    async backupExistsOnServer(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_backup_exists_on_server(uniffiTypeEncryptionObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    backupState() {
        return FfiConverterTypeBackupState.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_backup_state(uniffiTypeEncryptionObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    backupStateListener(listener) {
        return FfiConverterTypeTaskHandle.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_backup_state_listener(uniffiTypeEncryptionObjectFactory.clonePointer(this), FfiConverterTypeBackupStateListener.lower(listener), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Get the public curve25519 key of our own device in base64. This is
     * usually what is called the identity key of the device.
     */
    async curve25519Key(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_curve25519_key(uniffiTypeEncryptionObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterOptionalString.lift.bind(FfiConverterOptionalString), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async disableRecovery(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_disable_recovery(uniffiTypeEncryptionObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeRecoveryError.lift.bind(FfiConverterTypeRecoveryError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Get the public ed25519 key of our own device. This is usually what is
     * called the fingerprint of the device.
     */
    async ed25519Key(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_ed25519_key(uniffiTypeEncryptionObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterOptionalString.lift.bind(FfiConverterOptionalString), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async enableBackups(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_enable_backups(uniffiTypeEncryptionObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeRecoveryError.lift.bind(FfiConverterTypeRecoveryError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async enableRecovery(waitForBackupsToUpload, passphrase, progressListener, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_enable_recovery(uniffiTypeEncryptionObjectFactory.clonePointer(this), FfiConverterBool.lower(waitForBackupsToUpload), FfiConverterOptionalString.lower(passphrase), FfiConverterTypeEnableRecoveryProgressListener.lower(progressListener));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeRecoveryError.lift.bind(FfiConverterTypeRecoveryError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Does the user have other devices that the current device can verify
     * against?
     *
     * The device must be signed by the user's cross-signing key, must have an
     * identity, and must not be a dehydrated device.
     */
    async hasDevicesToVerifyAgainst(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_has_devices_to_verify_against(uniffiTypeEncryptionObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async isLastDevice(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_is_last_device(uniffiTypeEncryptionObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeRecoveryError.lift.bind(FfiConverterTypeRecoveryError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async recover(recoveryKey, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_recover(uniffiTypeEncryptionObjectFactory.clonePointer(this), FfiConverterString.lower(recoveryKey));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeRecoveryError.lift.bind(FfiConverterTypeRecoveryError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async recoverAndReset(oldRecoveryKey, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_recover_and_reset(uniffiTypeEncryptionObjectFactory.clonePointer(this), FfiConverterString.lower(oldRecoveryKey));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeRecoveryError.lift.bind(FfiConverterTypeRecoveryError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    recoveryState() {
        return FfiConverterTypeRecoveryState.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_recovery_state(uniffiTypeEncryptionObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    recoveryStateListener(listener) {
        return FfiConverterTypeTaskHandle.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_recovery_state_listener(uniffiTypeEncryptionObjectFactory.clonePointer(this), FfiConverterTypeRecoveryStateListener.lower(listener), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Completely reset the current user's crypto identity: reset the cross
     * signing keys, delete the existing backup and recovery key.
     */
    async resetIdentity(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_reset_identity(uniffiTypeEncryptionObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterOptionalTypeIdentityResetHandle.lift.bind(FfiConverterOptionalTypeIdentityResetHandle), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async resetRecoveryKey(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_reset_recovery_key(uniffiTypeEncryptionObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeRecoveryError.lift.bind(FfiConverterTypeRecoveryError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Get the E2EE identity of a user.
     *
     * This method always tries to fetch the identity from the store, which we
     * only have if the user is tracked, meaning that we are both members
     * of the same encrypted room. If no user is found locally, a request will
     * be made to the homeserver unless `fallback_to_server` is set to `false`.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user that the identity belongs to.
     * * `fallback_to_server` - Should we request the user identity from the
     * homeserver if one isn't found locally.
     *
     * Returns a `UserIdentity` if one is found. Returns an error if there
     * was an issue with the crypto store or with the request to the
     * homeserver.
     *
     * This will always return `None` if the client hasn't been logged in.
     */
    async userIdentity(userId, fallbackToServer, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_user_identity(uniffiTypeEncryptionObjectFactory.clonePointer(this), FfiConverterString.lower(userId), FfiConverterBool.lower(fallbackToServer));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterOptionalTypeUserIdentity.lift.bind(FfiConverterOptionalTypeUserIdentity), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    verificationState() {
        return FfiConverterTypeVerificationState.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_verification_state(uniffiTypeEncryptionObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    verificationStateListener(listener) {
        return FfiConverterTypeTaskHandle.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_verification_state_listener(uniffiTypeEncryptionObjectFactory.clonePointer(this), FfiConverterTypeVerificationStateListener.lower(listener), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    async waitForBackupUploadSteadyState(progressListener, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_wait_for_backup_upload_steady_state(uniffiTypeEncryptionObjectFactory.clonePointer(this), FfiConverterOptionalTypeBackupSteadyStateListener.lower(progressListener));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeSteadyStateError.lift.bind(FfiConverterTypeSteadyStateError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Waits for end-to-end encryption initialization tasks to finish, if any
     * was running in the background.
     */
    async waitForE2eeInitializationTasks(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_encryption_wait_for_e2ee_initialization_tasks(uniffiTypeEncryptionObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeEncryptionObjectFactory.pointer(this);
            uniffiTypeEncryptionObjectFactory.freePointer(pointer);
            uniffiTypeEncryptionObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeEncryptionObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeEncryptionObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeEncryptionObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(Encryption.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "Encryption";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_encryption(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_encryption(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "Encryption";
        },
    };
})();
// FfiConverter for EncryptionInterface
const FfiConverterTypeEncryption = new FfiConverterObject(uniffiTypeEncryptionObjectFactory);
/**
 * Handler for granting login in with a QR code.
 */
export class GrantLoginWithQrCodeHandler extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "GrantLoginWithQrCodeHandler";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeGrantLoginWithQrCodeHandlerObjectFactory.bless(pointer);
    }
    /**
     * This method allows you to grant login by generating a QR code.
     *
     * This device needs to call this method and handle its progress updates to
     * generate a QR code which the new device can scan to log in.
     *
     * This method uses the login mechanism described in [MSC4108]. As such,
     * it requires OAuth 2.0 support.
     *
     * For the reverse flow where the existing device generates the QR code
     * for this device to scan, use [`GrantLoginWithQrCodeHandler::scan`].
     *
     * # Arguments
     *
     * * `progress_listener` - A progress listener that must also be used to
     * obtain the [`QrCodeData`] and collect the [`CheckCode`] from the user.
     *
     * [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
     */
    async generate(progressListener, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_grantloginwithqrcodehandler_generate(uniffiTypeGrantLoginWithQrCodeHandlerObjectFactory.clonePointer(this), FfiConverterTypeGrantGeneratedQrLoginProgressListener.lower(progressListener));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeHumanQrGrantLoginError.lift.bind(FfiConverterTypeHumanQrGrantLoginError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * This method allows you to grant login with a scanned QR code.
     *
     * The new device needs to display the QR code which this device can
     * scan, call this method and handle its progress updates to grant the
     * login.
     *
     * This method uses the login mechanism described in [MSC4108]. As such,
     * it requires OAuth 2.0 support.
     *
     * For the reverse flow where this device generates the QR code for the
     * existing device to scan, use [`GrantLoginWithQrCodeHandler::generate`].
     *
     * # Arguments
     *
     * * `qr_code_data` - The [`QrCodeData`] scanned from the QR code.
     * * `progress_listener` - A progress listener that must also be used to
     * transfer the [`CheckCode`] to the new device.
     *
     * [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
     */
    async scan(qrCodeData, progressListener, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_grantloginwithqrcodehandler_scan(uniffiTypeGrantLoginWithQrCodeHandlerObjectFactory.clonePointer(this), FfiConverterTypeQrCodeData.lower(qrCodeData), FfiConverterTypeGrantQrLoginProgressListener.lower(progressListener));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeHumanQrGrantLoginError.lift.bind(FfiConverterTypeHumanQrGrantLoginError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeGrantLoginWithQrCodeHandlerObjectFactory.pointer(this);
            uniffiTypeGrantLoginWithQrCodeHandlerObjectFactory.freePointer(pointer);
            uniffiTypeGrantLoginWithQrCodeHandlerObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeGrantLoginWithQrCodeHandlerObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeGrantLoginWithQrCodeHandlerObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeGrantLoginWithQrCodeHandlerObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(GrantLoginWithQrCodeHandler.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "GrantLoginWithQrCodeHandler";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_grantloginwithqrcodehandler(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_grantloginwithqrcodehandler(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "GrantLoginWithQrCodeHandler";
        },
    };
})();
// FfiConverter for GrantLoginWithQrCodeHandlerInterface
const FfiConverterTypeGrantLoginWithQrCodeHandler = new FfiConverterObject(uniffiTypeGrantLoginWithQrCodeHandlerObjectFactory);
export class HomeserverLoginDetails extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "HomeserverLoginDetails";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeHomeserverLoginDetailsObjectFactory.bless(pointer);
    }
    /**
     * The sliding sync version.
     */
    slidingSyncVersion() {
        return FfiConverterTypeSlidingSyncVersion.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_sliding_sync_version(uniffiTypeHomeserverLoginDetailsObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * The prompts advertised by the authentication issuer for use in the login
     * URL.
     */
    supportedOidcPrompts() {
        return FfiConverterArrayTypeOidcPrompt.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supported_oidc_prompts(uniffiTypeHomeserverLoginDetailsObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Whether the current homeserver supports login using OIDC.
     */
    supportsOidcLogin() {
        return FfiConverterBool.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_oidc_login(uniffiTypeHomeserverLoginDetailsObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Whether the current homeserver supports the password login flow.
     */
    supportsPasswordLogin() {
        return FfiConverterBool.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_password_login(uniffiTypeHomeserverLoginDetailsObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Whether the current homeserver supports login using legacy SSO.
     */
    supportsSsoLogin() {
        return FfiConverterBool.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_sso_login(uniffiTypeHomeserverLoginDetailsObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * The URL of the currently configured homeserver.
     */
    url() {
        return FfiConverterString.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_url(uniffiTypeHomeserverLoginDetailsObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeHomeserverLoginDetailsObjectFactory.pointer(this);
            uniffiTypeHomeserverLoginDetailsObjectFactory.freePointer(pointer);
            uniffiTypeHomeserverLoginDetailsObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeHomeserverLoginDetailsObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeHomeserverLoginDetailsObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeHomeserverLoginDetailsObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(HomeserverLoginDetails.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "HomeserverLoginDetails";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_homeserverlogindetails(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_homeserverlogindetails(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "HomeserverLoginDetails";
        },
    };
})();
// FfiConverter for HomeserverLoginDetailsInterface
const FfiConverterTypeHomeserverLoginDetails = new FfiConverterObject(uniffiTypeHomeserverLoginDetailsObjectFactory);
export class IdentityResetHandle extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "IdentityResetHandle";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeIdentityResetHandleObjectFactory.bless(pointer);
    }
    /**
     * Get the underlying [`CrossSigningResetAuthType`] this identity reset
     * process is using.
     */
    authType() {
        return FfiConverterTypeCrossSigningResetAuthType.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_identityresethandle_auth_type(uniffiTypeIdentityResetHandleObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    async cancel(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_identityresethandle_cancel(uniffiTypeIdentityResetHandleObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * This method starts the identity reset process and
     * will go through the following steps:
     *
     * 1. Disable backing up room keys and delete the active backup
     * 2. Disable recovery and delete secret storage
     * 3. Go through the cross-signing key reset flow
     * 4. Finally, re-enable key backups only if they were enabled before
     */
    async reset(auth, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_identityresethandle_reset(uniffiTypeIdentityResetHandleObjectFactory.clonePointer(this), FfiConverterOptionalTypeAuthData.lower(auth));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeIdentityResetHandleObjectFactory.pointer(this);
            uniffiTypeIdentityResetHandleObjectFactory.freePointer(pointer);
            uniffiTypeIdentityResetHandleObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeIdentityResetHandleObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeIdentityResetHandleObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeIdentityResetHandleObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(IdentityResetHandle.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "IdentityResetHandle";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_identityresethandle(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_identityresethandle(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "IdentityResetHandle";
        },
    };
})();
// FfiConverter for IdentityResetHandleInterface
const FfiConverterTypeIdentityResetHandle = new FfiConverterObject(uniffiTypeIdentityResetHandleObjectFactory);
export class InReplyToDetails extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "InReplyToDetails";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeInReplyToDetailsObjectFactory.bless(pointer);
    }
    event() {
        return FfiConverterTypeEmbeddedEventDetails.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_inreplytodetails_event(uniffiTypeInReplyToDetailsObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    eventId() {
        return FfiConverterString.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_inreplytodetails_event_id(uniffiTypeInReplyToDetailsObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeInReplyToDetailsObjectFactory.pointer(this);
            uniffiTypeInReplyToDetailsObjectFactory.freePointer(pointer);
            uniffiTypeInReplyToDetailsObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeInReplyToDetailsObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeInReplyToDetailsObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeInReplyToDetailsObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(InReplyToDetails.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "InReplyToDetails";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_inreplytodetails(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_inreplytodetails(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "InReplyToDetails";
        },
    };
})();
// FfiConverter for InReplyToDetailsInterface
const FfiConverterTypeInReplyToDetails = new FfiConverterObject(uniffiTypeInReplyToDetailsObjectFactory);
export class IndexedDbStoreBuilder extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "IndexedDbStoreBuilder";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    constructor(name) {
        super();
        const pointer = uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_indexeddbstorebuilder_new(FfiConverterString.lower(name), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift);
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeIndexedDbStoreBuilderObjectFactory.bless(pointer);
    }
    /**
     * Set the passphrase for the stores.
     */
    passphrase(passphrase) {
        return FfiConverterTypeIndexedDbStoreBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_indexeddbstorebuilder_passphrase(uniffiTypeIndexedDbStoreBuilderObjectFactory.clonePointer(this), FfiConverterOptionalString.lower(passphrase), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeIndexedDbStoreBuilderObjectFactory.pointer(this);
            uniffiTypeIndexedDbStoreBuilderObjectFactory.freePointer(pointer);
            uniffiTypeIndexedDbStoreBuilderObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeIndexedDbStoreBuilderObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeIndexedDbStoreBuilderObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeIndexedDbStoreBuilderObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(IndexedDbStoreBuilder.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "IndexedDbStoreBuilder";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_indexeddbstorebuilder(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_indexeddbstorebuilder(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "IndexedDbStoreBuilder";
        },
    };
})();
// FfiConverter for IndexedDbStoreBuilderInterface
const FfiConverterTypeIndexedDbStoreBuilder = new FfiConverterObject(uniffiTypeIndexedDbStoreBuilderObjectFactory);
/**
 * A set of actions to perform for a knock request.
 */
export class KnockRequestActions extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "KnockRequestActions";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeKnockRequestActionsObjectFactory.bless(pointer);
    }
    /**
     * Accepts the knock request by inviting the user to the room.
     */
    async accept(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_accept(uniffiTypeKnockRequestActionsObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Declines the knock request by kicking the user from the room with an
     * optional reason.
     */
    async decline(reason, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_decline(uniffiTypeKnockRequestActionsObjectFactory.clonePointer(this), FfiConverterOptionalString.lower(reason));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Declines the knock request by banning the user from the room with an
     * optional reason.
     */
    async declineAndBan(reason, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_decline_and_ban(uniffiTypeKnockRequestActionsObjectFactory.clonePointer(this), FfiConverterOptionalString.lower(reason));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Marks the knock request as 'seen'.
     *
     * **IMPORTANT**: this won't update the current reference to this request,
     * a new one with the updated value should be emitted instead.
     */
    async markAsSeen(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_mark_as_seen(uniffiTypeKnockRequestActionsObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeKnockRequestActionsObjectFactory.pointer(this);
            uniffiTypeKnockRequestActionsObjectFactory.freePointer(pointer);
            uniffiTypeKnockRequestActionsObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeKnockRequestActionsObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeKnockRequestActionsObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeKnockRequestActionsObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(KnockRequestActions.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "KnockRequestActions";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_knockrequestactions(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_knockrequestactions(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "KnockRequestActions";
        },
    };
})();
// FfiConverter for KnockRequestActionsInterface
const FfiConverterTypeKnockRequestActions = new FfiConverterObject(uniffiTypeKnockRequestActionsObjectFactory);
/**
 * Wrapper to retrieve some timeline item info lazily.
 */
export class LazyTimelineItemProvider extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "LazyTimelineItemProvider";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeLazyTimelineItemProviderObjectFactory.bless(pointer);
    }
    containsOnlyEmojis() {
        return FfiConverterBool.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_contains_only_emojis(uniffiTypeLazyTimelineItemProviderObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Returns some debug information for this event timeline item.
     */
    debugInfo() {
        return FfiConverterTypeEventTimelineItemDebugInfo.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_debug_info(uniffiTypeLazyTimelineItemProviderObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * For local echoes, return the associated send handle; returns `None` for
     * remote echoes.
     */
    getSendHandle() {
        return FfiConverterOptionalTypeSendHandle.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_get_send_handle(uniffiTypeLazyTimelineItemProviderObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Returns the shields for this event timeline item.
     */
    getShields(strict) {
        return FfiConverterOptionalTypeShieldState.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_get_shields(uniffiTypeLazyTimelineItemProviderObjectFactory.clonePointer(this), FfiConverterBool.lower(strict), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeLazyTimelineItemProviderObjectFactory.pointer(this);
            uniffiTypeLazyTimelineItemProviderObjectFactory.freePointer(pointer);
            uniffiTypeLazyTimelineItemProviderObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeLazyTimelineItemProviderObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeLazyTimelineItemProviderObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeLazyTimelineItemProviderObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(LazyTimelineItemProvider.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "LazyTimelineItemProvider";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_lazytimelineitemprovider(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_lazytimelineitemprovider(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "LazyTimelineItemProvider";
        },
    };
})();
// FfiConverter for LazyTimelineItemProviderInterface
const FfiConverterTypeLazyTimelineItemProvider = new FfiConverterObject(uniffiTypeLazyTimelineItemProviderObjectFactory);
/**
 * The `LeaveSpaceHandle` processes rooms to be left in the order they were
 * provided by the [`SpaceService`] and annotates them with extra data to
 * inform the leave process e.g. if the current user is the last room admin.
 *
 * Once the upstream client decides what rooms should actually be left, the
 * handle provides a method to execute that too.
 */
export class LeaveSpaceHandle extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "LeaveSpaceHandle";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeLeaveSpaceHandleObjectFactory.bless(pointer);
    }
    /**
     * Bulk leave the given rooms. Stops when encountering an error.
     */
    async leave(roomIds, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_leavespacehandle_leave(uniffiTypeLeaveSpaceHandleObjectFactory.clonePointer(this), FfiConverterArrayString.lower(roomIds));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * A list of rooms to be left which next to normal [`SpaceRoom`] data also
     * include leave specific information.
     */
    rooms() {
        return FfiConverterArrayTypeLeaveSpaceRoom.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_leavespacehandle_rooms(uniffiTypeLeaveSpaceHandleObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeLeaveSpaceHandleObjectFactory.pointer(this);
            uniffiTypeLeaveSpaceHandleObjectFactory.freePointer(pointer);
            uniffiTypeLeaveSpaceHandleObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeLeaveSpaceHandleObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeLeaveSpaceHandleObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeLeaveSpaceHandleObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(LeaveSpaceHandle.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "LeaveSpaceHandle";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_leavespacehandle(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_leavespacehandle(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "LeaveSpaceHandle";
        },
    };
})();
// FfiConverter for LeaveSpaceHandleInterface
const FfiConverterTypeLeaveSpaceHandle = new FfiConverterObject(uniffiTypeLeaveSpaceHandleObjectFactory);
/**
 * Handler for logging in with a QR code.
 */
export class LoginWithQrCodeHandler extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "LoginWithQrCodeHandler";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeLoginWithQrCodeHandlerObjectFactory.bless(pointer);
    }
    /**
     * This method allows you to log in by generating a QR code.
     *
     * This device needs to call this method and handle its progress updates to
     * generate a QR code which the existing device can scan and grant the
     * log in.
     *
     * This method uses the login mechanism described in [MSC4108]. As such,
     * it requires OAuth 2.0 support.
     *
     * For the reverse flow where the existing device generates the QR code
     * for this device to scan, use [`LoginWithQrCodeHandler::scan`].
     *
     * # Arguments
     *
     * * `progress_listener` - A progress listener that must also be used to
     * obtain the [`QrCodeData`] and collect the [`CheckCode`] from the user.
     *
     * [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
     */
    async generate(progressListener, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_loginwithqrcodehandler_generate(uniffiTypeLoginWithQrCodeHandlerObjectFactory.clonePointer(this), FfiConverterTypeGeneratedQrLoginProgressListener.lower(progressListener));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeHumanQrLoginError.lift.bind(FfiConverterTypeHumanQrLoginError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * This method allows you to log in with a scanned QR code.
     *
     * The existing device needs to display the QR code which this device can
     * scan, call this method and handle its progress updates to log in.
     *
     * For the login to succeed, the [`Client`] associated with the
     * [`LoginWithQrCodeHandler`] must have been built with
     * [`QrCodeData::server_name`] as the server name.
     *
     * This method uses the login mechanism described in [MSC4108]. As such,
     * it requires OAuth 2.0 support.
     *
     * For the reverse flow where this device generates the QR code for the
     * existing device to scan, use [`LoginWithQrCodeHandler::generate`].
     *
     * # Arguments
     *
     * * `qr_code_data` - The [`QrCodeData`] scanned from the QR code.
     * * `progress_listener` - A progress listener that must also be used to
     * transfer the [`CheckCode`] to the existing device.
     *
     * [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
     */
    async scan(qrCodeData, progressListener, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_loginwithqrcodehandler_scan(uniffiTypeLoginWithQrCodeHandlerObjectFactory.clonePointer(this), FfiConverterTypeQrCodeData.lower(qrCodeData), FfiConverterTypeQrLoginProgressListener.lower(progressListener));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeHumanQrLoginError.lift.bind(FfiConverterTypeHumanQrLoginError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeLoginWithQrCodeHandlerObjectFactory.pointer(this);
            uniffiTypeLoginWithQrCodeHandlerObjectFactory.freePointer(pointer);
            uniffiTypeLoginWithQrCodeHandlerObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeLoginWithQrCodeHandlerObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeLoginWithQrCodeHandlerObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeLoginWithQrCodeHandlerObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(LoginWithQrCodeHandler.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "LoginWithQrCodeHandler";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_loginwithqrcodehandler(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_loginwithqrcodehandler(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "LoginWithQrCodeHandler";
        },
    };
})();
// FfiConverter for LoginWithQrCodeHandlerInterface
const FfiConverterTypeLoginWithQrCodeHandler = new FfiConverterObject(uniffiTypeLoginWithQrCodeHandlerObjectFactory);
/**
 * A file handle that takes ownership of a media file on disk. When the handle
 * is dropped, the file will be removed from the disk.
 */
export class MediaFileHandle extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "MediaFileHandle";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeMediaFileHandleObjectFactory.bless(pointer);
    }
    /**
     * Get the media file's path.
     */
    path() {
        return FfiConverterString.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_mediafilehandle_path(uniffiTypeMediaFileHandleObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    persist(path) {
        return FfiConverterBool.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_mediafilehandle_persist(uniffiTypeMediaFileHandleObjectFactory.clonePointer(this), FfiConverterString.lower(path), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeMediaFileHandleObjectFactory.pointer(this);
            uniffiTypeMediaFileHandleObjectFactory.freePointer(pointer);
            uniffiTypeMediaFileHandleObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeMediaFileHandleObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeMediaFileHandleObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeMediaFileHandleObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(MediaFileHandle.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "MediaFileHandle";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_mediafilehandle(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_mediafilehandle(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "MediaFileHandle";
        },
    };
})();
// FfiConverter for MediaFileHandleInterface
const FfiConverterTypeMediaFileHandle = new FfiConverterObject(uniffiTypeMediaFileHandleObjectFactory);
export class MediaSource extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "MediaSource";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeMediaSourceObjectFactory.bless(pointer);
    }
    static fromJson(json) {
        return FfiConverterTypeMediaSource.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_mediasource_from_json(FfiConverterString.lower(json), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    static fromUrl(url) {
        return FfiConverterTypeMediaSource.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_mediasource_from_url(FfiConverterString.lower(url), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    toJson() {
        return FfiConverterString.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_mediasource_to_json(uniffiTypeMediaSourceObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    url() {
        return FfiConverterString.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_mediasource_url(uniffiTypeMediaSourceObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeMediaSourceObjectFactory.pointer(this);
            uniffiTypeMediaSourceObjectFactory.freePointer(pointer);
            uniffiTypeMediaSourceObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeMediaSourceObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeMediaSourceObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeMediaSourceObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(MediaSource.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "MediaSource";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_mediasource(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_mediasource(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "MediaSource";
        },
    };
})();
// FfiConverter for MediaSourceInterface
const FfiConverterTypeMediaSource = new FfiConverterObject(uniffiTypeMediaSourceObjectFactory);
export class NotificationClient extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "NotificationClient";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeNotificationClientObjectFactory.bless(pointer);
    }
    /**
     * Fetches the content of a notification.
     *
     * This will first try to get the notification using a short-lived sliding
     * sync, and if the sliding-sync can't find the event, then it'll use a
     * `/context` query to find the event with associated member information.
     *
     * An error result means that we couldn't resolve the notification; in that
     * case, a dummy notification may be displayed instead.
     */
    async getNotification(roomId, eventId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationclient_get_notification(uniffiTypeNotificationClientObjectFactory.clonePointer(this), FfiConverterString.lower(roomId), FfiConverterString.lower(eventId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterTypeNotificationStatus.lift.bind(FfiConverterTypeNotificationStatus), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Get several notification items in a single batch.
     *
     * Returns an error if the flow failed when preparing to fetch the
     * notifications, and a [`HashMap`] containing either a
     * [`BatchNotificationResult`], that indicates if the notification was
     * successfully fetched (in which case, it's a [`NotificationStatus`]), or
     * an error message if it couldn't be fetched.
     */
    async getNotifications(requests, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationclient_get_notifications(uniffiTypeNotificationClientObjectFactory.clonePointer(this), FfiConverterArrayTypeNotificationItemsRequest.lower(requests));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterMapStringTypeBatchNotificationResult.lift.bind(FfiConverterMapStringTypeBatchNotificationResult), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Fetches a room by its ID using the in-memory state store backed client.
     *
     * Useful to retrieve room information after running the limited
     * notification client sliding sync loop.
     */
    getRoom(roomId) {
        return FfiConverterOptionalTypeRoom.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationclient_get_room(uniffiTypeNotificationClientObjectFactory.clonePointer(this), FfiConverterString.lower(roomId), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeNotificationClientObjectFactory.pointer(this);
            uniffiTypeNotificationClientObjectFactory.freePointer(pointer);
            uniffiTypeNotificationClientObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeNotificationClientObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeNotificationClientObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeNotificationClientObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(NotificationClient.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "NotificationClient";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_notificationclient(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_notificationclient(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "NotificationClient";
        },
    };
})();
// FfiConverter for NotificationClientInterface
const FfiConverterTypeNotificationClient = new FfiConverterObject(uniffiTypeNotificationClientObjectFactory);
export class NotificationSettings extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "NotificationSettings";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeNotificationSettingsObjectFactory.bless(pointer);
    }
    /**
     * Check whether [MSC 4028 push rule][rule] is enabled on the homeserver.
     *
     * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
     */
    async canHomeserverPushEncryptedEventToDevice(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_can_homeserver_push_encrypted_event_to_device(uniffiTypeNotificationSettingsObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Returns true if [MSC 4028 push rule][rule] is supported and enabled.
     *
     * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
     */
    async canPushEncryptedEventToDevice(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_can_push_encrypted_event_to_device(uniffiTypeNotificationSettingsObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Get whether some enabled keyword rules exist.
     */
    async containsKeywordsRules(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_contains_keywords_rules(uniffiTypeNotificationSettingsObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Get the default room notification mode
     *
     * The mode will depend on the associated `PushRule` based on whether the
     * room is encrypted or not, and on the number of members.
     *
     * # Arguments
     *
     * * `is_encrypted` - whether the room is encrypted
     * * `is_one_to_one` - whether the room is a direct chats involving two
     * people
     */
    async getDefaultRoomNotificationMode(isEncrypted, isOneToOne, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_default_room_notification_mode(uniffiTypeNotificationSettingsObjectFactory.clonePointer(this), FfiConverterBool.lower(isEncrypted), FfiConverterBool.lower(isOneToOne));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterTypeRoomNotificationMode.lift.bind(FfiConverterTypeRoomNotificationMode), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Returns the raw push rules in JSON format.
     */
    async getRawPushRules(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_raw_push_rules(uniffiTypeNotificationSettingsObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterOptionalString.lift.bind(FfiConverterOptionalString), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Get the notification settings for a room.
     *
     * # Arguments
     *
     * * `room_id` - the room ID
     * * `is_encrypted` - whether the room is encrypted
     * * `is_one_to_one` - whether the room is a direct chat involving two
     * people
     */
    async getRoomNotificationSettings(roomId, isEncrypted, isOneToOne, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_room_notification_settings(uniffiTypeNotificationSettingsObjectFactory.clonePointer(this), FfiConverterString.lower(roomId), FfiConverterBool.lower(isEncrypted), FfiConverterBool.lower(isOneToOne));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterTypeRoomNotificationSettings.lift.bind(FfiConverterTypeRoomNotificationSettings), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(FfiConverterTypeNotificationSettingsError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Get all room IDs for which a user-defined rule exists.
     */
    async getRoomsWithUserDefinedRules(enabled, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_rooms_with_user_defined_rules(uniffiTypeNotificationSettingsObjectFactory.clonePointer(this), FfiConverterOptionalBool.lower(enabled));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterArrayString.lift.bind(FfiConverterArrayString), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Get the user defined room notification mode
     */
    async getUserDefinedRoomNotificationMode(roomId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_user_defined_room_notification_mode(uniffiTypeNotificationSettingsObjectFactory.clonePointer(this), FfiConverterString.lower(roomId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterOptionalTypeRoomNotificationMode.lift.bind(FfiConverterOptionalTypeRoomNotificationMode), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(FfiConverterTypeNotificationSettingsError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Get whether the `.m.rule.call` push rule is enabled
     */
    async isCallEnabled(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_call_enabled(uniffiTypeNotificationSettingsObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(FfiConverterTypeNotificationSettingsError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Get whether the `.m.rule.invite_for_me` push rule is enabled
     */
    async isInviteForMeEnabled(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_invite_for_me_enabled(uniffiTypeNotificationSettingsObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(FfiConverterTypeNotificationSettingsError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Get whether room mentions are enabled.
     */
    async isRoomMentionEnabled(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_room_mention_enabled(uniffiTypeNotificationSettingsObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(FfiConverterTypeNotificationSettingsError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Get whether user mentions are enabled.
     */
    async isUserMentionEnabled(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_user_mention_enabled(uniffiTypeNotificationSettingsObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(FfiConverterTypeNotificationSettingsError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Restore the default notification mode for a room
     */
    async restoreDefaultRoomNotificationMode(roomId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_restore_default_room_notification_mode(uniffiTypeNotificationSettingsObjectFactory.clonePointer(this), FfiConverterString.lower(roomId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(FfiConverterTypeNotificationSettingsError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Set whether the `.m.rule.call` push rule is enabled
     */
    async setCallEnabled(enabled, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_call_enabled(uniffiTypeNotificationSettingsObjectFactory.clonePointer(this), FfiConverterBool.lower(enabled));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(FfiConverterTypeNotificationSettingsError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Sets a custom push rule with the given actions and conditions.
     */
    async setCustomPushRule(ruleId, ruleKind, actions, conditions, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_custom_push_rule(uniffiTypeNotificationSettingsObjectFactory.clonePointer(this), FfiConverterString.lower(ruleId), FfiConverterTypeRuleKind.lower(ruleKind), FfiConverterArrayTypeAction.lower(actions), FfiConverterArrayTypePushCondition.lower(conditions));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(FfiConverterTypeNotificationSettingsError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Set the default room notification mode
     *
     * # Arguments
     *
     * * `is_encrypted` - whether the mode is for encrypted rooms
     * * `is_one_to_one` - whether the mode is for direct chats involving two
     * people
     * * `mode` - the new default mode
     */
    async setDefaultRoomNotificationMode(isEncrypted, isOneToOne, mode, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_default_room_notification_mode(uniffiTypeNotificationSettingsObjectFactory.clonePointer(this), FfiConverterBool.lower(isEncrypted), FfiConverterBool.lower(isOneToOne), FfiConverterTypeRoomNotificationMode.lower(mode));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(FfiConverterTypeNotificationSettingsError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    setDelegate(delegate) {
        uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_delegate(uniffiTypeNotificationSettingsObjectFactory.clonePointer(this), FfiConverterOptionalTypeNotificationSettingsDelegate.lower(delegate), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift);
    }
    /**
     * Set whether the `.m.rule.invite_for_me` push rule is enabled
     */
    async setInviteForMeEnabled(enabled, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_invite_for_me_enabled(uniffiTypeNotificationSettingsObjectFactory.clonePointer(this), FfiConverterBool.lower(enabled));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(FfiConverterTypeNotificationSettingsError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Set whether room mentions are enabled.
     */
    async setRoomMentionEnabled(enabled, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_room_mention_enabled(uniffiTypeNotificationSettingsObjectFactory.clonePointer(this), FfiConverterBool.lower(enabled));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(FfiConverterTypeNotificationSettingsError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Set the notification mode for a room.
     */
    async setRoomNotificationMode(roomId, mode, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_room_notification_mode(uniffiTypeNotificationSettingsObjectFactory.clonePointer(this), FfiConverterString.lower(roomId), FfiConverterTypeRoomNotificationMode.lower(mode));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(FfiConverterTypeNotificationSettingsError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Set whether user mentions are enabled.
     */
    async setUserMentionEnabled(enabled, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_user_mention_enabled(uniffiTypeNotificationSettingsObjectFactory.clonePointer(this), FfiConverterBool.lower(enabled));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(FfiConverterTypeNotificationSettingsError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Unmute a room.
     *
     * # Arguments
     *
     * * `room_id` - the room to unmute
     * * `is_encrypted` - whether the room is encrypted
     * * `is_one_to_one` - whether the room is a direct chat involving two
     * people
     */
    async unmuteRoom(roomId, isEncrypted, isOneToOne, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_notificationsettings_unmute_room(uniffiTypeNotificationSettingsObjectFactory.clonePointer(this), FfiConverterString.lower(roomId), FfiConverterBool.lower(isEncrypted), FfiConverterBool.lower(isOneToOne));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeNotificationSettingsError.lift.bind(FfiConverterTypeNotificationSettingsError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeNotificationSettingsObjectFactory.pointer(this);
            uniffiTypeNotificationSettingsObjectFactory.freePointer(pointer);
            uniffiTypeNotificationSettingsObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeNotificationSettingsObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeNotificationSettingsObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeNotificationSettingsObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(NotificationSettings.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "NotificationSettings";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_notificationsettings(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_notificationsettings(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "NotificationSettings";
        },
    };
})();
// FfiConverter for NotificationSettingsInterface
const FfiConverterTypeNotificationSettings = new FfiConverterObject(uniffiTypeNotificationSettingsObjectFactory);
/**
 * Data for the QR code login mechanism.
 *
 * The [`QrCodeData`] can be serialized and encoded as a QR code or it can be
 * decoded from a QR code.
 */
export class QrCodeData extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "QrCodeData";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeQrCodeDataObjectFactory.bless(pointer);
    }
    /**
     * Attempt to decode a slice of bytes into a [`QrCodeData`] object.
     *
     * The slice of bytes would generally be returned by a QR code decoder.
     */
    static fromBytes(bytes) {
        return FfiConverterTypeQrCodeData.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeQrCodeDecodeError.lift.bind(FfiConverterTypeQrCodeDecodeError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_qrcodedata_from_bytes(FfiConverterArrayBuffer.lower(bytes), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * The server name contained within the scanned QR code data.
     *
     * Note: This value is only present when scanning a QR code the belongs to
     * a logged in client. The mode where the new client shows the QR code
     * will return `None`.
     */
    serverName() {
        return FfiConverterOptionalString.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_qrcodedata_server_name(uniffiTypeQrCodeDataObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeQrCodeDataObjectFactory.pointer(this);
            uniffiTypeQrCodeDataObjectFactory.freePointer(pointer);
            uniffiTypeQrCodeDataObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeQrCodeDataObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeQrCodeDataObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeQrCodeDataObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(QrCodeData.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "QrCodeData";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_qrcodedata(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_qrcodedata(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "QrCodeData";
        },
    };
})();
// FfiConverter for QrCodeDataInterface
const FfiConverterTypeQrCodeData = new FfiConverterObject(uniffiTypeQrCodeDataObjectFactory);
export class Room extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "Room";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeRoomObjectFactory.bless(pointer);
    }
    activeMembersCount() {
        return FfiConverterUInt64.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_active_members_count(uniffiTypeRoomObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Returns a Vec of userId's that participate in the room call.
     *
     * MatrixRTC memberships with application "m.call" and scope "m.room" are
     * considered. A user can occur twice if they join with two devices.
     * convert to a set depending if the different users are required or the
     * amount of sessions.
     *
     * The vector is ordered by oldest membership user to newest.
     */
    activeRoomCallParticipants() {
        return FfiConverterArrayString.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_active_room_call_participants(uniffiTypeRoomObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    alternativeAliases() {
        return FfiConverterArrayString.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_alternative_aliases(uniffiTypeRoomObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    async applyPowerLevelChanges(changes, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_apply_power_level_changes(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterTypeRoomPowerLevelChanges.lower(changes));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    avatarUrl() {
        return FfiConverterOptionalString.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_avatar_url(uniffiTypeRoomObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    async banUser(userId, reason, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_ban_user(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(userId), FfiConverterOptionalString.lower(reason));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    canonicalAlias() {
        return FfiConverterOptionalString.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_canonical_alias(uniffiTypeRoomObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Remove the `ComposerDraft` stored in the state store for this room.
     */
    async clearComposerDraft(threadRoot, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_clear_composer_draft(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterOptionalString.lower(threadRoot));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Clear the event cache storage for the current room.
     *
     * This will remove all the information related to the event cache, in
     * memory and in the persisted storage, if enabled.
     */
    async clearEventCacheStorage(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_clear_event_cache_storage(uniffiTypeRoomObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Declines a call (and stop ringing).
     *
     * # Arguments
     *
     * * `rtc_notification_event_id` - the event id of the m.rtc.notification
     * event.
     */
    async declineCall(rtcNotificationEventId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_decline_call(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(rtcNotificationEventId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Forces the currently active room key, which is used to encrypt messages,
     * to be rotated.
     *
     * A new room key will be crated and shared with all the room members the
     * next time a message will be sent. You don't have to call this method,
     * room keys will be rotated automatically when necessary. This method is
     * still useful for debugging purposes.
     */
    async discardRoomKey(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_discard_room_key(uniffiTypeRoomObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Returns the room's name from the state event if available, otherwise
     * compute a room name based on the room's nature (DM or not) and number of
     * members.
     */
    displayName() {
        return FfiConverterOptionalString.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_display_name(uniffiTypeRoomObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Edit an event given its event id.
     *
     * Useful outside the context of a timeline, or when a timeline doesn't
     * have the full content of an event.
     */
    async edit(eventId, newContent, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_edit(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(eventId), FfiConverterTypeRoomMessageEventContentWithoutRelation.lower(newContent));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Enable End-to-end encryption in this room.
     */
    async enableEncryption(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_enable_encryption(uniffiTypeRoomObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Enable or disable the send queue for that particular room.
     */
    enableSendQueue(enable) {
        uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_enable_send_queue(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterBool.lower(enable), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift);
    }
    encryptionState() {
        return FfiConverterTypeEncryptionState.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_encryption_state(uniffiTypeRoomObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Return the current MSC4306 thread subscription for the given thread root
     * in this room.
     *
     * Returns `None` if the thread doesn't exist, or isn't subscribed to, or
     * the server can't handle MSC4306; otherwise, returns the thread
     * subscription status.
     */
    async fetchThreadSubscription(threadRootEventId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_fetch_thread_subscription(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(threadRootEventId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterOptionalTypeThreadSubscription.lift.bind(FfiConverterOptionalTypeThreadSubscription), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Forget this room.
     *
     * This communicates to the homeserver that it should forget the room.
     *
     * Only left or banned-from rooms can be forgotten.
     */
    async forget(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_forget(uniffiTypeRoomObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async getPowerLevels(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_get_power_levels(uniffiTypeRoomObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeRoomPowerLevels.lift.bind(FfiConverterTypeRoomPowerLevels), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Returns the visibility for this room in the room directory.
     *
     * [Public](`RoomVisibility::Public`) rooms are listed in the room
     * directory and can be found using it.
     */
    async getRoomVisibility(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_get_room_visibility(uniffiTypeRoomObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterTypeRoomVisibility.lift.bind(FfiConverterTypeRoomVisibility), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Is there a non expired membership with application "m.call" and scope
     * "m.room" in this room.
     */
    hasActiveRoomCall() {
        return FfiConverterBool.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_has_active_room_call(uniffiTypeRoomObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Returns the room heroes for this room.
     */
    heroes() {
        return FfiConverterArrayTypeRoomHero.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_heroes(uniffiTypeRoomObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    id() {
        return FfiConverterString.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_id(uniffiTypeRoomObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Set the local trust for the given devices to `LocalTrust::Ignored`
     * and resend messages that failed to send because said devices are
     * unverified (in response to
     * `SessionRecipientCollectionError::VerifiedUserHasUnsignedDevice`).
     * # Arguments
     *
     * * `devices` - The map of users identifiers to device identifiers
     * received in the error
     * * `transaction_id` - The send queue transaction identifier of the local
     * echo the send error applies to
     */
    async ignoreDeviceTrustAndResend(devices, sendHandle, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_ignore_device_trust_and_resend(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterMapStringArrayString.lower(devices), FfiConverterTypeSendHandle.lower(sendHandle));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Ignores a user.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user to ignore.
     */
    async ignoreUser(userId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_ignore_user(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(userId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async inviteUserById(userId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_invite_user_by_id(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(userId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    invitedMembersCount() {
        return FfiConverterUInt64.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_invited_members_count(uniffiTypeRoomObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Get the user who created the invite, if any.
     */
    async inviter(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_inviter(uniffiTypeRoomObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterOptionalTypeRoomMember.lift.bind(FfiConverterOptionalTypeRoomMember), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async isDirect(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_is_direct(uniffiTypeRoomObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Checks whether the room is encrypted or not.
     *
     * **Note**: this info may not be reliable if you don't set up
     * `m.room.encryption` as required state.
     */
    async isEncrypted(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_is_encrypted(uniffiTypeRoomObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Whether the room can be publicly joined or not, based on its join rule.
     *
     * Can return `None` if the join rule state event is missing.
     */
    isPublic() {
        return FfiConverterOptionalBool.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_is_public(uniffiTypeRoomObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Returns whether the send queue for that particular room is enabled or
     * not.
     */
    isSendQueueEnabled() {
        return FfiConverterBool.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_is_send_queue_enabled(uniffiTypeRoomObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    isSpace() {
        return FfiConverterBool.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_is_space(uniffiTypeRoomObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Join this room.
     *
     * Only invited and left rooms can be joined via this method.
     */
    async join(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_join(uniffiTypeRoomObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    joinedMembersCount() {
        return FfiConverterUInt64.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_joined_members_count(uniffiTypeRoomObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    async kickUser(userId, reason, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_kick_user(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(userId), FfiConverterOptionalString.lower(reason));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async latestEncryptionState(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_latest_encryption_state(uniffiTypeRoomObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterTypeEncryptionState.lift.bind(FfiConverterTypeEncryptionState), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async latestEvent(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_latest_event(uniffiTypeRoomObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterOptionalTypeEventTimelineItem.lift.bind(FfiConverterOptionalTypeEventTimelineItem), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Leave this room.
     *
     * Only invited and joined rooms can be left.
     */
    async leave(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_leave(uniffiTypeRoomObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Retrieve the `ComposerDraft` stored in the state store for this room.
     */
    async loadComposerDraft(threadRoot, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_load_composer_draft(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterOptionalString.lower(threadRoot));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterOptionalTypeComposerDraft.lift.bind(FfiConverterOptionalTypeComposerDraft), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Either loads the event associated with the `event_id` from the event
     * cache or fetches it from the homeserver.
     */
    async loadOrFetchEvent(eventId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_load_or_fetch_event(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(eventId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeTimelineEvent.lift.bind(FfiConverterTypeTimelineEvent), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Mark a room as fully read, by attaching a read receipt to the provided
     * `event_id`.
     *
     * **Warning:** using this method is **NOT** recommended, as providing the
     * latest event id can cause incorrect read receipts. This method won't
     * check if sending the read receipt is necessary or valid. It should
     * *only* be used when some constraint prevents you from instantiating a
     * [`Timeline`]. For any other case use [`Timeline::mark_as_read`]
     * instead.
     */
    async markAsFullyReadUnchecked(eventId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_mark_as_fully_read_unchecked(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(eventId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Mark a room as read, by attaching a read receipt on the latest event.
     *
     * Note: this does NOT unset the unread flag; it's the caller's
     * responsibility to do so, if need be.
     */
    async markAsRead(receiptType, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_mark_as_read(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterTypeReceiptType.lower(receiptType));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async matrixToEventPermalink(eventId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_matrix_to_event_permalink(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(eventId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async matrixToPermalink(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_matrix_to_permalink(uniffiTypeRoomObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async member(userId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_member(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(userId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterTypeRoomMember.lift.bind(FfiConverterTypeRoomMember), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async memberAvatarUrl(userId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_member_avatar_url(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(userId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterOptionalString.lift.bind(FfiConverterOptionalString), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async memberDisplayName(userId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_member_display_name(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(userId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterOptionalString.lift.bind(FfiConverterOptionalString), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Get the membership details for the current user.
     *
     * Returns:
     * - If the user was present in the room, a
     * [`matrix_sdk::room::RoomMemberWithSenderInfo`] containing both the
     * user info and the member info of the sender of the `m.room.member`
     * event.
     * - If the current user is not present, an error.
     */
    async memberWithSenderInfo(userId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_member_with_sender_info(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(userId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterTypeRoomMemberWithSenderInfo.lift.bind(FfiConverterTypeRoomMemberWithSenderInfo), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async members(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_members(uniffiTypeRoomObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeRoomMembersIterator.lift.bind(FfiConverterTypeRoomMembersIterator), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async membersNoSync(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_members_no_sync(uniffiTypeRoomObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeRoomMembersIterator.lift.bind(FfiConverterTypeRoomMembersIterator), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * The room's current membership state.
     */
    membership() {
        return FfiConverterTypeMembership.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_membership(uniffiTypeRoomObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    async newLatestEvent(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_new_latest_event(uniffiTypeRoomObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterTypeLatestEventValue.lift.bind(FfiConverterTypeLatestEventValue), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    ownUserId() {
        return FfiConverterString.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_own_user_id(uniffiTypeRoomObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * If this room is the successor of a tombstoned room, return the
     * reference to the predecessor room.
     *
     * A room is tombstoned if it has received a [`m.room.tombstone`] state
     * event.
     *
     * To determine if a room is the successor of a tombstoned room, the
     * [`m.room.create`] must have been received, **with** a `predecessor`
     * field.
     *
     * [`m.room.tombstone`]: https://spec.matrix.org/v1.14/client-server-api/#mroomtombstone
     * [`m.room.create`]: https://spec.matrix.org/v1.14/client-server-api/#mroomcreate
     */
    predecessorRoom() {
        return FfiConverterOptionalTypePredecessorRoom.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_predecessor_room(uniffiTypeRoomObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Builds a `RoomPreview` from a room list item. This is intended for
     * invited, knocked or banned rooms.
     */
    async previewRoom(via, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_preview_room(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterArrayString.lower(via));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeRoomPreview.lift.bind(FfiConverterTypeRoomPreview), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Publish a new room alias for this room in the room directory.
     *
     * Returns:
     * - `true` if the room alias didn't exist and it's now published.
     * - `false` if the room alias was already present so it couldn't be
     * published.
     */
    async publishRoomAliasInRoomDirectory(alias, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_publish_room_alias_in_room_directory(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(alias));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * The raw name as present in the room state event.
     */
    rawName() {
        return FfiConverterOptionalString.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_raw_name(uniffiTypeRoomObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Redacts an event from the room.
     *
     * # Arguments
     *
     * * `event_id` - The ID of the event to redact
     *
     * * `reason` - The reason for the event being redacted (optional). its
     * transaction ID (optional). If not given one is created.
     */
    async redact(eventId, reason, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_redact(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(eventId), FfiConverterOptionalString.lower(reason));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Removes the current room avatar
     */
    async removeAvatar(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_remove_avatar(uniffiTypeRoomObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Remove an existing room alias for this room in the room directory.
     *
     * Returns:
     * - `true` if the room alias was present and it's now removed from the
     * room directory.
     * - `false` if the room alias didn't exist so it couldn't be removed.
     */
    async removeRoomAliasFromRoomDirectory(alias, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_remove_room_alias_from_room_directory(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(alias));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Reports an event from the room.
     *
     * # Arguments
     *
     * * `event_id` - The ID of the event to report
     *
     * * `reason` - The reason for the event being reported (optional).
     *
     * * `score` - The score to rate this content as where -100 is most
     * offensive and 0 is inoffensive (optional).
     */
    async reportContent(eventId, score, reason, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_report_content(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(eventId), FfiConverterOptionalInt32.lower(score), FfiConverterOptionalString.lower(reason));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Reports a room as inappropriate to the server.
     * The caller is not required to be joined to the room to report it.
     *
     * # Arguments
     *
     * * `reason` - The reason the room is being reported.
     *
     * # Errors
     *
     * Returns an error if the room is not found or on rate limit
     */
    async reportRoom(reason, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_report_room(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(reason));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async resetPowerLevels(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_reset_power_levels(uniffiTypeRoomObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeRoomPowerLevels.lift.bind(FfiConverterTypeRoomPowerLevels), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Return a debug representation for the internal room events data
     * structure, one line per entry in the resulting vector.
     */
    async roomEventsDebugString(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_room_events_debug_string(uniffiTypeRoomObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterArrayString.lift.bind(FfiConverterArrayString), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async roomInfo(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_room_info(uniffiTypeRoomObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterTypeRoomInfo.lift.bind(FfiConverterTypeRoomInfo), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Store the given `ComposerDraft` in the state store using the current
     * room id, as identifier.
     */
    async saveComposerDraft(draft, threadRoot, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_save_composer_draft(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterTypeComposerDraft.lower(draft), FfiConverterOptionalString.lower(threadRoot));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Send the current users live location beacon in the room.
     */
    async sendLiveLocation(geoUri, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_send_live_location(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(geoUri));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Send a raw event to the room.
     *
     * # Arguments
     *
     * * `event_type` - The type of the event to send.
     *
     * * `content` - The content of the event to send encoded as JSON string.
     */
    async sendRaw(eventType, content, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_send_raw(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(eventType), FfiConverterString.lower(content));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async setIsFavourite(isFavourite, tagOrder, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_set_is_favourite(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterBool.lower(isFavourite), FfiConverterOptionalFloat64.lower(tagOrder));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async setIsLowPriority(isLowPriority, tagOrder, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_set_is_low_priority(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterBool.lower(isLowPriority), FfiConverterOptionalFloat64.lower(tagOrder));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Sets a new name to the room.
     */
    async setName(name, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_set_name(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(name));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Set a MSC4306 subscription to a thread in this room, based on the thread
     * root event id.
     *
     * If `subscribed` is `true`, it will subscribe to the thread, with a
     * precision that the subscription was manually requested by the user
     * (i.e. not automatic).
     *
     * If the thread was already subscribed to (resp. unsubscribed from), while
     * trying to subscribe to it (resp. unsubscribe from it), it will do
     * nothing, i.e. subscribing (resp. unsubscribing) to a thread is an
     * idempotent operation.
     */
    async setThreadSubscription(threadRootEventId, subscribed, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_set_thread_subscription(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(threadRootEventId), FfiConverterBool.lower(subscribed));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Sets a new topic in the room.
     */
    async setTopic(topic, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_set_topic(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(topic));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Set (or unset) a flag on the room to indicate that the user has
     * explicitly marked it as unread.
     */
    async setUnreadFlag(newValue, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_set_unread_flag(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterBool.lower(newValue));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Start the current users live location share in the room.
     */
    async startLiveLocationShare(durationMillis, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_start_live_location_share(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterUInt64.lower(durationMillis));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Stop the current users live location share in the room.
     */
    async stopLiveLocationShare(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_stop_live_location_share(uniffiTypeRoomObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Subscribes to call decline for a currently ringing call, using a
     * `listener` to be notified when someone declines.
     *
     * Will error if `rtc_notification_event_id` is not a valid event id.
     * Use the [`TaskHandle`] to cancel the subscription.
     */
    subscribeToCallDeclineEvents(rtcNotificationEventId, listener) {
        return FfiConverterTypeTaskHandle.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_call_decline_events(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(rtcNotificationEventId), FfiConverterTypeCallDeclineListener.lower(listener), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    async subscribeToIdentityStatusChanges(listener, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_identity_status_changes(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterTypeIdentityStatusChangeListener.lower(listener));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeTaskHandle.lift.bind(FfiConverterTypeTaskHandle), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Subscribes to requests to join this room (knock member events), using a
     * `listener` to be notified of the changes.
     *
     * The current requests to join the room will be emitted immediately
     * when subscribing, along with a [`TaskHandle`] to cancel the
     * subscription.
     */
    async subscribeToKnockRequests(listener, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_knock_requests(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterTypeKnockRequestsListener.lower(listener));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeTaskHandle.lift.bind(FfiConverterTypeTaskHandle), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Subscribes to live location shares in this room, using a `listener` to
     * be notified of the changes.
     *
     * The current live location shares will be emitted immediately when
     * subscribing, along with a [`TaskHandle`] to cancel the subscription.
     */
    subscribeToLiveLocationShares(listener) {
        return FfiConverterTypeTaskHandle.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_live_location_shares(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterTypeLiveLocationShareListener.lower(listener), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    subscribeToRoomInfoUpdates(listener) {
        return FfiConverterTypeTaskHandle.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_room_info_updates(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterTypeRoomInfoListener.lower(listener), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Subscribe to all send queue updates in this room.
     *
     * The given listener will be immediately called with
     * `RoomSendQueueUpdate::NewLocalEvent` for each local echo existing in
     * the queue.
     */
    async subscribeToSendQueueUpdates(listener, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_send_queue_updates(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterTypeSendQueueListener.lower(listener));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeTaskHandle.lift.bind(FfiConverterTypeTaskHandle), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    subscribeToTypingNotifications(listener) {
        return FfiConverterTypeTaskHandle.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_typing_notifications(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterTypeTypingNotificationsListener.lower(listener), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * If this room is tombstoned, return the reference to the successor room
     * i.e. the room replacing this one.
     *
     * A room is tombstoned if it has received a [`m.room.tombstone`] state
     * event.
     *
     * [`m.room.tombstone`]: https://spec.matrix.org/v1.14/client-server-api/#mroomtombstone
     */
    successorRoom() {
        return FfiConverterOptionalTypeSuccessorRoom.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_successor_room(uniffiTypeRoomObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    async suggestedRoleForUser(userId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_suggested_role_for_user(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(userId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterTypeRoomMemberRole.lift.bind(FfiConverterTypeRoomMemberRole), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Create a timeline with a default configuration, i.e. a live timeline
     * with read receipts and read marker tracking.
     */
    async timeline(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_timeline(uniffiTypeRoomObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeTimeline.lift.bind(FfiConverterTypeTimeline), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Build a new timeline instance with the given configuration.
     */
    async timelineWithConfiguration(configuration, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_timeline_with_configuration(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterTypeTimelineConfiguration.lower(configuration));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeTimeline.lift.bind(FfiConverterTypeTimeline), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    topic() {
        return FfiConverterOptionalString.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_topic(uniffiTypeRoomObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    async typingNotice(isTyping, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_typing_notice(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterBool.lower(isTyping));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async unbanUser(userId, reason, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_unban_user(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(userId), FfiConverterOptionalString.lower(reason));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Update the canonical alias of the room.
     *
     * Note that publishing the alias in the room directory is done separately.
     */
    async updateCanonicalAlias(alias, altAliases, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_update_canonical_alias(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterOptionalString.lower(alias), FfiConverterArrayString.lower(altAliases));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Update room history visibility for this room.
     */
    async updateHistoryVisibility(visibility, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_update_history_visibility(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterTypeRoomHistoryVisibility.lower(visibility));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Update the join rule for this room.
     */
    async updateJoinRules(newRule, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_update_join_rules(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterTypeJoinRule.lower(newRule));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async updatePowerLevelsForUsers(updates, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_update_power_levels_for_users(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterArrayTypeUserPowerLevelUpdate.lower(updates));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Update the room's visibility in the room directory.
     */
    async updateRoomVisibility(visibility, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_update_room_visibility(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterTypeRoomVisibility.lower(visibility));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Upload and set the room's avatar.
     *
     * This will upload the data produced by the reader to the homeserver's
     * content repository, and set the room's avatar to the MXC URI for the
     * uploaded file.
     *
     * # Arguments
     *
     * * `mime_type` - The mime description of the avatar, for example
     * image/jpeg
     * * `data` - The raw data that will be uploaded to the homeserver's
     * content repository
     * * `media_info` - The media info used as avatar image info.
     */
    async uploadAvatar(mimeType, data, mediaInfo, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_upload_avatar(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterString.lower(mimeType), FfiConverterArrayBuffer.lower(data), FfiConverterOptionalTypeImageInfo.lower(mediaInfo));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Remove verification requirements for the given users and
     * resend messages that failed to send because their identities were no
     * longer verified (in response to
     * `SessionRecipientCollectionError::VerifiedUserChangedIdentity`)
     *
     * # Arguments
     *
     * * `user_ids` - The list of users identifiers received in the error
     * * `transaction_id` - The send queue transaction identifier of the local
     * echo the send error applies to
     */
    async withdrawVerificationAndResend(userIds, sendHandle, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_room_withdraw_verification_and_resend(uniffiTypeRoomObjectFactory.clonePointer(this), FfiConverterArrayString.lower(userIds), FfiConverterTypeSendHandle.lower(sendHandle));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeRoomObjectFactory.pointer(this);
            uniffiTypeRoomObjectFactory.freePointer(pointer);
            uniffiTypeRoomObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeRoomObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeRoomObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeRoomObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(Room.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "Room";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_room(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_room(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "Room";
        },
    };
})();
// FfiConverter for RoomInterface
const FfiConverterTypeRoom = new FfiConverterObject(uniffiTypeRoomObjectFactory);
/**
 * A helper for performing room searches in the room directory.
 * The way this is intended to be used is:
 *
 * 1. Register a callback using [`RoomDirectorySearch::results`].
 * 2. Start the room search with [`RoomDirectorySearch::search`].
 * 3. To get more results, use [`RoomDirectorySearch::next_page`].
 */
export class RoomDirectorySearch extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "RoomDirectorySearch";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeRoomDirectorySearchObjectFactory.bless(pointer);
    }
    /**
     * Get whether the search is at the last page.
     */
    async isAtLastPage(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_is_at_last_page(uniffiTypeRoomDirectorySearchObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Get the number of pages that have been loaded so far.
     */
    async loadedPages(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_loaded_pages(uniffiTypeRoomDirectorySearchObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_u32, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_u32, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_u32, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_u32, 
            /*liftFunc:*/ FfiConverterUInt32.lift.bind(FfiConverterUInt32), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Asks the server for the next page of the current search.
     */
    async nextPage(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_next_page(uniffiTypeRoomDirectorySearchObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Registers a callback to receive new search results when starting a
     * search or getting new paginated results.
     */
    async results(listener, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_results(uniffiTypeRoomDirectorySearchObjectFactory.clonePointer(this), FfiConverterTypeRoomDirectorySearchEntriesListener.lower(listener));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeTaskHandle.lift.bind(FfiConverterTypeTaskHandle), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Starts a filtered search for the server.
     *
     * If the `filter` is not provided it will search for all the rooms.
     * You can specify a `batch_size` to control the number of rooms to fetch
     * per request.
     *
     * If the `via_server` is not provided it will search in the current
     * homeserver by default.
     *
     * This method will clear the current search results and start a new one.
     */
    async search(filter, batchSize, viaServerName, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_search(uniffiTypeRoomDirectorySearchObjectFactory.clonePointer(this), FfiConverterOptionalString.lower(filter), FfiConverterUInt32.lower(batchSize), FfiConverterOptionalString.lower(viaServerName));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeRoomDirectorySearchObjectFactory.pointer(this);
            uniffiTypeRoomDirectorySearchObjectFactory.freePointer(pointer);
            uniffiTypeRoomDirectorySearchObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeRoomDirectorySearchObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeRoomDirectorySearchObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeRoomDirectorySearchObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(RoomDirectorySearch.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "RoomDirectorySearch";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roomdirectorysearch(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roomdirectorysearch(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "RoomDirectorySearch";
        },
    };
})();
// FfiConverter for RoomDirectorySearchInterface
const FfiConverterTypeRoomDirectorySearch = new FfiConverterObject(uniffiTypeRoomDirectorySearchObjectFactory);
export class RoomList extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "RoomList";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeRoomListObjectFactory.bless(pointer);
    }
    entriesWithDynamicAdapters(pageSize, listener) {
        return FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlist_entries_with_dynamic_adapters(uniffiTypeRoomListObjectFactory.clonePointer(this), FfiConverterUInt32.lower(pageSize), FfiConverterTypeRoomListEntriesListener.lower(listener), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    entriesWithDynamicAdaptersWith(pageSize, enableLatestEventSorter, listener) {
        return FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlist_entries_with_dynamic_adapters_with(uniffiTypeRoomListObjectFactory.clonePointer(this), FfiConverterUInt32.lower(pageSize), FfiConverterBool.lower(enableLatestEventSorter), FfiConverterTypeRoomListEntriesListener.lower(listener), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    loadingState(listener) {
        return FfiConverterTypeRoomListLoadingStateResult.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeRoomListError.lift.bind(FfiConverterTypeRoomListError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlist_loading_state(uniffiTypeRoomListObjectFactory.clonePointer(this), FfiConverterTypeRoomListLoadingStateListener.lower(listener), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    room(roomId) {
        return FfiConverterTypeRoom.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeRoomListError.lift.bind(FfiConverterTypeRoomListError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlist_room(uniffiTypeRoomListObjectFactory.clonePointer(this), FfiConverterString.lower(roomId), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeRoomListObjectFactory.pointer(this);
            uniffiTypeRoomListObjectFactory.freePointer(pointer);
            uniffiTypeRoomListObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeRoomListObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeRoomListObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeRoomListObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(RoomList.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "RoomList";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roomlist(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roomlist(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "RoomList";
        },
    };
})();
// FfiConverter for RoomListInterface
const FfiConverterTypeRoomList = new FfiConverterObject(uniffiTypeRoomListObjectFactory);
export class RoomListDynamicEntriesController extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "RoomListDynamicEntriesController";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeRoomListDynamicEntriesControllerObjectFactory.bless(pointer);
    }
    addOnePage() {
        uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_add_one_page(uniffiTypeRoomListDynamicEntriesControllerObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift);
    }
    resetToOnePage() {
        uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_reset_to_one_page(uniffiTypeRoomListDynamicEntriesControllerObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift);
    }
    setFilter(kind) {
        return FfiConverterBool.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_set_filter(uniffiTypeRoomListDynamicEntriesControllerObjectFactory.clonePointer(this), FfiConverterTypeRoomListEntriesDynamicFilterKind.lower(kind), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeRoomListDynamicEntriesControllerObjectFactory.pointer(this);
            uniffiTypeRoomListDynamicEntriesControllerObjectFactory.freePointer(pointer);
            uniffiTypeRoomListDynamicEntriesControllerObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeRoomListDynamicEntriesControllerObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeRoomListDynamicEntriesControllerObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeRoomListDynamicEntriesControllerObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(RoomListDynamicEntriesController.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "RoomListDynamicEntriesController";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roomlistdynamicentriescontroller(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roomlistdynamicentriescontroller(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "RoomListDynamicEntriesController";
        },
    };
})();
// FfiConverter for RoomListDynamicEntriesControllerInterface
const FfiConverterTypeRoomListDynamicEntriesController = new FfiConverterObject(uniffiTypeRoomListDynamicEntriesControllerObjectFactory);
export class RoomListEntriesWithDynamicAdaptersResult extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "RoomListEntriesWithDynamicAdaptersResult";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory.bless(pointer);
    }
    controller() {
        return FfiConverterTypeRoomListDynamicEntriesController.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistentrieswithdynamicadaptersresult_controller(uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    entriesStream() {
        return FfiConverterTypeTaskHandle.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistentrieswithdynamicadaptersresult_entries_stream(uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory.pointer(this);
            uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory.freePointer(pointer);
            uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(RoomListEntriesWithDynamicAdaptersResult.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "RoomListEntriesWithDynamicAdaptersResult";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roomlistentrieswithdynamicadaptersresult(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roomlistentrieswithdynamicadaptersresult(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "RoomListEntriesWithDynamicAdaptersResult";
        },
    };
})();
// FfiConverter for RoomListEntriesWithDynamicAdaptersResultInterface
const FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult = new FfiConverterObject(uniffiTypeRoomListEntriesWithDynamicAdaptersResultObjectFactory);
export class RoomListService extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "RoomListService";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeRoomListServiceObjectFactory.bless(pointer);
    }
    async allRooms(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistservice_all_rooms(uniffiTypeRoomListServiceObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeRoomList.lift.bind(FfiConverterTypeRoomList), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeRoomListError.lift.bind(FfiConverterTypeRoomListError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    room(roomId) {
        return FfiConverterTypeRoom.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeRoomListError.lift.bind(FfiConverterTypeRoomListError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistservice_room(uniffiTypeRoomListServiceObjectFactory.clonePointer(this), FfiConverterString.lower(roomId), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    state(listener) {
        return FfiConverterTypeTaskHandle.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistservice_state(uniffiTypeRoomListServiceObjectFactory.clonePointer(this), FfiConverterTypeRoomListServiceStateListener.lower(listener), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    async subscribeToRooms(roomIds, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistservice_subscribe_to_rooms(uniffiTypeRoomListServiceObjectFactory.clonePointer(this), FfiConverterArrayString.lower(roomIds));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeRoomListError.lift.bind(FfiConverterTypeRoomListError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    syncIndicator(delayBeforeShowingInMs, delayBeforeHidingInMs, listener) {
        return FfiConverterTypeTaskHandle.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roomlistservice_sync_indicator(uniffiTypeRoomListServiceObjectFactory.clonePointer(this), FfiConverterUInt32.lower(delayBeforeShowingInMs), FfiConverterUInt32.lower(delayBeforeHidingInMs), FfiConverterTypeRoomListServiceSyncIndicatorListener.lower(listener), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeRoomListServiceObjectFactory.pointer(this);
            uniffiTypeRoomListServiceObjectFactory.freePointer(pointer);
            uniffiTypeRoomListServiceObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeRoomListServiceObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeRoomListServiceObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeRoomListServiceObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(RoomListService.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "RoomListService";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roomlistservice(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roomlistservice(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "RoomListService";
        },
    };
})();
// FfiConverter for RoomListServiceInterface
const FfiConverterTypeRoomListService = new FfiConverterObject(uniffiTypeRoomListServiceObjectFactory);
export class RoomMembersIterator extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "RoomMembersIterator";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeRoomMembersIteratorObjectFactory.bless(pointer);
    }
    len() {
        return FfiConverterUInt32.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roommembersiterator_len(uniffiTypeRoomMembersIteratorObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    nextChunk(chunkSize) {
        return FfiConverterOptionalArrayTypeRoomMember.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roommembersiterator_next_chunk(uniffiTypeRoomMembersIteratorObjectFactory.clonePointer(this), FfiConverterUInt32.lower(chunkSize), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeRoomMembersIteratorObjectFactory.pointer(this);
            uniffiTypeRoomMembersIteratorObjectFactory.freePointer(pointer);
            uniffiTypeRoomMembersIteratorObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeRoomMembersIteratorObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeRoomMembersIteratorObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeRoomMembersIteratorObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(RoomMembersIterator.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "RoomMembersIterator";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roommembersiterator(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roommembersiterator(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "RoomMembersIterator";
        },
    };
})();
// FfiConverter for RoomMembersIteratorInterface
const FfiConverterTypeRoomMembersIterator = new FfiConverterObject(uniffiTypeRoomMembersIteratorObjectFactory);
export class RoomMessageEventContentWithoutRelation extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "RoomMessageEventContentWithoutRelation";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeRoomMessageEventContentWithoutRelationObjectFactory.bless(pointer);
    }
    withMentions(mentions) {
        return FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roommessageeventcontentwithoutrelation_with_mentions(uniffiTypeRoomMessageEventContentWithoutRelationObjectFactory.clonePointer(this), FfiConverterTypeMentions.lower(mentions), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeRoomMessageEventContentWithoutRelationObjectFactory.pointer(this);
            uniffiTypeRoomMessageEventContentWithoutRelationObjectFactory.freePointer(pointer);
            uniffiTypeRoomMessageEventContentWithoutRelationObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeRoomMessageEventContentWithoutRelationObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeRoomMessageEventContentWithoutRelationObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeRoomMessageEventContentWithoutRelationObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(RoomMessageEventContentWithoutRelation.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "RoomMessageEventContentWithoutRelation";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roommessageeventcontentwithoutrelation(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roommessageeventcontentwithoutrelation(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "RoomMessageEventContentWithoutRelation";
        },
    };
})();
// FfiConverter for RoomMessageEventContentWithoutRelationInterface
const FfiConverterTypeRoomMessageEventContentWithoutRelation = new FfiConverterObject(uniffiTypeRoomMessageEventContentWithoutRelationObjectFactory);
export class RoomPowerLevels extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "RoomPowerLevels";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeRoomPowerLevelsObjectFactory.bless(pointer);
    }
    /**
     * Returns true if the current user is able to ban in the room.
     */
    canOwnUserBan() {
        return FfiConverterBool.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_ban(uniffiTypeRoomPowerLevelsObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Returns true if the current user is able to invite in the room.
     */
    canOwnUserInvite() {
        return FfiConverterBool.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_invite(uniffiTypeRoomPowerLevelsObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Returns true if the current user is able to kick in the room.
     */
    canOwnUserKick() {
        return FfiConverterBool.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_kick(uniffiTypeRoomPowerLevelsObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Returns true if the current user is able to pin or unpin events in the
     * room.
     */
    canOwnUserPinUnpin() {
        return FfiConverterBool.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_pin_unpin(uniffiTypeRoomPowerLevelsObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Returns true if the current user user is able to redact messages of
     * other users in the room.
     */
    canOwnUserRedactOther() {
        return FfiConverterBool.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_redact_other(uniffiTypeRoomPowerLevelsObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Returns true if the current user is able to redact their own messages in
     * the room.
     */
    canOwnUserRedactOwn() {
        return FfiConverterBool.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_redact_own(uniffiTypeRoomPowerLevelsObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Returns true if the current user is able to send a specific message type
     * in the room.
     */
    canOwnUserSendMessage(message) {
        return FfiConverterBool.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_send_message(uniffiTypeRoomPowerLevelsObjectFactory.clonePointer(this), FfiConverterTypeMessageLikeEventType.lower(message), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Returns true if the current user is able to send a specific state event
     * type in the room.
     */
    canOwnUserSendState(stateEvent) {
        return FfiConverterBool.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_send_state(uniffiTypeRoomPowerLevelsObjectFactory.clonePointer(this), FfiConverterTypeStateEventType.lower(stateEvent), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Returns true if the current user is able to trigger a notification in
     * the room.
     */
    canOwnUserTriggerRoomNotification() {
        return FfiConverterBool.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_trigger_room_notification(uniffiTypeRoomPowerLevelsObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Returns true if the user with the given user_id is able to ban in the
     * room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    canUserBan(userId) {
        return FfiConverterBool.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_ban(uniffiTypeRoomPowerLevelsObjectFactory.clonePointer(this), FfiConverterString.lower(userId), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Returns true if the user with the given user_id is able to invite in the
     * room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    canUserInvite(userId) {
        return FfiConverterBool.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_invite(uniffiTypeRoomPowerLevelsObjectFactory.clonePointer(this), FfiConverterString.lower(userId), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Returns true if the user with the given user_id is able to kick in the
     * room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    canUserKick(userId) {
        return FfiConverterBool.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_kick(uniffiTypeRoomPowerLevelsObjectFactory.clonePointer(this), FfiConverterString.lower(userId), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Returns true if the user with the given user_id is able to pin or unpin
     * events in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    canUserPinUnpin(userId) {
        return FfiConverterBool.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_pin_unpin(uniffiTypeRoomPowerLevelsObjectFactory.clonePointer(this), FfiConverterString.lower(userId), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Returns true if the user with the given user_id is able to redact
     * messages of other users in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    canUserRedactOther(userId) {
        return FfiConverterBool.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_redact_other(uniffiTypeRoomPowerLevelsObjectFactory.clonePointer(this), FfiConverterString.lower(userId), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Returns true if the user with the given user_id is able to redact
     * their own messages in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    canUserRedactOwn(userId) {
        return FfiConverterBool.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_redact_own(uniffiTypeRoomPowerLevelsObjectFactory.clonePointer(this), FfiConverterString.lower(userId), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Returns true if the user with the given user_id is able to send a
     * specific message type in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    canUserSendMessage(userId, message) {
        return FfiConverterBool.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_send_message(uniffiTypeRoomPowerLevelsObjectFactory.clonePointer(this), FfiConverterString.lower(userId), FfiConverterTypeMessageLikeEventType.lower(message), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Returns true if the user with the given user_id is able to send a
     * specific state event type in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    canUserSendState(userId, stateEvent) {
        return FfiConverterBool.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_send_state(uniffiTypeRoomPowerLevelsObjectFactory.clonePointer(this), FfiConverterString.lower(userId), FfiConverterTypeStateEventType.lower(stateEvent), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Returns true if the user with the given user_id is able to trigger a
     * notification in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    canUserTriggerRoomNotification(userId) {
        return FfiConverterBool.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_trigger_room_notification(uniffiTypeRoomPowerLevelsObjectFactory.clonePointer(this), FfiConverterString.lower(userId), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Gets a map with the `UserId` of users with power levels other than `0`
     * and their power level.
     */
    userPowerLevels() {
        return FfiConverterMapStringInt64.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_user_power_levels(uniffiTypeRoomPowerLevelsObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    values() {
        return FfiConverterTypeRoomPowerLevelsValues.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_values(uniffiTypeRoomPowerLevelsObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeRoomPowerLevelsObjectFactory.pointer(this);
            uniffiTypeRoomPowerLevelsObjectFactory.freePointer(pointer);
            uniffiTypeRoomPowerLevelsObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeRoomPowerLevelsObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeRoomPowerLevelsObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeRoomPowerLevelsObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(RoomPowerLevels.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "RoomPowerLevels";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roompowerlevels(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roompowerlevels(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "RoomPowerLevels";
        },
    };
})();
// FfiConverter for RoomPowerLevelsInterface
const FfiConverterTypeRoomPowerLevels = new FfiConverterObject(uniffiTypeRoomPowerLevelsObjectFactory);
/**
 * A room preview for a room. It's intended to be used to represent rooms that
 * aren't joined yet.
 */
export class RoomPreview extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "RoomPreview";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeRoomPreviewObjectFactory.bless(pointer);
    }
    /**
     * Forget the room if we had access to it, and it was left or banned.
     */
    async forget(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompreview_forget(uniffiTypeRoomPreviewObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Returns the room info the preview contains.
     */
    info() {
        return FfiConverterTypeRoomPreviewInfo.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompreview_info(uniffiTypeRoomPreviewObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Get the user who created the invite, if any.
     */
    async inviter(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompreview_inviter(uniffiTypeRoomPreviewObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterOptionalTypeRoomMember.lift.bind(FfiConverterOptionalTypeRoomMember), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Leave the room if the room preview state is either joined, invited or
     * knocked.
     *
     * If rejecting an invite then also forget it as an extra layer of
     * protection against spam attacks.
     *
     * Will return an error otherwise.
     */
    async leave(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompreview_leave(uniffiTypeRoomPreviewObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Get the membership details for the current user.
     */
    async ownMembershipDetails(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_roompreview_own_membership_details(uniffiTypeRoomPreviewObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterOptionalTypeRoomMemberWithSenderInfo.lift.bind(FfiConverterOptionalTypeRoomMemberWithSenderInfo), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeRoomPreviewObjectFactory.pointer(this);
            uniffiTypeRoomPreviewObjectFactory.freePointer(pointer);
            uniffiTypeRoomPreviewObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeRoomPreviewObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeRoomPreviewObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeRoomPreviewObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(RoomPreview.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "RoomPreview";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_roompreview(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_roompreview(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "RoomPreview";
        },
    };
})();
// FfiConverter for RoomPreviewInterface
const FfiConverterTypeRoomPreview = new FfiConverterObject(uniffiTypeRoomPreviewObjectFactory);
export class SendAttachmentJoinHandle extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "SendAttachmentJoinHandle";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeSendAttachmentJoinHandleObjectFactory.bless(pointer);
    }
    /**
     * Cancel the current sending task.
     *
     * A subsequent call to [`Self::join`] will return immediately.
     */
    cancel() {
        uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sendattachmentjoinhandle_cancel(uniffiTypeSendAttachmentJoinHandleObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift);
    }
    /**
     * Wait until the attachment has been sent.
     *
     * If the sending had been cancelled, will return immediately.
     */
    async join(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sendattachmentjoinhandle_join(uniffiTypeSendAttachmentJoinHandleObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeRoomError.lift.bind(FfiConverterTypeRoomError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeSendAttachmentJoinHandleObjectFactory.pointer(this);
            uniffiTypeSendAttachmentJoinHandleObjectFactory.freePointer(pointer);
            uniffiTypeSendAttachmentJoinHandleObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeSendAttachmentJoinHandleObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeSendAttachmentJoinHandleObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeSendAttachmentJoinHandleObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(SendAttachmentJoinHandle.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "SendAttachmentJoinHandle";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_sendattachmentjoinhandle(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_sendattachmentjoinhandle(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "SendAttachmentJoinHandle";
        },
    };
})();
// FfiConverter for SendAttachmentJoinHandleInterface
const FfiConverterTypeSendAttachmentJoinHandle = new FfiConverterObject(uniffiTypeSendAttachmentJoinHandleObjectFactory);
/**
 * A handle to perform actions onto a local echo.
 */
export class SendHandle extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "SendHandle";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeSendHandleObjectFactory.bless(pointer);
    }
    /**
     * Try to abort the sending of the current event.
     *
     * If this returns `true`, then the sending could be aborted, because the
     * event hasn't been sent yet. Otherwise, if this returns `false`, the
     * event had already been sent and could not be aborted.
     *
     * This has an effect only on the first call; subsequent calls will always
     * return `false`.
     */
    async abort(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sendhandle_abort(uniffiTypeSendHandleObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Attempt to manually resend messages that failed to send due to issues
     * that should now have been fixed.
     *
     * This is useful for example, when there's a
     * `SessionRecipientCollectionError::VerifiedUserChangedIdentity` error;
     * the user may have re-verified on a different device and would now
     * like to send the failed message that's waiting on this device.
     *
     * # Arguments
     *
     * * `transaction_id` - The send queue transaction identifier of the local
     * echo that should be unwedged.
     */
    async tryResend(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sendhandle_try_resend(uniffiTypeSendHandleObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeSendHandleObjectFactory.pointer(this);
            uniffiTypeSendHandleObjectFactory.freePointer(pointer);
            uniffiTypeSendHandleObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeSendHandleObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeSendHandleObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeSendHandleObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(SendHandle.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "SendHandle";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_sendhandle(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_sendhandle(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "SendHandle";
        },
    };
})();
// FfiConverter for SendHandleInterface
const FfiConverterTypeSendHandle = new FfiConverterObject(uniffiTypeSendHandleObjectFactory);
export class SessionVerificationController extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "SessionVerificationController";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeSessionVerificationControllerObjectFactory.bless(pointer);
    }
    /**
     * Accept the previously acknowledged verification request
     */
    async acceptVerificationRequest(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_accept_verification_request(uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Set this particular request as the currently active one and register for
     * events pertaining it.
     * * `sender_id` - The user requesting verification.
     * * `flow_id` - - The ID that uniquely identifies the verification flow.
     */
    async acknowledgeVerificationRequest(senderId, flowId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_acknowledge_verification_request(uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(this), FfiConverterString.lower(senderId), FfiConverterString.lower(flowId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Confirm that the short auth strings match on both sides.
     */
    async approveVerification(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_approve_verification(uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Cancel the current verification request
     */
    async cancelVerification(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_cancel_verification(uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Reject the short auth string
     */
    async declineVerification(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_decline_verification(uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Request verification for the current device
     */
    async requestDeviceVerification(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_request_device_verification(uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Request verification for the given user
     */
    async requestUserVerification(userId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_request_user_verification(uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(this), FfiConverterString.lower(userId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    setDelegate(delegate) {
        uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_set_delegate(uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(this), FfiConverterOptionalTypeSessionVerificationControllerDelegate.lower(delegate), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift);
    }
    /**
     * Transition the current verification request into a SAS verification
     * flow.
     */
    async startSasVerification(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_start_sas_verification(uniffiTypeSessionVerificationControllerObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeSessionVerificationControllerObjectFactory.pointer(this);
            uniffiTypeSessionVerificationControllerObjectFactory.freePointer(pointer);
            uniffiTypeSessionVerificationControllerObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeSessionVerificationControllerObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeSessionVerificationControllerObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeSessionVerificationControllerObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(SessionVerificationController.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "SessionVerificationController";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_sessionverificationcontroller(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_sessionverificationcontroller(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "SessionVerificationController";
        },
    };
})();
// FfiConverter for SessionVerificationControllerInterface
const FfiConverterTypeSessionVerificationController = new FfiConverterObject(uniffiTypeSessionVerificationControllerObjectFactory);
export class SessionVerificationEmoji extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "SessionVerificationEmoji";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeSessionVerificationEmojiObjectFactory.bless(pointer);
    }
    description() {
        return FfiConverterString.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_description(uniffiTypeSessionVerificationEmojiObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    symbol() {
        return FfiConverterString.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_symbol(uniffiTypeSessionVerificationEmojiObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeSessionVerificationEmojiObjectFactory.pointer(this);
            uniffiTypeSessionVerificationEmojiObjectFactory.freePointer(pointer);
            uniffiTypeSessionVerificationEmojiObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeSessionVerificationEmojiObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeSessionVerificationEmojiObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeSessionVerificationEmojiObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(SessionVerificationEmoji.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "SessionVerificationEmoji";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_sessionverificationemoji(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_sessionverificationemoji(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "SessionVerificationEmoji";
        },
    };
})();
// FfiConverter for SessionVerificationEmojiInterface
const FfiConverterTypeSessionVerificationEmoji = new FfiConverterObject(uniffiTypeSessionVerificationEmojiObjectFactory);
/**
 * The `SpaceRoomList`represents a paginated list of direct rooms
 * that belong to a particular space.
 *
 * It can be used to paginate through the list (and have live updates on the
 * pagination state) as well as subscribe to changes as rooms are joined or
 * left.
 *
 * The `SpaceRoomList` also automatically subscribes to client room changes
 * and updates the list accordingly as rooms are joined or left.
 */
export class SpaceRoomList extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "SpaceRoomList";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeSpaceRoomListObjectFactory.bless(pointer);
    }
    /**
     * Ask the list to retrieve the next page if the end hasn't been reached
     * yet. Otherwise it no-ops.
     */
    async paginate(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_paginate(uniffiTypeSpaceRoomListObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Returns if the room list is currently paginating or not.
     */
    paginationState() {
        return FfiConverterTypeSpaceRoomListPaginationState.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_pagination_state(uniffiTypeSpaceRoomListObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Return the current list of rooms.
     */
    rooms() {
        return FfiConverterArrayTypeSpaceRoom.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_rooms(uniffiTypeSpaceRoomListObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Returns the space of the room list if known.
     */
    space() {
        return FfiConverterOptionalTypeSpaceRoom.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_space(uniffiTypeSpaceRoomListObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Subscribe to pagination updates.
     */
    subscribeToPaginationStateUpdates(listener) {
        return FfiConverterTypeTaskHandle.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_subscribe_to_pagination_state_updates(uniffiTypeSpaceRoomListObjectFactory.clonePointer(this), FfiConverterTypeSpaceRoomListPaginationStateListener.lower(listener), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Subscribes to room list updates.
     */
    subscribeToRoomUpdate(listener) {
        return FfiConverterTypeTaskHandle.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_subscribe_to_room_update(uniffiTypeSpaceRoomListObjectFactory.clonePointer(this), FfiConverterTypeSpaceRoomListEntriesListener.lower(listener), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Subscribe to space updates.
     */
    subscribeToSpaceUpdates(listener) {
        return FfiConverterTypeTaskHandle.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_subscribe_to_space_updates(uniffiTypeSpaceRoomListObjectFactory.clonePointer(this), FfiConverterTypeSpaceRoomListSpaceListener.lower(listener), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeSpaceRoomListObjectFactory.pointer(this);
            uniffiTypeSpaceRoomListObjectFactory.freePointer(pointer);
            uniffiTypeSpaceRoomListObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeSpaceRoomListObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeSpaceRoomListObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeSpaceRoomListObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(SpaceRoomList.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "SpaceRoomList";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_spaceroomlist(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_spaceroomlist(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "SpaceRoomList";
        },
    };
})();
// FfiConverter for SpaceRoomListInterface
const FfiConverterTypeSpaceRoomList = new FfiConverterObject(uniffiTypeSpaceRoomListObjectFactory);
/**
 * The main entry point into the Spaces facilities.
 *
 * The spaces service is responsible for retrieving one's joined rooms,
 * building a graph out of their `m.space.parent` and `m.space.child` state
 * events, and providing access to the top-level spaces and their children.
 */
export class SpaceService extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "SpaceService";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeSpaceServiceObjectFactory.bless(pointer);
    }
    async addChildToSpace(childId, spaceId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_spaceservice_add_child_to_space(uniffiTypeSpaceServiceObjectFactory.clonePointer(this), FfiConverterString.lower(childId), FfiConverterString.lower(spaceId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Returns a flattened list containing all the spaces where the user has
     * permission to send `m.space.child` state events.
     *
     * Note: Unlike [`Self::joined_spaces()`], this method does not recompute
     * the space graph, nor does it notify subscribers about changes.
     */
    async editableSpaces(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_spaceservice_editable_spaces(uniffiTypeSpaceServiceObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterArrayTypeSpaceRoom.lift.bind(FfiConverterArrayTypeSpaceRoom), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Returns all known direct-parents of a given space room ID.
     */
    async joinedParentsOfChild(childId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_spaceservice_joined_parents_of_child(uniffiTypeSpaceServiceObjectFactory.clonePointer(this), FfiConverterString.lower(childId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterArrayTypeSpaceRoom.lift.bind(FfiConverterArrayTypeSpaceRoom), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Returns a list of all the top-level joined spaces. It will eagerly
     * compute the latest version and also notify subscribers if there were
     * any changes.
     */
    async joinedSpaces(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_spaceservice_joined_spaces(uniffiTypeSpaceServiceObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterArrayTypeSpaceRoom.lift.bind(FfiConverterArrayTypeSpaceRoom), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Start a space leave process returning a [`LeaveSpaceHandle`] from which
     * rooms can be retrieved in reversed BFS order starting from the requested
     * `space_id` graph node. If the room is unknown then an error will be
     * returned.
     *
     * Once the rooms to be left are chosen the handle can be used to leave
     * them.
     */
    async leaveSpace(spaceId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_spaceservice_leave_space(uniffiTypeSpaceServiceObjectFactory.clonePointer(this), FfiConverterString.lower(spaceId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeLeaveSpaceHandle.lift.bind(FfiConverterTypeLeaveSpaceHandle), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async removeChildFromSpace(childId, spaceId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_spaceservice_remove_child_from_space(uniffiTypeSpaceServiceObjectFactory.clonePointer(this), FfiConverterString.lower(childId), FfiConverterString.lower(spaceId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Returns a `SpaceRoomList` for the given space ID.
     */
    async spaceRoomList(spaceId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_spaceservice_space_room_list(uniffiTypeSpaceServiceObjectFactory.clonePointer(this), FfiConverterString.lower(spaceId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeSpaceRoomList.lift.bind(FfiConverterTypeSpaceRoomList), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Subscribes to updates on the joined spaces list. If space rooms are
     * joined or left, the stream will yield diffs that reflect the changes.
     */
    async subscribeToJoinedSpaces(listener, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_spaceservice_subscribe_to_joined_spaces(uniffiTypeSpaceServiceObjectFactory.clonePointer(this), FfiConverterTypeSpaceServiceJoinedSpacesListener.lower(listener));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeTaskHandle.lift.bind(FfiConverterTypeTaskHandle), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeSpaceServiceObjectFactory.pointer(this);
            uniffiTypeSpaceServiceObjectFactory.freePointer(pointer);
            uniffiTypeSpaceServiceObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeSpaceServiceObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeSpaceServiceObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeSpaceServiceObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(SpaceService.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "SpaceService";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_spaceservice(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_spaceservice(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "SpaceService";
        },
    };
})();
// FfiConverter for SpaceServiceInterface
const FfiConverterTypeSpaceService = new FfiConverterObject(uniffiTypeSpaceServiceObjectFactory);
export class Span extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "Span";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    /**
     * Create a span originating at the given callsite (file, line and column).
     *
     * The target should be something like a module path, and can be referenced
     * in the filter string given to `setup_tracing`. `level` and `target`
     * for a callsite are fixed at the first creation of a span for that
     * callsite and can not be changed afterwards, i.e. the level and
     * target passed for second and following creation of a span with the same
     * callsite will be ignored.
     *
     * This function leaks a little bit of memory for each unique (file +
     * line + level + target + name) it is called with. Please make sure that
     * the number of different combinations of those parameters this can be
     * called with is constant in the final executable.
     *
     * For a span to have an effect, you must `.enter()` it at the start of a
     * logical unit of work and `.exit()` it at the end of the same (including
     * on failure). Entering registers the span in thread-local storage, so
     * future calls to `log_event` on the same thread are able to attach the
     * events they create to the span, exiting unregisters it. For this to
     * work, exiting a span must be done on the same thread where it was
     * entered. It is possible to enter a span on multiple threads, in which
     * case it should also be exited on all of them individually; that is,
     * unless you *want* the span to be attached to all further events created
     * on that thread.
     */
    constructor(file, line, level, target, name, bridgeTraceId) {
        super();
        const pointer = uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_span_new(FfiConverterString.lower(file), FfiConverterOptionalUInt32.lower(line), FfiConverterTypeLogLevel.lower(level), FfiConverterString.lower(target), FfiConverterString.lower(name), FfiConverterOptionalString.lower(bridgeTraceId), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift);
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeSpanObjectFactory.bless(pointer);
    }
    static current() {
        return FfiConverterTypeSpan.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_span_current(callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Creates a [`Span`] that acts as a bridge between the client spans and
     * the SDK ones, allowing them to be joined in Sentry. This function
     * will only return a valid span if the `sentry` feature is enabled,
     * otherwise it will return a noop span.
     */
    static newBridgeSpan(target, parentTraceId) {
        return FfiConverterTypeSpan.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_span_new_bridge_span(FfiConverterString.lower(target), FfiConverterOptionalString.lower(parentTraceId), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    enter() {
        uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_span_enter(uniffiTypeSpanObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift);
    }
    exit() {
        uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_span_exit(uniffiTypeSpanObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift);
    }
    isNone() {
        return FfiConverterBool.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_span_is_none(uniffiTypeSpanObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeSpanObjectFactory.pointer(this);
            uniffiTypeSpanObjectFactory.freePointer(pointer);
            uniffiTypeSpanObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeSpanObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeSpanObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeSpanObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(Span.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "Span";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_span(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_span(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "Span";
        },
    };
})();
// FfiConverter for SpanInterface
const FfiConverterTypeSpan = new FfiConverterObject(uniffiTypeSpanObjectFactory);
/**
 * An object encapsulating the SSO login flow
 */
export class SsoHandler extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "SsoHandler";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeSsoHandlerObjectFactory.bless(pointer);
    }
    /**
     * Completes the SSO login process.
     */
    async finish(callbackUrl, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_ssohandler_finish(uniffiTypeSsoHandlerObjectFactory.clonePointer(this), FfiConverterString.lower(callbackUrl));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeSsoError.lift.bind(FfiConverterTypeSsoError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Returns the URL for starting SSO authentication. The URL should be
     * opened in a web view. Once the web view succeeds, call `finish` with
     * the callback URL.
     */
    url() {
        return FfiConverterString.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_ssohandler_url(uniffiTypeSsoHandlerObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeSsoHandlerObjectFactory.pointer(this);
            uniffiTypeSsoHandlerObjectFactory.freePointer(pointer);
            uniffiTypeSsoHandlerObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeSsoHandlerObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeSsoHandlerObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeSsoHandlerObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(SsoHandler.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "SsoHandler";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_ssohandler(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_ssohandler(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "SsoHandler";
        },
    };
})();
// FfiConverter for SsoHandlerInterface
const FfiConverterTypeSsoHandler = new FfiConverterObject(uniffiTypeSsoHandlerObjectFactory);
export class SyncService extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "SyncService";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeSyncServiceObjectFactory.bless(pointer);
    }
    /**
     * Force expiring both sliding sync sessions.
     *
     * This ensures that the sync service is stopped before expiring both
     * sessions. It should be used sparingly, as it will cause a restart of
     * the sessions on the server as well.
     */
    async expireSessions(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_syncservice_expire_sessions(uniffiTypeSyncServiceObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    roomListService() {
        return FfiConverterTypeRoomListService.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_syncservice_room_list_service(uniffiTypeSyncServiceObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    async start(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_syncservice_start(uniffiTypeSyncServiceObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    state(listener) {
        return FfiConverterTypeTaskHandle.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_syncservice_state(uniffiTypeSyncServiceObjectFactory.clonePointer(this), FfiConverterTypeSyncServiceStateObserver.lower(listener), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    async stop(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_syncservice_stop(uniffiTypeSyncServiceObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeSyncServiceObjectFactory.pointer(this);
            uniffiTypeSyncServiceObjectFactory.freePointer(pointer);
            uniffiTypeSyncServiceObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeSyncServiceObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeSyncServiceObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeSyncServiceObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(SyncService.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "SyncService";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_syncservice(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_syncservice(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "SyncService";
        },
    };
})();
// FfiConverter for SyncServiceInterface
const FfiConverterTypeSyncService = new FfiConverterObject(uniffiTypeSyncServiceObjectFactory);
export class SyncServiceBuilder extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "SyncServiceBuilder";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeSyncServiceBuilderObjectFactory.bless(pointer);
    }
    async finish(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_finish(uniffiTypeSyncServiceBuilderObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeSyncService.lift.bind(FfiConverterTypeSyncService), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    withCrossProcessLock() {
        return FfiConverterTypeSyncServiceBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_cross_process_lock(uniffiTypeSyncServiceBuilderObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Enable the "offline" mode for the [`SyncService`].
     */
    withOfflineMode() {
        return FfiConverterTypeSyncServiceBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_offline_mode(uniffiTypeSyncServiceBuilderObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    withSharePos(enable) {
        return FfiConverterTypeSyncServiceBuilder.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_share_pos(uniffiTypeSyncServiceBuilderObjectFactory.clonePointer(this), FfiConverterBool.lower(enable), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeSyncServiceBuilderObjectFactory.pointer(this);
            uniffiTypeSyncServiceBuilderObjectFactory.freePointer(pointer);
            uniffiTypeSyncServiceBuilderObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeSyncServiceBuilderObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeSyncServiceBuilderObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeSyncServiceBuilderObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(SyncServiceBuilder.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "SyncServiceBuilder";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_syncservicebuilder(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_syncservicebuilder(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "SyncServiceBuilder";
        },
    };
})();
// FfiConverter for SyncServiceBuilderInterface
const FfiConverterTypeSyncServiceBuilder = new FfiConverterObject(uniffiTypeSyncServiceBuilderObjectFactory);
/**
 * A task handle is a way to keep the handle a task running by itself in
 * detached mode.
 *
 * It's a thin wrapper around [`JoinHandle`].
 */
export class TaskHandle extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "TaskHandle";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeTaskHandleObjectFactory.bless(pointer);
    }
    cancel() {
        uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_taskhandle_cancel(uniffiTypeTaskHandleObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift);
    }
    /**
     * Check whether the handle is finished.
     */
    isFinished() {
        return FfiConverterBool.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_taskhandle_is_finished(uniffiTypeTaskHandleObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeTaskHandleObjectFactory.pointer(this);
            uniffiTypeTaskHandleObjectFactory.freePointer(pointer);
            uniffiTypeTaskHandleObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeTaskHandleObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeTaskHandleObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeTaskHandleObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(TaskHandle.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "TaskHandle";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_taskhandle(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_taskhandle(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "TaskHandle";
        },
    };
})();
// FfiConverter for TaskHandleInterface
const FfiConverterTypeTaskHandle = new FfiConverterObject(uniffiTypeTaskHandleObjectFactory);
export class ThreadSummary extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "ThreadSummary";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeThreadSummaryObjectFactory.bless(pointer);
    }
    latestEvent() {
        return FfiConverterTypeEmbeddedEventDetails.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_threadsummary_latest_event(uniffiTypeThreadSummaryObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    numReplies() {
        return FfiConverterUInt64.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_threadsummary_num_replies(uniffiTypeThreadSummaryObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeThreadSummaryObjectFactory.pointer(this);
            uniffiTypeThreadSummaryObjectFactory.freePointer(pointer);
            uniffiTypeThreadSummaryObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeThreadSummaryObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeThreadSummaryObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeThreadSummaryObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(ThreadSummary.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "ThreadSummary";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_threadsummary(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_threadsummary(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "ThreadSummary";
        },
    };
})();
// FfiConverter for ThreadSummaryInterface
const FfiConverterTypeThreadSummary = new FfiConverterObject(uniffiTypeThreadSummaryObjectFactory);
export class Timeline extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "Timeline";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeTimelineObjectFactory.bless(pointer);
    }
    async addListener(listener, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_add_listener(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterTypeTimelineListener.lower(listener));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeTaskHandle.lift.bind(FfiConverterTypeTaskHandle), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    createMessageContent(msgType) {
        return FfiConverterOptionalTypeRoomMessageEventContentWithoutRelation.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_create_message_content(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterTypeMessageType.lower(msgType), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    async createPoll(question, answers, maxSelections, pollKind, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_create_poll(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterString.lower(question), FfiConverterArrayString.lower(answers), FfiConverterUInt8.lower(maxSelections), FfiConverterTypePollKind.lower(pollKind));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Edits an event from the timeline.
     *
     * If it was a local event, this will *try* to edit it, if it was not
     * being sent already. If the event was a remote event, then it will be
     * redacted by sending an edit request to the server.
     *
     * Returns whether the edit did happen. It can only return false for
     * local events that are being processed.
     */
    async edit(eventOrTransactionId, newContent, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_edit(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterTypeEventOrTransactionId.lower(eventOrTransactionId), FfiConverterTypeEditedContent.lower(newContent));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async endPoll(pollStartEventId, text, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_end_poll(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterString.lower(pollStartEventId), FfiConverterString.lower(text));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async fetchDetailsForEvent(eventId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_fetch_details_for_event(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterString.lower(eventId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async fetchMembers(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_fetch_members(uniffiTypeTimelineObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Get the current timeline item for the given event ID, if any.
     *
     * Will return a remote event, *or* a local echo that has been sent but not
     * yet replaced by a remote echo.
     *
     * It's preferable to store the timeline items in the model for your UI, if
     * possible, instead of just storing IDs and coming back to the timeline
     * object to look up items.
     */
    async getEventTimelineItemByEventId(eventId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_get_event_timeline_item_by_event_id(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterString.lower(eventId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterTypeEventTimelineItem.lift.bind(FfiConverterTypeEventTimelineItem), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Returns the latest [`EventId`] in the timeline.
     */
    async latestEventId(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_latest_event_id(uniffiTypeTimelineObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterOptionalString.lift.bind(FfiConverterOptionalString), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Load the reply details for the given event id.
     *
     * This will return an `InReplyToDetails` object that contains the details
     * which will either be ready or an error.
     */
    async loadReplyDetails(eventIdStr, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_load_reply_details(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterString.lower(eventIdStr));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeInReplyToDetails.lift.bind(FfiConverterTypeInReplyToDetails), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Mark the room as read by trying to attach an *unthreaded* read receipt
     * to the latest room event.
     *
     * This works even if the latest event belongs to a thread, as a threaded
     * reply also belongs to the unthreaded timeline. No threaded receipt
     * will be sent here (see also #3123).
     */
    async markAsRead(receiptType, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_mark_as_read(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterTypeReceiptType.lower(receiptType));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Paginate backwards, whether we are in focused mode or in live mode.
     *
     * Returns whether we hit the start of the timeline or not.
     */
    async paginateBackwards(numEvents, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_paginate_backwards(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterUInt16.lower(numEvents));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Paginate forwards, whether we are in focused mode or in live mode.
     *
     * Returns whether we hit the end of the timeline or not.
     */
    async paginateForwards(numEvents, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_paginate_forwards(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterUInt16.lower(numEvents));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Adds a new pinned event by sending an updated `m.room.pinned_events`
     * event containing the new event id.
     *
     * Returns `true` if we sent the request, `false` if the event was already
     * pinned.
     */
    async pinEvent(eventId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_pin_event(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterString.lower(eventId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Redacts an event from the timeline.
     *
     * Only works for events that exist as timeline items.
     *
     * If it was a local event, this will *try* to cancel it, if it was not
     * being sent already. If the event was a remote event, then it will be
     * redacted by sending a redaction request to the server.
     *
     * Will return an error if the event couldn't be redacted.
     */
    async redactEvent(eventOrTransactionId, reason, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_redact_event(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterTypeEventOrTransactionId.lower(eventOrTransactionId), FfiConverterOptionalString.lower(reason));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    retryDecryption(sessionIds) {
        uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_retry_decryption(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterArrayString.lower(sessionIds), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift);
    }
    /**
     * Queues an event in the room's send queue so it's processed for
     * sending later.
     *
     * Returns an abort handle that allows to abort sending, if it hasn't
     * happened yet.
     */
    async send(msg, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterTypeRoomMessageEventContentWithoutRelation.lower(msg));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeSendHandle.lift.bind(FfiConverterTypeSendHandle), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    sendAudio(params, audioInfo) {
        return FfiConverterTypeSendAttachmentJoinHandle.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeRoomError.lift.bind(FfiConverterTypeRoomError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_audio(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterTypeUploadParameters.lower(params), FfiConverterTypeAudioInfo.lower(audioInfo), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    sendFile(params, fileInfo) {
        return FfiConverterTypeSendAttachmentJoinHandle.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeRoomError.lift.bind(FfiConverterTypeRoomError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_file(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterTypeUploadParameters.lower(params), FfiConverterTypeFileInfo.lower(fileInfo), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    sendImage(params, thumbnailSource, imageInfo) {
        return FfiConverterTypeSendAttachmentJoinHandle.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeRoomError.lift.bind(FfiConverterTypeRoomError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_image(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterTypeUploadParameters.lower(params), FfiConverterOptionalTypeUploadSource.lower(thumbnailSource), FfiConverterTypeImageInfo.lower(imageInfo), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    async sendLocation(body, geoUri, description, zoomLevel, assetType, repliedToEventId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_location(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterString.lower(body), FfiConverterString.lower(geoUri), FfiConverterOptionalString.lower(description), FfiConverterOptionalUInt8.lower(zoomLevel), FfiConverterOptionalTypeAssetType.lower(assetType), FfiConverterOptionalString.lower(repliedToEventId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async sendPollResponse(pollStartEventId, answers, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_poll_response(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterString.lower(pollStartEventId), FfiConverterArrayString.lower(answers));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    async sendReadReceipt(receiptType, eventId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_read_receipt(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterTypeReceiptType.lower(receiptType), FfiConverterString.lower(eventId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Send a reply.
     *
     * If the replied to event has a thread relation, it is forwarded on the
     * reply so that clients that support threads can render the reply
     * inside the thread.
     */
    async sendReply(msg, eventId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_reply(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterTypeRoomMessageEventContentWithoutRelation.lower(msg), FfiConverterString.lower(eventId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    sendVideo(params, thumbnailSource, videoInfo) {
        return FfiConverterTypeSendAttachmentJoinHandle.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeRoomError.lift.bind(FfiConverterTypeRoomError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_video(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterTypeUploadParameters.lower(params), FfiConverterOptionalTypeUploadSource.lower(thumbnailSource), FfiConverterTypeVideoInfo.lower(videoInfo), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    sendVoiceMessage(params, audioInfo, waveform) {
        return FfiConverterTypeSendAttachmentJoinHandle.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeRoomError.lift.bind(FfiConverterTypeRoomError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_send_voice_message(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterTypeUploadParameters.lower(params), FfiConverterTypeAudioInfo.lower(audioInfo), FfiConverterArrayFloat32.lower(waveform), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    async subscribeToBackPaginationStatus(listener, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_subscribe_to_back_pagination_status(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterTypePaginationStatusListener.lower(listener));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_pointer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_pointer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_pointer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_pointer, 
            /*liftFunc:*/ FfiConverterTypeTaskHandle.lift.bind(FfiConverterTypeTaskHandle), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Toggle a reaction on an event.
     *
     * Adds or redacts a reaction based on the state of the reaction at the
     * time it is called.
     *
     * This method works both on local echoes and remote items.
     *
     * When redacting a previous reaction, the redaction reason is not set.
     *
     * Ensures that only one reaction is sent at a time to avoid race
     * conditions and spamming the homeserver with requests.
     *
     * Returns `true` if the reaction was added, `false` if it was removed.
     */
    async toggleReaction(itemId, key, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_toggle_reaction(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterTypeEventOrTransactionId.lower(itemId), FfiConverterString.lower(key));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * Adds a new pinned event by sending an updated `m.room.pinned_events`
     * event without the event id we want to remove.
     *
     * Returns `true` if we sent the request, `false` if the event wasn't
     * pinned
     */
    async unpinEvent(eventId, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timeline_unpin_event(uniffiTypeTimelineObjectFactory.clonePointer(this), FfiConverterString.lower(eventId));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeTimelineObjectFactory.pointer(this);
            uniffiTypeTimelineObjectFactory.freePointer(pointer);
            uniffiTypeTimelineObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeTimelineObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeTimelineObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeTimelineObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(Timeline.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "Timeline";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_timeline(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_timeline(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "Timeline";
        },
    };
})();
// FfiConverter for TimelineInterface
const FfiConverterTypeTimeline = new FfiConverterObject(uniffiTypeTimelineObjectFactory);
export class TimelineEvent extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "TimelineEvent";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeTimelineEventObjectFactory.bless(pointer);
    }
    eventId() {
        return FfiConverterString.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelineevent_event_id(uniffiTypeTimelineEventObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    eventType() {
        return FfiConverterTypeTimelineEventType.lift(uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError), 
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelineevent_event_type(uniffiTypeTimelineEventObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    senderId() {
        return FfiConverterString.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelineevent_sender_id(uniffiTypeTimelineEventObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Returns the thread root event id for the event, if it's part of a
     * thread.
     */
    threadRootEventId() {
        return FfiConverterOptionalString.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelineevent_thread_root_event_id(uniffiTypeTimelineEventObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    timestamp() {
        return FfiConverterTypeTimestamp.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelineevent_timestamp(uniffiTypeTimelineEventObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeTimelineEventObjectFactory.pointer(this);
            uniffiTypeTimelineEventObjectFactory.freePointer(pointer);
            uniffiTypeTimelineEventObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeTimelineEventObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeTimelineEventObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeTimelineEventObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(TimelineEvent.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "TimelineEvent";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_timelineevent(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_timelineevent(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "TimelineEvent";
        },
    };
})();
// FfiConverter for TimelineEventInterface
const FfiConverterTypeTimelineEvent = new FfiConverterObject(uniffiTypeTimelineEventObjectFactory);
export class TimelineEventTypeFilter extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "TimelineEventTypeFilter";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeTimelineEventTypeFilterObjectFactory.bless(pointer);
    }
    static exclude(eventTypes) {
        return FfiConverterTypeTimelineEventTypeFilter.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_timelineeventtypefilter_exclude(FfiConverterArrayTypeFilterTimelineEventType.lower(eventTypes), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    static include(eventTypes) {
        return FfiConverterTypeTimelineEventTypeFilter.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_constructor_timelineeventtypefilter_include(FfiConverterArrayTypeFilterTimelineEventType.lower(eventTypes), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeTimelineEventTypeFilterObjectFactory.pointer(this);
            uniffiTypeTimelineEventTypeFilterObjectFactory.freePointer(pointer);
            uniffiTypeTimelineEventTypeFilterObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeTimelineEventTypeFilterObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeTimelineEventTypeFilterObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeTimelineEventTypeFilterObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(TimelineEventTypeFilter.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "TimelineEventTypeFilter";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_timelineeventtypefilter(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_timelineeventtypefilter(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "TimelineEventTypeFilter";
        },
    };
})();
// FfiConverter for TimelineEventTypeFilterInterface
const FfiConverterTypeTimelineEventTypeFilter = new FfiConverterObject(uniffiTypeTimelineEventTypeFilterObjectFactory);
export class TimelineItem extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "TimelineItem";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeTimelineItemObjectFactory.bless(pointer);
    }
    asEvent() {
        return FfiConverterOptionalTypeEventTimelineItem.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_event(uniffiTypeTimelineItemObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    asVirtual() {
        return FfiConverterOptionalTypeVirtualTimelineItem.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_virtual(uniffiTypeTimelineItemObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    fmtDebug() {
        return FfiConverterString.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelineitem_fmt_debug(uniffiTypeTimelineItemObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * An opaque unique identifier for this timeline item.
     */
    uniqueId() {
        return FfiConverterTypeTimelineUniqueId.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_timelineitem_unique_id(uniffiTypeTimelineItemObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeTimelineItemObjectFactory.pointer(this);
            uniffiTypeTimelineItemObjectFactory.freePointer(pointer);
            uniffiTypeTimelineItemObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeTimelineItemObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeTimelineItemObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeTimelineItemObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(TimelineItem.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "TimelineItem";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_timelineitem(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_timelineitem(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "TimelineItem";
        },
    };
})();
// FfiConverter for TimelineItemInterface
const FfiConverterTypeTimelineItem = new FfiConverterObject(uniffiTypeTimelineItemObjectFactory);
export class UnreadNotificationsCount extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "UnreadNotificationsCount";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeUnreadNotificationsCountObjectFactory.bless(pointer);
    }
    hasNotifications() {
        return FfiConverterBool.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_has_notifications(uniffiTypeUnreadNotificationsCountObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    highlightCount() {
        return FfiConverterUInt32.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_highlight_count(uniffiTypeUnreadNotificationsCountObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    notificationCount() {
        return FfiConverterUInt32.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_notification_count(uniffiTypeUnreadNotificationsCountObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeUnreadNotificationsCountObjectFactory.pointer(this);
            uniffiTypeUnreadNotificationsCountObjectFactory.freePointer(pointer);
            uniffiTypeUnreadNotificationsCountObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeUnreadNotificationsCountObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeUnreadNotificationsCountObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeUnreadNotificationsCountObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(UnreadNotificationsCount.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "UnreadNotificationsCount";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_unreadnotificationscount(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_unreadnotificationscount(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "UnreadNotificationsCount";
        },
    };
})();
// FfiConverter for UnreadNotificationsCountInterface
const FfiConverterTypeUnreadNotificationsCount = new FfiConverterObject(uniffiTypeUnreadNotificationsCountObjectFactory);
/**
 * The E2EE identity of a user.
 */
export class UserIdentity extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "UserIdentity";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeUserIdentityObjectFactory.bless(pointer);
    }
    /**
     * Was this identity previously verified, and is no longer?
     */
    hasVerificationViolation() {
        return FfiConverterBool.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_useridentity_has_verification_violation(uniffiTypeUserIdentityObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Is the user identity considered to be verified.
     *
     * If the identity belongs to another user, our own user identity needs to
     * be verified as well for the identity to be considered to be verified.
     */
    isVerified() {
        return FfiConverterBool.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_useridentity_is_verified(uniffiTypeUserIdentityObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Get the public part of the Master key of this user identity.
     *
     * The public part of the Master key is usually used to uniquely identify
     * the identity.
     *
     * Returns None if the master key does not actually contain any keys.
     */
    masterKey() {
        return FfiConverterOptionalString.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_useridentity_master_key(uniffiTypeUserIdentityObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Remember this identity, ensuring it does not result in a pin violation.
     *
     * When we first see a user, we assume their cryptographic identity has not
     * been tampered with by the homeserver or another entity with
     * man-in-the-middle capabilities. We remember this identity and call this
     * action "pinning".
     *
     * If the identity presented for the user changes later on, the newly
     * presented identity is considered to be in "pin violation". This
     * method explicitly accepts the new identity, allowing it to replace
     * the previously pinned one and bringing it out of pin violation.
     *
     * UIs should display a warning to the user when encountering an identity
     * which is not verified and is in pin violation.
     */
    async pin(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_useridentity_pin(uniffiTypeUserIdentityObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * True if we verified this identity at some point in the past.
     *
     * To reset this latch back to `false`, one must call
     * [`UserIdentity::withdraw_verification()`].
     */
    wasPreviouslyVerified() {
        return FfiConverterBool.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_useridentity_was_previously_verified(uniffiTypeUserIdentityObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * Remove the requirement for this identity to be verified.
     *
     * If an identity was previously verified and is not anymore it will be
     * reported to the user. In order to remove this notice users have to
     * verify again or to withdraw the verification requirement.
     */
    async withdrawVerification(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_useridentity_withdraw_verification(uniffiTypeUserIdentityObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_, 
            /*errorHandler:*/ FfiConverterTypeClientError.lift.bind(FfiConverterTypeClientError));
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeUserIdentityObjectFactory.pointer(this);
            uniffiTypeUserIdentityObjectFactory.freePointer(pointer);
            uniffiTypeUserIdentityObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeUserIdentityObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeUserIdentityObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeUserIdentityObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(UserIdentity.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "UserIdentity";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_useridentity(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_useridentity(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "UserIdentity";
        },
    };
})();
// FfiConverter for UserIdentityInterface
const FfiConverterTypeUserIdentity = new FfiConverterObject(uniffiTypeUserIdentityObjectFactory);
/**
 * An object that handles all interactions of a widget living inside a webview
 * or IFrame with the Matrix world.
 */
export class WidgetDriver extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "WidgetDriver";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeWidgetDriverObjectFactory.bless(pointer);
    }
    async run(room, capabilitiesProvider, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_widgetdriver_run(uniffiTypeWidgetDriverObjectFactory.clonePointer(this), FfiConverterTypeRoom.lower(room), FfiConverterTypeWidgetCapabilitiesProvider.lower(capabilitiesProvider));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_void, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_void, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_void, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_void, 
            /*liftFunc:*/ (_v) => { }, 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeWidgetDriverObjectFactory.pointer(this);
            uniffiTypeWidgetDriverObjectFactory.freePointer(pointer);
            uniffiTypeWidgetDriverObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeWidgetDriverObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeWidgetDriverObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeWidgetDriverObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(WidgetDriver.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "WidgetDriver";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_widgetdriver(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_widgetdriver(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "WidgetDriver";
        },
    };
})();
// FfiConverter for WidgetDriverInterface
const FfiConverterTypeWidgetDriver = new FfiConverterObject(uniffiTypeWidgetDriverObjectFactory);
/**
 * A handle that encapsulates the communication between a widget driver and the
 * corresponding widget (inside a webview or IFrame).
 */
export class WidgetDriverHandle extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "WidgetDriverHandle";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeWidgetDriverHandleObjectFactory.bless(pointer);
    }
    /**
     * Receive a message from the widget driver.
     *
     * The message must be passed on to the widget.
     *
     * Returns `None` if the widget driver is no longer running.
     */
    async recv(asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_widgetdriverhandle_recv(uniffiTypeWidgetDriverHandleObjectFactory.clonePointer(this));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_rust_buffer, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_rust_buffer, 
            /*liftFunc:*/ FfiConverterOptionalString.lift.bind(FfiConverterOptionalString), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     *
     * Returns `false` if the widget driver is no longer running.
     */
    async send(msg, asyncOpts_) {
        const __stack = uniffiIsDebug ? new Error().stack : undefined;
        try {
            return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller, 
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_method_widgetdriverhandle_send(uniffiTypeWidgetDriverHandleObjectFactory.clonePointer(this), FfiConverterString.lower(msg));
            }, 
            /*pollFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_poll_i8, 
            /*cancelFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_cancel_i8, 
            /*completeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_complete_i8, 
            /*freeFunc:*/ nativeModule().ubrn_ffi_matrix_sdk_ffi_rust_future_free_i8, 
            /*liftFunc:*/ FfiConverterBool.lift.bind(FfiConverterBool), 
            /*liftString:*/ FfiConverterString.lift, 
            /*asyncOpts:*/ asyncOpts_);
        }
        catch (__error) {
            if (uniffiIsDebug && __error instanceof Error) {
                __error.stack = __stack;
            }
            throw __error;
        }
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeWidgetDriverHandleObjectFactory.pointer(this);
            uniffiTypeWidgetDriverHandleObjectFactory.freePointer(pointer);
            uniffiTypeWidgetDriverHandleObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeWidgetDriverHandleObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeWidgetDriverHandleObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeWidgetDriverHandleObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(WidgetDriverHandle.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "WidgetDriverHandle";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_clone_widgetdriverhandle(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_ffi_fn_free_widgetdriverhandle(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "WidgetDriverHandle";
        },
    };
})();
// FfiConverter for WidgetDriverHandleInterface
const FfiConverterTypeWidgetDriverHandle = new FfiConverterObject(uniffiTypeWidgetDriverHandleObjectFactory);
// FfiConverter for boolean | undefined
const FfiConverterOptionalBool = new FfiConverterOptional(FfiConverterBool);
// FfiConverter for BackupSteadyStateListener | undefined
const FfiConverterOptionalTypeBackupSteadyStateListener = new FfiConverterOptional(FfiConverterTypeBackupSteadyStateListener);
// FfiConverter for ClientDelegate | undefined
const FfiConverterOptionalTypeClientDelegate = new FfiConverterOptional(FfiConverterTypeClientDelegate);
// FfiConverter for NotificationSettingsDelegate | undefined
const FfiConverterOptionalTypeNotificationSettingsDelegate = new FfiConverterOptional(FfiConverterTypeNotificationSettingsDelegate);
// FfiConverter for ProgressWatcher | undefined
const FfiConverterOptionalTypeProgressWatcher = new FfiConverterOptional(FfiConverterTypeProgressWatcher);
// FfiConverter for SessionVerificationControllerDelegate | undefined
const FfiConverterOptionalTypeSessionVerificationControllerDelegate = new FfiConverterOptional(FfiConverterTypeSessionVerificationControllerDelegate);
// FfiConverter for UniffiDuration | undefined
const FfiConverterOptionalDuration = new FfiConverterOptional(FfiConverterDuration);
// FfiConverter for EventItemOrigin | undefined
const FfiConverterOptionalTypeEventItemOrigin = new FfiConverterOptional(FfiConverterTypeEventItemOrigin);
// FfiConverter for /*f64*/number | undefined
const FfiConverterOptionalFloat64 = new FfiConverterOptional(FfiConverterFloat64);
// FfiConverter for /*i32*/number | undefined
const FfiConverterOptionalInt32 = new FfiConverterOptional(FfiConverterInt32);
// FfiConverter for AudioInfo | undefined
const FfiConverterOptionalTypeAudioInfo = new FfiConverterOptional(FfiConverterTypeAudioInfo);
// FfiConverter for ComposerDraft | undefined
const FfiConverterOptionalTypeComposerDraft = new FfiConverterOptional(FfiConverterTypeComposerDraft);
// FfiConverter for EventTimelineItem | undefined
const FfiConverterOptionalTypeEventTimelineItem = new FfiConverterOptional(FfiConverterTypeEventTimelineItem);
// FfiConverter for FileInfo | undefined
const FfiConverterOptionalTypeFileInfo = new FfiConverterOptional(FfiConverterTypeFileInfo);
// FfiConverter for FormattedBody | undefined
const FfiConverterOptionalTypeFormattedBody = new FfiConverterOptional(FfiConverterTypeFormattedBody);
// FfiConverter for ImageInfo | undefined
const FfiConverterOptionalTypeImageInfo = new FfiConverterOptional(FfiConverterTypeImageInfo);
// FfiConverter for MatrixEntity | undefined
const FfiConverterOptionalTypeMatrixEntity = new FfiConverterOptional(FfiConverterTypeMatrixEntity);
// FfiConverter for MediaPreviewConfig | undefined
const FfiConverterOptionalTypeMediaPreviewConfig = new FfiConverterOptional(FfiConverterTypeMediaPreviewConfig);
// FfiConverter for MediaUploadProgress | undefined
const FfiConverterOptionalTypeMediaUploadProgress = new FfiConverterOptional(FfiConverterTypeMediaUploadProgress);
// FfiConverter for Mentions | undefined
const FfiConverterOptionalTypeMentions = new FfiConverterOptional(FfiConverterTypeMentions);
// FfiConverter for NotificationPowerLevels | undefined
const FfiConverterOptionalTypeNotificationPowerLevels = new FfiConverterOptional(FfiConverterTypeNotificationPowerLevels);
// FfiConverter for PassPhrase | undefined
const FfiConverterOptionalTypePassPhrase = new FfiConverterOptional(FfiConverterTypePassPhrase);
// FfiConverter for PowerLevels | undefined
const FfiConverterOptionalTypePowerLevels = new FfiConverterOptional(FfiConverterTypePowerLevels);
// FfiConverter for PredecessorRoom | undefined
const FfiConverterOptionalTypePredecessorRoom = new FfiConverterOptional(FfiConverterTypePredecessorRoom);
// FfiConverter for ResolvedRoomAlias | undefined
const FfiConverterOptionalTypeResolvedRoomAlias = new FfiConverterOptional(FfiConverterTypeResolvedRoomAlias);
// FfiConverter for RoomMember | undefined
const FfiConverterOptionalTypeRoomMember = new FfiConverterOptional(FfiConverterTypeRoomMember);
// FfiConverter for RoomMemberWithSenderInfo | undefined
const FfiConverterOptionalTypeRoomMemberWithSenderInfo = new FfiConverterOptional(FfiConverterTypeRoomMemberWithSenderInfo);
// FfiConverter for SpaceRoom | undefined
const FfiConverterOptionalTypeSpaceRoom = new FfiConverterOptional(FfiConverterTypeSpaceRoom);
// FfiConverter for SuccessorRoom | undefined
const FfiConverterOptionalTypeSuccessorRoom = new FfiConverterOptional(FfiConverterTypeSuccessorRoom);
// FfiConverter for ThreadSubscription | undefined
const FfiConverterOptionalTypeThreadSubscription = new FfiConverterOptional(FfiConverterTypeThreadSubscription);
// FfiConverter for ThumbnailInfo | undefined
const FfiConverterOptionalTypeThumbnailInfo = new FfiConverterOptional(FfiConverterTypeThumbnailInfo);
// FfiConverter for TracingFileConfiguration | undefined
const FfiConverterOptionalTypeTracingFileConfiguration = new FfiConverterOptional(FfiConverterTypeTracingFileConfiguration);
// FfiConverter for UnstableAudioDetailsContent | undefined
const FfiConverterOptionalTypeUnstableAudioDetailsContent = new FfiConverterOptional(FfiConverterTypeUnstableAudioDetailsContent);
// FfiConverter for UnstableVoiceContent | undefined
const FfiConverterOptionalTypeUnstableVoiceContent = new FfiConverterOptional(FfiConverterTypeUnstableVoiceContent);
// FfiConverter for VideoInfo | undefined
const FfiConverterOptionalTypeVideoInfo = new FfiConverterOptional(FfiConverterTypeVideoInfo);
// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);
// FfiConverter for /*u16*/number | undefined
const FfiConverterOptionalUInt16 = new FfiConverterOptional(FfiConverterUInt16);
// FfiConverter for /*u32*/number | undefined
const FfiConverterOptionalUInt32 = new FfiConverterOptional(FfiConverterUInt32);
// FfiConverter for /*u64*/bigint | undefined
const FfiConverterOptionalUInt64 = new FfiConverterOptional(FfiConverterUInt64);
// FfiConverter for /*u8*/number | undefined
const FfiConverterOptionalUInt8 = new FfiConverterOptional(FfiConverterUInt8);
// FfiConverter for Array<ArrayBuffer>
const FfiConverterArrayArrayBuffer = new FfiConverterArray(FfiConverterArrayBuffer);
// FfiConverter for Array</*f32*/number>
const FfiConverterArrayFloat32 = new FfiConverterArray(FfiConverterFloat32);
// FfiConverter for Array<ConditionalPushRule>
const FfiConverterArrayTypeConditionalPushRule = new FfiConverterArray(FfiConverterTypeConditionalPushRule);
// FfiConverter for Array<IdentityStatusChange>
const FfiConverterArrayTypeIdentityStatusChange = new FfiConverterArray(FfiConverterTypeIdentityStatusChange);
// FfiConverter for Array<KnockRequest>
const FfiConverterArrayTypeKnockRequest = new FfiConverterArray(FfiConverterTypeKnockRequest);
// FfiConverter for Array<LeaveSpaceRoom>
const FfiConverterArrayTypeLeaveSpaceRoom = new FfiConverterArray(FfiConverterTypeLeaveSpaceRoom);
// FfiConverter for Array<LiveLocationShare>
const FfiConverterArrayTypeLiveLocationShare = new FfiConverterArray(FfiConverterTypeLiveLocationShare);
// FfiConverter for Array<NotificationItemsRequest>
const FfiConverterArrayTypeNotificationItemsRequest = new FfiConverterArray(FfiConverterTypeNotificationItemsRequest);
// FfiConverter for Array<PatternedPushRule>
const FfiConverterArrayTypePatternedPushRule = new FfiConverterArray(FfiConverterTypePatternedPushRule);
// FfiConverter for Array<PollAnswer>
const FfiConverterArrayTypePollAnswer = new FfiConverterArray(FfiConverterTypePollAnswer);
// FfiConverter for Array<Reaction>
const FfiConverterArrayTypeReaction = new FfiConverterArray(FfiConverterTypeReaction);
// FfiConverter for Array<ReactionSenderData>
const FfiConverterArrayTypeReactionSenderData = new FfiConverterArray(FfiConverterTypeReactionSenderData);
// FfiConverter for Array<RoomDescription>
const FfiConverterArrayTypeRoomDescription = new FfiConverterArray(FfiConverterTypeRoomDescription);
// FfiConverter for Array<RoomHero>
const FfiConverterArrayTypeRoomHero = new FfiConverterArray(FfiConverterTypeRoomHero);
// FfiConverter for Array<RoomMember>
const FfiConverterArrayTypeRoomMember = new FfiConverterArray(FfiConverterTypeRoomMember);
// FfiConverter for Array<SimplePushRule>
const FfiConverterArrayTypeSimplePushRule = new FfiConverterArray(FfiConverterTypeSimplePushRule);
// FfiConverter for Array<SpaceRoom>
const FfiConverterArrayTypeSpaceRoom = new FfiConverterArray(FfiConverterTypeSpaceRoom);
// FfiConverter for Array<UserPowerLevelUpdate>
const FfiConverterArrayTypeUserPowerLevelUpdate = new FfiConverterArray(FfiConverterTypeUserPowerLevelUpdate);
// FfiConverter for Array<UserProfile>
const FfiConverterArrayTypeUserProfile = new FfiConverterArray(FfiConverterTypeUserProfile);
// FfiConverter for Array<string>
const FfiConverterArrayString = new FfiConverterArray(FfiConverterString);
// FfiConverter for Array</*u16*/number>
const FfiConverterArrayUInt16 = new FfiConverterArray(FfiConverterUInt16);
// FfiConverter for Map<TagName, TagInfo>
const FfiConverterMapTypeTagNameTypeTagInfo = new FfiConverterMap(FfiConverterTypeTagName, FfiConverterTypeTagInfo);
// FfiConverter for Map<string, BatchNotificationResult>
const FfiConverterMapStringTypeBatchNotificationResult = new FfiConverterMap(FfiConverterString, FfiConverterTypeBatchNotificationResult);
// FfiConverter for Map<string, Array<string>>
const FfiConverterMapStringArrayString = new FfiConverterMap(FfiConverterString, FfiConverterArrayString);
// FfiConverter for Timestamp | undefined
const FfiConverterOptionalTypeTimestamp = new FfiConverterOptional(FfiConverterTypeTimestamp);
// FfiConverter for AccountManagementAction | undefined
const FfiConverterOptionalTypeAccountManagementAction = new FfiConverterOptional(FfiConverterTypeAccountManagementAction);
// FfiConverter for AssetType | undefined
const FfiConverterOptionalTypeAssetType = new FfiConverterOptional(FfiConverterTypeAssetType);
// FfiConverter for AuthData | undefined
const FfiConverterOptionalTypeAuthData = new FfiConverterOptional(FfiConverterTypeAuthData);
// FfiConverter for EventSendState | undefined
const FfiConverterOptionalTypeEventSendState = new FfiConverterOptional(FfiConverterTypeEventSendState);
// FfiConverter for HistoryVisibility | undefined
const FfiConverterOptionalTypeHistoryVisibility = new FfiConverterOptional(FfiConverterTypeHistoryVisibility);
// FfiConverter for InviteAvatars | undefined
const FfiConverterOptionalTypeInviteAvatars = new FfiConverterOptional(FfiConverterTypeInviteAvatars);
// FfiConverter for JoinRule | undefined
const FfiConverterOptionalTypeJoinRule = new FfiConverterOptional(FfiConverterTypeJoinRule);
// FfiConverter for MediaPreviews | undefined
const FfiConverterOptionalTypeMediaPreviews = new FfiConverterOptional(FfiConverterTypeMediaPreviews);
// FfiConverter for Membership | undefined
const FfiConverterOptionalTypeMembership = new FfiConverterOptional(FfiConverterTypeMembership);
// FfiConverter for MembershipChange | undefined
const FfiConverterOptionalTypeMembershipChange = new FfiConverterOptional(FfiConverterTypeMembershipChange);
// FfiConverter for OidcPrompt | undefined
const FfiConverterOptionalTypeOidcPrompt = new FfiConverterOptional(FfiConverterTypeOidcPrompt);
// FfiConverter for PublicRoomJoinRule | undefined
const FfiConverterOptionalTypePublicRoomJoinRule = new FfiConverterOptional(FfiConverterTypePublicRoomJoinRule);
// FfiConverter for PushFormat | undefined
const FfiConverterOptionalTypePushFormat = new FfiConverterOptional(FfiConverterTypePushFormat);
// FfiConverter for RoomHistoryVisibility | undefined
const FfiConverterOptionalTypeRoomHistoryVisibility = new FfiConverterOptional(FfiConverterTypeRoomHistoryVisibility);
// FfiConverter for RoomNotificationMode | undefined
const FfiConverterOptionalTypeRoomNotificationMode = new FfiConverterOptional(FfiConverterTypeRoomNotificationMode);
// FfiConverter for ShieldState | undefined
const FfiConverterOptionalTypeShieldState = new FfiConverterOptional(FfiConverterTypeShieldState);
// FfiConverter for UploadSource | undefined
const FfiConverterOptionalTypeUploadSource = new FfiConverterOptional(FfiConverterTypeUploadSource);
// FfiConverter for VirtualTimelineItem | undefined
const FfiConverterOptionalTypeVirtualTimelineItem = new FfiConverterOptional(FfiConverterTypeVirtualTimelineItem);
// FfiConverter for Map<string, /*i64*/bigint> | undefined
const FfiConverterOptionalMapStringInt64 = new FfiConverterOptional(FfiConverterMapStringInt64);
// FfiConverter for IdentityResetHandleInterface | undefined
const FfiConverterOptionalTypeIdentityResetHandle = new FfiConverterOptional(FfiConverterTypeIdentityResetHandle);
// FfiConverter for InReplyToDetailsInterface | undefined
const FfiConverterOptionalTypeInReplyToDetails = new FfiConverterOptional(FfiConverterTypeInReplyToDetails);
// FfiConverter for MediaSourceInterface | undefined
const FfiConverterOptionalTypeMediaSource = new FfiConverterOptional(FfiConverterTypeMediaSource);
// FfiConverter for RoomInterface | undefined
const FfiConverterOptionalTypeRoom = new FfiConverterOptional(FfiConverterTypeRoom);
// FfiConverter for RoomMessageEventContentWithoutRelationInterface | undefined
const FfiConverterOptionalTypeRoomMessageEventContentWithoutRelation = new FfiConverterOptional(FfiConverterTypeRoomMessageEventContentWithoutRelation);
// FfiConverter for RoomPowerLevelsInterface | undefined
const FfiConverterOptionalTypeRoomPowerLevels = new FfiConverterOptional(FfiConverterTypeRoomPowerLevels);
// FfiConverter for SendHandleInterface | undefined
const FfiConverterOptionalTypeSendHandle = new FfiConverterOptional(FfiConverterTypeSendHandle);
// FfiConverter for SyncServiceInterface | undefined
const FfiConverterOptionalTypeSyncService = new FfiConverterOptional(FfiConverterTypeSyncService);
// FfiConverter for TaskHandleInterface | undefined
const FfiConverterOptionalTypeTaskHandle = new FfiConverterOptional(FfiConverterTypeTaskHandle);
// FfiConverter for ThreadSummaryInterface | undefined
const FfiConverterOptionalTypeThreadSummary = new FfiConverterOptional(FfiConverterTypeThreadSummary);
// FfiConverter for UserIdentityInterface | undefined
const FfiConverterOptionalTypeUserIdentity = new FfiConverterOptional(FfiConverterTypeUserIdentity);
// FfiConverter for Array<RoomHero> | undefined
const FfiConverterOptionalArrayTypeRoomHero = new FfiConverterOptional(FfiConverterArrayTypeRoomHero);
// FfiConverter for Array<RoomMember> | undefined
const FfiConverterOptionalArrayTypeRoomMember = new FfiConverterOptional(FfiConverterArrayTypeRoomMember);
// FfiConverter for Array<string> | undefined
const FfiConverterOptionalArrayString = new FfiConverterOptional(FfiConverterArrayString);
// FfiConverter for Array<Action>
const FfiConverterArrayTypeAction = new FfiConverterArray(FfiConverterTypeAction);
// FfiConverter for Array<AllowRule>
const FfiConverterArrayTypeAllowRule = new FfiConverterArray(FfiConverterTypeAllowRule);
// FfiConverter for Array<DraftAttachment>
const FfiConverterArrayTypeDraftAttachment = new FfiConverterArray(FfiConverterTypeDraftAttachment);
// FfiConverter for Array<FilterTimelineEventType>
const FfiConverterArrayTypeFilterTimelineEventType = new FfiConverterArray(FfiConverterTypeFilterTimelineEventType);
// FfiConverter for Array<Membership>
const FfiConverterArrayTypeMembership = new FfiConverterArray(FfiConverterTypeMembership);
// FfiConverter for Array<OidcPrompt>
const FfiConverterArrayTypeOidcPrompt = new FfiConverterArray(FfiConverterTypeOidcPrompt);
// FfiConverter for Array<PushCondition>
const FfiConverterArrayTypePushCondition = new FfiConverterArray(FfiConverterTypePushCondition);
// FfiConverter for Array<RoomDirectorySearchEntryUpdate>
const FfiConverterArrayTypeRoomDirectorySearchEntryUpdate = new FfiConverterArray(FfiConverterTypeRoomDirectorySearchEntryUpdate);
// FfiConverter for Array<RoomListEntriesDynamicFilterKind>
const FfiConverterArrayTypeRoomListEntriesDynamicFilterKind = new FfiConverterArray(FfiConverterTypeRoomListEntriesDynamicFilterKind);
// FfiConverter for Array<RoomListEntriesUpdate>
const FfiConverterArrayTypeRoomListEntriesUpdate = new FfiConverterArray(FfiConverterTypeRoomListEntriesUpdate);
// FfiConverter for Array<RoomMessageEventMessageType>
const FfiConverterArrayTypeRoomMessageEventMessageType = new FfiConverterArray(FfiConverterTypeRoomMessageEventMessageType);
// FfiConverter for Array<SlidingSyncVersion>
const FfiConverterArrayTypeSlidingSyncVersion = new FfiConverterArray(FfiConverterTypeSlidingSyncVersion);
// FfiConverter for Array<SpaceListUpdate>
const FfiConverterArrayTypeSpaceListUpdate = new FfiConverterArray(FfiConverterTypeSpaceListUpdate);
// FfiConverter for Array<TimelineDiff>
const FfiConverterArrayTypeTimelineDiff = new FfiConverterArray(FfiConverterTypeTimelineDiff);
// FfiConverter for Array<TraceLogPacks>
const FfiConverterArrayTypeTraceLogPacks = new FfiConverterArray(FfiConverterTypeTraceLogPacks);
// FfiConverter for Array<WidgetEventFilter>
const FfiConverterArrayTypeWidgetEventFilter = new FfiConverterArray(FfiConverterTypeWidgetEventFilter);
// FfiConverter for Array<RoomInterface>
const FfiConverterArrayTypeRoom = new FfiConverterArray(FfiConverterTypeRoom);
// FfiConverter for Array<SessionVerificationEmojiInterface>
const FfiConverterArrayTypeSessionVerificationEmoji = new FfiConverterArray(FfiConverterTypeSessionVerificationEmoji);
// FfiConverter for Array<TimelineItemInterface>
const FfiConverterArrayTypeTimelineItem = new FfiConverterArray(FfiConverterTypeTimelineItem);
// FfiConverter for Array<Action> | undefined
const FfiConverterOptionalArrayTypeAction = new FfiConverterOptional(FfiConverterArrayTypeAction);
/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
    // Get the bindings contract version from our ComponentInterface
    const bindingsContractVersion = 29;
    // Get the scaffolding contract version by calling the into the dylib
    const scaffoldingContractVersion = nativeModule().ubrn_ffi_matrix_sdk_ffi_uniffi_contract_version();
    if (bindingsContractVersion !== scaffoldingContractVersion) {
        throw new UniffiInternalError.ContractVersionMismatch(scaffoldingContractVersion, bindingsContractVersion);
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_content_without_relation_from_message() !== 1366) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_func_content_without_relation_from_message");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_create_caption_edit() !== 33992) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_func_create_caption_edit");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_gen_transaction_id() !== 15808) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_func_gen_transaction_id");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_generate_webview_url() !== 48529) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_func_generate_webview_url");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_get_element_call_required_permissions() !== 30181) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_func_get_element_call_required_permissions");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_init_platform() !== 11113) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_func_init_platform");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_is_room_alias_format_valid() !== 54845) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_func_is_room_alias_format_valid");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_log_event() !== 55646) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_func_log_event");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_make_widget_driver() !== 34206) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_func_make_widget_driver");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_matrix_to_room_alias_permalink() !== 13776) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_func_matrix_to_room_alias_permalink");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_matrix_to_user_permalink() !== 46473) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_func_matrix_to_user_permalink");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html() !== 37203) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html_as_emote() !== 8938) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html_as_emote");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown() !== 58385) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown_as_emote() !== 20152) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown_as_emote");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_message_event_content_new() !== 57839) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_func_message_event_content_new");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_new_virtual_element_call_widget() !== 7233) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_func_new_virtual_element_call_widget");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_parse_matrix_entity_from() !== 49710) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_func_parse_matrix_entity_from");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_reload_tracing_file_writer() !== 1447) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_func_reload_tracing_file_writer");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_room_alias_name_from_room_display_name() !== 65010) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_func_room_alias_name_from_room_display_name");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_sdk_git_sha() !== 4038) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_func_sdk_git_sha");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_suggested_power_level_for_role() !== 29703) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_func_suggested_power_level_for_role");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_func_suggested_role_for_power_level() !== 13856) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_func_suggested_role_for_power_level");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_checkcodesender_send() !== 50179) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_checkcodesender_send");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_abort_oidc_auth() !== 53440) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_abort_oidc_auth");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_account_data() !== 50433) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_account_data");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_account_url() !== 42373) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_account_url");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_available_sliding_sync_versions() !== 35296) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_available_sliding_sync_versions");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_avatar_url() !== 27867) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_avatar_url");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_await_room_remote_echo() !== 18126) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_await_room_remote_echo");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_cached_avatar_url() !== 50226) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_cached_avatar_url");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_can_deactivate_account() !== 39890) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_can_deactivate_account");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_clear_caches() !== 55711) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_clear_caches");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_create_room() !== 52700) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_create_room");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_custom_login_with_jwt() !== 19710) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_custom_login_with_jwt");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_deactivate_account() !== 20658) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_deactivate_account");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_delete_pusher() !== 45990) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_delete_pusher");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_device_id() !== 44340) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_device_id");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_display_name() !== 56259) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_display_name");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_enable_all_send_queues() !== 30834) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_enable_all_send_queues");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_enable_send_queue_upload_progress() !== 10688) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_enable_send_queue_upload_progress");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_encryption() !== 9657) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_encryption");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_fetch_media_preview_config() !== 15595) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_fetch_media_preview_config");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_dm_room() !== 5137) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_get_dm_room");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_invite_avatars_display_policy() !== 46953) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_get_invite_avatars_display_policy");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_max_media_upload_size() !== 12661) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_get_max_media_upload_size");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_media_content() !== 40308) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_get_media_content");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_media_file() !== 20094) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_get_media_file");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_media_preview_display_policy() !== 19264) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_get_media_preview_display_policy");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_media_thumbnail() !== 52601) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_get_media_thumbnail");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_notification_settings() !== 49769) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_get_notification_settings");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_profile() !== 60062) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_get_profile");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_recently_visited_rooms() !== 22399) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_get_recently_visited_rooms");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_room() !== 30376) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_get_room");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_alias() !== 7674) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_alias");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_id() !== 36348) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_id");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_session_verification_controller() !== 55934) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_get_session_verification_controller");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_get_url() !== 32541) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_get_url");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_homeserver() !== 26427) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_homeserver");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_homeserver_login_details() !== 63487) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_homeserver_login_details");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_ignore_user() !== 14588) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_ignore_user");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_ignored_users() !== 49620) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_ignored_users");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_is_livekit_rtc_supported() !== 34863) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_is_livekit_rtc_supported");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_is_report_room_api_supported() !== 17934) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_is_report_room_api_supported");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_is_room_alias_available() !== 23322) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_is_room_alias_available");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id() !== 64032) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id_or_alias() !== 18521) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id_or_alias");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_knock() !== 48652) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_knock");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_login() !== 33276) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_login");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_login_with_email() !== 11789) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_login_with_email");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_login_with_oidc_callback() !== 32591) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_login_with_oidc_callback");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_logout() !== 42911) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_logout");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_new_grant_login_with_qr_code_handler() !== 48299) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_new_grant_login_with_qr_code_handler");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_new_login_with_qr_code_handler() !== 4124) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_new_login_with_qr_code_handler");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_notification_client() !== 37308) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_notification_client");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_observe_account_data_event() !== 13906) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_observe_account_data_event");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_observe_room_account_data_event() !== 15699) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_observe_room_account_data_event");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_register_notification_handler() !== 47103) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_register_notification_handler");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_remove_avatar() !== 29033) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_remove_avatar");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_reset_server_info() !== 16333) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_reset_server_info");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_resolve_room_alias() !== 3551) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_resolve_room_alias");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_restore_session() !== 56125) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_restore_session");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_restore_session_with() !== 20927) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_restore_session_with");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_room_alias_exists() !== 20359) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_room_alias_exists");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_room_directory_search() !== 39855) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_room_directory_search");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_rooms() !== 29558) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_rooms");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_search_users() !== 42927) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_search_users");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_server() !== 63276) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_server");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_server_vendor_info() !== 51933) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_server_vendor_info");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_session() !== 8085) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_session");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_set_account_data() !== 18256) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_set_account_data");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_set_delegate() !== 46437) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_set_delegate");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_set_display_name() !== 15292) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_set_display_name");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_set_invite_avatars_display_policy() !== 48457) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_set_invite_avatars_display_policy");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_set_media_preview_display_policy() !== 24080) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_set_media_preview_display_policy");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_set_media_retention_policy() !== 2414) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_set_media_retention_policy");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_set_pusher() !== 41975) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_set_pusher");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_set_utd_delegate() !== 37720) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_set_utd_delegate");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_sliding_sync_version() !== 4957) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_sliding_sync_version");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_space_service() !== 31959) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_space_service");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_start_sso_login() !== 34571) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_start_sso_login");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_ignored_users() !== 23285) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_ignored_users");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_media_preview_config() !== 47047) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_media_preview_config");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_room_info() !== 41103) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_room_info");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_send_queue_status() !== 57403) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_send_queue_status");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_send_queue_updates() !== 33603) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_send_queue_updates");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_sync_service() !== 52812) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_sync_service");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_track_recently_visited_room() !== 56986) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_track_recently_visited_room");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_unignore_user() !== 8489) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_unignore_user");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_upload_avatar() !== 64486) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_upload_avatar");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_upload_media() !== 51195) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_upload_media");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_url_for_oidc() !== 19369) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_url_for_oidc");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_user_id() !== 40531) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_user_id");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_client_user_id_server_name() !== 57725) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_client_user_id_server_name");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_add_root_certificates() !== 14763) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_add_root_certificates");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_backups() !== 44502) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_backups");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_cross_signing() !== 37167) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_cross_signing");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_backup_download_strategy() !== 11959) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_backup_download_strategy");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build() !== 56018) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_cross_process_store_locks_holder_name() !== 46627) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_cross_process_store_locks_holder_name");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_decryption_settings() !== 34715) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_decryption_settings");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_automatic_token_refresh() !== 43839) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_automatic_token_refresh");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_built_in_root_certificates() !== 47525) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_built_in_root_certificates");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_ssl_verification() !== 2334) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_ssl_verification");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_enable_oidc_refresh_lock() !== 42214) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_enable_oidc_refresh_lock");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_enable_share_history_on_invite() !== 3856) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_enable_share_history_on_invite");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_homeserver_url() !== 28347) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_homeserver_url");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_in_memory_store() !== 28117) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_in_memory_store");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_indexeddb_store() !== 44062) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_indexeddb_store");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_proxy() !== 5659) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_proxy");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_request_config() !== 58783) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_request_config");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_room_key_recipient_strategy() !== 41183) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_room_key_recipient_strategy");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name() !== 29096) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name_or_homeserver_url() !== 30022) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name_or_homeserver_url");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_set_session_delegate() !== 8576) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_set_session_delegate");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_sliding_sync_version_builder() !== 39381) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_sliding_sync_version_builder");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_system_is_memory_constrained() !== 30452) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_system_is_memory_constrained");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_threads_enabled() !== 23935) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_threads_enabled");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_user_agent() !== 13719) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_user_agent");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_username() !== 45302) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_username");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_exists_on_server() !== 45490) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_exists_on_server");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state() !== 51049) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state_listener() !== 14246) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state_listener");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_curve25519_key() !== 58425) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_encryption_curve25519_key");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_disable_recovery() !== 18699) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_encryption_disable_recovery");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_ed25519_key() !== 11864) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_encryption_ed25519_key");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_backups() !== 55446) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_backups");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_recovery() !== 64351) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_recovery");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_has_devices_to_verify_against() !== 7561) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_encryption_has_devices_to_verify_against");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_is_last_device() !== 27955) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_encryption_is_last_device");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_recover() !== 33712) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_encryption_recover");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_recover_and_reset() !== 12902) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_encryption_recover_and_reset");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state() !== 54051) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state_listener() !== 36612) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state_listener");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_identity() !== 13780) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_identity");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_recovery_key() !== 20380) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_recovery_key");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_user_identity() !== 17575) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_encryption_user_identity");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state() !== 29114) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state_listener() !== 59806) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state_listener");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_backup_upload_steady_state() !== 37503) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_backup_upload_steady_state");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_e2ee_initialization_tasks() !== 41585) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_e2ee_initialization_tasks");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_grantloginwithqrcodehandler_generate() !== 56670) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_grantloginwithqrcodehandler_generate");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_grantloginwithqrcodehandler_scan() !== 60730) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_grantloginwithqrcodehandler_scan");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_sliding_sync_version() !== 36573) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_sliding_sync_version");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supported_oidc_prompts() !== 63396) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supported_oidc_prompts");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_oidc_login() !== 46090) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_oidc_login");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_password_login() !== 33501) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_password_login");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_sso_login() !== 37773) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_sso_login");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_url() !== 61326) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_url");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_auth_type() !== 43501) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_auth_type");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_cancel() !== 57622) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_cancel");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_reset() !== 11997) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_reset");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event() !== 36106) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event_id() !== 5876) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event_id");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_indexeddbstorebuilder_passphrase() !== 6201) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_indexeddbstorebuilder_passphrase");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_accept() !== 25656) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_accept");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline() !== 65054) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline_and_ban() !== 26242) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline_and_ban");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_mark_as_seen() !== 36036) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_mark_as_seen");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_contains_only_emojis() !== 5211) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_contains_only_emojis");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_debug_info() !== 55450) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_debug_info");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_send_handle() !== 46057) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_send_handle");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_shields() !== 12518) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_shields");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_leavespacehandle_leave() !== 54036) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_leavespacehandle_leave");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_leavespacehandle_rooms() !== 50920) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_leavespacehandle_rooms");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_loginwithqrcodehandler_generate() !== 59689) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_loginwithqrcodehandler_generate");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_loginwithqrcodehandler_scan() !== 53560) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_loginwithqrcodehandler_scan");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_path() !== 16357) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_path");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_persist() !== 12883) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_persist");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_mediasource_to_json() !== 23306) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_mediasource_to_json");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_mediasource_url() !== 62692) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_mediasource_url");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_notification() !== 52873) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_notification");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_notifications() !== 64372) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_notifications");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_room() !== 26581) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_room");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_homeserver_push_encrypted_event_to_device() !== 37323) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_homeserver_push_encrypted_event_to_device");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_push_encrypted_event_to_device() !== 21251) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_push_encrypted_event_to_device");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_contains_keywords_rules() !== 60025) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_contains_keywords_rules");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_default_room_notification_mode() !== 36211) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_default_room_notification_mode");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_raw_push_rules() !== 17884) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_raw_push_rules");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_room_notification_settings() !== 55295) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_room_notification_settings");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_rooms_with_user_defined_rules() !== 19849) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_rooms_with_user_defined_rules");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_user_defined_room_notification_mode() !== 18228) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_user_defined_room_notification_mode");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_call_enabled() !== 12210) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_call_enabled");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_invite_for_me_enabled() !== 533) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_invite_for_me_enabled");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_room_mention_enabled() !== 13304) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_room_mention_enabled");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_user_mention_enabled() !== 49857) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_user_mention_enabled");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_restore_default_room_notification_mode() !== 35399) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_restore_default_room_notification_mode");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_call_enabled() !== 16823) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_call_enabled");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_custom_push_rule() !== 465) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_custom_push_rule");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_default_room_notification_mode() !== 9426) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_default_room_notification_mode");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_delegate() !== 57636) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_delegate");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_invite_for_me_enabled() !== 11988) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_invite_for_me_enabled");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_mention_enabled() !== 31650) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_mention_enabled");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_notification_mode() !== 4135) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_notification_mode");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_user_mention_enabled() !== 56594) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_user_mention_enabled");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_unmute_room() !== 47580) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_unmute_room");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_qrcodedata_server_name() !== 30173) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_qrcodedata_server_name");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_active_members_count() !== 61905) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_active_members_count");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_active_room_call_participants() !== 41533) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_active_room_call_participants");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_alternative_aliases() !== 28555) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_alternative_aliases");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_apply_power_level_changes() !== 44206) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_apply_power_level_changes");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_avatar_url() !== 34637) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_avatar_url");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_ban_user() !== 35046) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_ban_user");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_canonical_alias() !== 19786) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_canonical_alias");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_clear_composer_draft() !== 59182) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_clear_composer_draft");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_clear_event_cache_storage() !== 13838) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_clear_event_cache_storage");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_decline_call() !== 36115) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_decline_call");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_discard_room_key() !== 18081) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_discard_room_key");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_display_name() !== 64194) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_display_name");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_edit() !== 61956) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_edit");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_enable_encryption() !== 14669) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_enable_encryption");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_enable_send_queue() !== 23914) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_enable_send_queue");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_encryption_state() !== 9101) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_encryption_state");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_fetch_thread_subscription() !== 51696) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_fetch_thread_subscription");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_forget() !== 37840) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_forget");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_get_power_levels() !== 47640) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_get_power_levels");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_get_room_visibility() !== 412) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_get_room_visibility");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_has_active_room_call() !== 33588) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_has_active_room_call");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_heroes() !== 22313) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_heroes");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_id() !== 61990) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_id");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_ignore_device_trust_and_resend() !== 39984) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_ignore_device_trust_and_resend");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_ignore_user() !== 62239) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_ignore_user");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_invite_user_by_id() !== 41133) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_invite_user_by_id");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_invited_members_count() !== 1023) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_invited_members_count");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_inviter() !== 18103) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_inviter");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_is_direct() !== 10462) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_is_direct");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_is_encrypted() !== 63995) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_is_encrypted");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_is_public() !== 57746) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_is_public");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_is_send_queue_enabled() !== 36591) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_is_send_queue_enabled");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_is_space() !== 16919) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_is_space");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_join() !== 9240) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_join");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_joined_members_count() !== 55835) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_joined_members_count");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_kick_user() !== 28600) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_kick_user");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_latest_encryption_state() !== 16843) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_latest_encryption_state");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_latest_event() !== 39083) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_latest_event");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_leave() !== 63688) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_leave");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_load_composer_draft() !== 62856) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_load_composer_draft");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_load_or_fetch_event() !== 12703) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_load_or_fetch_event");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_mark_as_fully_read_unchecked() !== 24981) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_mark_as_fully_read_unchecked");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_mark_as_read() !== 57806) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_mark_as_read");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_event_permalink() !== 36705) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_event_permalink");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_permalink() !== 47781) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_permalink");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_member() !== 48980) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_member");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_member_avatar_url() !== 29492) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_member_avatar_url");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_member_display_name() !== 33206) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_member_display_name");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_member_with_sender_info() !== 64964) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_member_with_sender_info");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_members() !== 42691) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_members");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_members_no_sync() !== 3255) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_members_no_sync");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_membership() !== 45951) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_membership");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_new_latest_event() !== 11947) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_new_latest_event");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_own_user_id() !== 39510) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_own_user_id");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_predecessor_room() !== 22093) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_predecessor_room");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_preview_room() !== 60431) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_preview_room");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_publish_room_alias_in_room_directory() !== 13924) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_publish_room_alias_in_room_directory");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_raw_name() !== 15453) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_raw_name");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_redact() !== 45810) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_redact");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_remove_avatar() !== 7230) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_remove_avatar");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_remove_room_alias_from_room_directory() !== 16926) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_remove_room_alias_from_room_directory");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_report_content() !== 16529) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_report_content");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_report_room() !== 6449) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_report_room");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_reset_power_levels() !== 5060) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_reset_power_levels");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_room_events_debug_string() !== 37832) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_room_events_debug_string");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_room_info() !== 41146) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_room_info");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_save_composer_draft() !== 27585) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_save_composer_draft");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_send_live_location() !== 34248) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_send_live_location");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_send_raw() !== 20486) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_send_raw");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_set_is_favourite() !== 64403) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_set_is_favourite");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_set_is_low_priority() !== 48070) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_set_is_low_priority");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_set_name() !== 52127) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_set_name");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_set_thread_subscription() !== 48337) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_set_thread_subscription");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_set_topic() !== 5576) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_set_topic");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_set_unread_flag() !== 2381) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_set_unread_flag");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_start_live_location_share() !== 11488) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_start_live_location_share");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_stop_live_location_share() !== 19983) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_stop_live_location_share");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_call_decline_events() !== 62256) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_call_decline_events");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_identity_status_changes() !== 8526) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_identity_status_changes");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_knock_requests() !== 30649) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_knock_requests");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_live_location_shares() !== 57037) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_live_location_shares");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_room_info_updates() !== 48209) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_room_info_updates");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_send_queue_updates() !== 17661) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_send_queue_updates");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_typing_notifications() !== 38524) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_typing_notifications");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_successor_room() !== 27360) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_successor_room");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_suggested_role_for_user() !== 47787) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_suggested_role_for_user");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_timeline() !== 51477) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_timeline");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_timeline_with_configuration() !== 35159) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_timeline_with_configuration");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_topic() !== 59745) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_topic");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_typing_notice() !== 28642) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_typing_notice");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_unban_user() !== 1803) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_unban_user");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_update_canonical_alias() !== 25065) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_update_canonical_alias");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_update_history_visibility() !== 26248) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_update_history_visibility");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_update_join_rules() !== 49303) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_update_join_rules");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_update_power_levels_for_users() !== 52057) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_update_power_levels_for_users");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_update_room_visibility() !== 64724) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_update_room_visibility");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_upload_avatar() !== 19069) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_upload_avatar");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_room_withdraw_verification_and_resend() !== 33485) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_room_withdraw_verification_and_resend");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_is_at_last_page() !== 34221) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_is_at_last_page");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_loaded_pages() !== 2923) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_loaded_pages");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_next_page() !== 29305) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_next_page");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_results() !== 30207) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_results");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_search() !== 24438) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_search");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlist_entries_with_dynamic_adapters() !== 36097) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roomlist_entries_with_dynamic_adapters");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlist_entries_with_dynamic_adapters_with() !== 21746) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roomlist_entries_with_dynamic_adapters_with");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlist_loading_state() !== 21585) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roomlist_loading_state");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlist_room() !== 62491) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roomlist_room");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_add_one_page() !== 47748) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_add_one_page");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_reset_to_one_page() !== 61352) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_reset_to_one_page");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_set_filter() !== 61202) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_set_filter");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_controller() !== 36258) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_controller");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_entries_stream() !== 56632) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_entries_stream");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_all_rooms() !== 49704) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_all_rooms");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_room() !== 60695) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_room");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_state() !== 64650) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_state");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_subscribe_to_rooms() !== 5528) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_subscribe_to_rooms");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_sync_indicator() !== 16821) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_sync_indicator");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_len() !== 39835) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_len");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_next_chunk() !== 23186) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_next_chunk");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roommessageeventcontentwithoutrelation_with_mentions() !== 8867) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roommessageeventcontentwithoutrelation_with_mentions");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_ban() !== 7183) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_ban");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_invite() !== 57708) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_invite");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_kick() !== 461) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_kick");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_pin_unpin() !== 52852) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_pin_unpin");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_redact_other() !== 60699) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_redact_other");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_redact_own() !== 32905) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_redact_own");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_send_message() !== 2424) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_send_message");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_send_state() !== 33539) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_send_state");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_trigger_room_notification() !== 64150) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_trigger_room_notification");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_ban() !== 57457) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_ban");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_invite() !== 41275) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_invite");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_kick() !== 51066) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_kick");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_pin_unpin() !== 4609) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_pin_unpin");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_redact_other() !== 52543) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_redact_other");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_redact_own() !== 2983) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_redact_own");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_send_message() !== 48291) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_send_message");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_send_state() !== 14792) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_send_state");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_trigger_room_notification() !== 26319) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_trigger_room_notification");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_user_power_levels() !== 16221) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_user_power_levels");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_values() !== 38774) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_values");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompreview_forget() !== 18179) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roompreview_forget");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompreview_info() !== 50237) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roompreview_info");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompreview_inviter() !== 1297) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roompreview_inviter");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompreview_leave() !== 21886) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roompreview_leave");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roompreview_own_membership_details() !== 46321) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roompreview_own_membership_details");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_cancel() !== 62384) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_cancel");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_join() !== 1903) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_join");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sendhandle_abort() !== 11570) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_sendhandle_abort");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sendhandle_try_resend() !== 28691) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_sendhandle_try_resend");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_accept_verification_request() !== 53466) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_accept_verification_request");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_acknowledge_verification_request() !== 37982) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_acknowledge_verification_request");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_approve_verification() !== 27140) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_approve_verification");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_cancel_verification() !== 32994) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_cancel_verification");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_decline_verification() !== 64345) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_decline_verification");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_device_verification() !== 4777) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_device_verification");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_user_verification() !== 26149) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_user_verification");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_set_delegate() !== 42324) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_set_delegate");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_start_sas_verification() !== 16328) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_start_sas_verification");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_description() !== 21346) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_description");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_symbol() !== 46075) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_symbol");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_paginate() !== 57707) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_paginate");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_pagination_state() !== 33381) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_pagination_state");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_rooms() !== 24664) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_rooms");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_space() !== 25368) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_space");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_subscribe_to_pagination_state_updates() !== 16775) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_subscribe_to_pagination_state_updates");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_subscribe_to_room_update() !== 55793) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_subscribe_to_room_update");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_subscribe_to_space_updates() !== 26327) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_subscribe_to_space_updates");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_spaceservice_add_child_to_space() !== 31295) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_spaceservice_add_child_to_space");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_spaceservice_editable_spaces() !== 62969) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_spaceservice_editable_spaces");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_spaceservice_joined_parents_of_child() !== 18724) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_spaceservice_joined_parents_of_child");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_spaceservice_joined_spaces() !== 54285) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_spaceservice_joined_spaces");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_spaceservice_leave_space() !== 7949) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_spaceservice_leave_space");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_spaceservice_remove_child_from_space() !== 14438) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_spaceservice_remove_child_from_space");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_spaceservice_space_room_list() !== 6768) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_spaceservice_space_room_list");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_spaceservice_subscribe_to_joined_spaces() !== 10090) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_spaceservice_subscribe_to_joined_spaces");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_span_enter() !== 8900) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_span_enter");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_span_exit() !== 47924) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_span_exit");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_span_is_none() !== 33327) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_span_is_none");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_ssohandler_finish() !== 64706) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_ssohandler_finish");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_ssohandler_url() !== 10889) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_ssohandler_url");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservice_expire_sessions() !== 45579) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_syncservice_expire_sessions");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservice_room_list_service() !== 26426) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_syncservice_room_list_service");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservice_start() !== 16010) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_syncservice_start");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservice_state() !== 61806) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_syncservice_state");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservice_stop() !== 42435) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_syncservice_stop");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_finish() !== 22814) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_finish");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_cross_process_lock() !== 56326) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_cross_process_lock");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_offline_mode() !== 16958) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_offline_mode");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_share_pos() !== 18892) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_share_pos");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_taskhandle_cancel() !== 9124) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_taskhandle_cancel");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_taskhandle_is_finished() !== 29008) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_taskhandle_is_finished");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_threadsummary_latest_event() !== 52917) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_threadsummary_latest_event");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_threadsummary_num_replies() !== 10634) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_threadsummary_num_replies");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_add_listener() !== 18746) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_add_listener");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_create_message_content() !== 21811) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_create_message_content");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_create_poll() !== 37925) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_create_poll");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_edit() !== 42189) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_edit");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_end_poll() !== 32659) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_end_poll");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_details_for_event() !== 54068) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_details_for_event");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_members() !== 37994) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_members");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_get_event_timeline_item_by_event_id() !== 33999) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_get_event_timeline_item_by_event_id");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_latest_event_id() !== 18266) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_latest_event_id");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_load_reply_details() !== 54225) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_load_reply_details");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_mark_as_read() !== 16621) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_mark_as_read");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_backwards() !== 36829) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_backwards");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_forwards() !== 30268) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_forwards");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_pin_event() !== 41687) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_pin_event");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_redact_event() !== 48707) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_redact_event");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_retry_decryption() !== 21112) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_retry_decryption");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send() !== 9553) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_send");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_audio() !== 36723) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_send_audio");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_file() !== 4740) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_send_file");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_image() !== 29043) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_send_image");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_location() !== 39080) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_send_location");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_poll_response() !== 7453) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_send_poll_response");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_read_receipt() !== 37532) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_send_read_receipt");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_reply() !== 11149) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_send_reply");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_video() !== 52974) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_send_video");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_send_voice_message() !== 41701) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_send_voice_message");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_subscribe_to_back_pagination_status() !== 46161) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_subscribe_to_back_pagination_status");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_toggle_reaction() !== 13555) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_toggle_reaction");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timeline_unpin_event() !== 52414) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timeline_unpin_event");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_id() !== 11088) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_id");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_type() !== 12922) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_type");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelineevent_sender_id() !== 18142) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timelineevent_sender_id");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelineevent_thread_root_event_id() !== 56465) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timelineevent_thread_root_event_id");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelineevent_timestamp() !== 50929) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timelineevent_timestamp");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_event() !== 6106) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_event");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_virtual() !== 50960) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_virtual");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelineitem_fmt_debug() !== 38094) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timelineitem_fmt_debug");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelineitem_unique_id() !== 39945) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timelineitem_unique_id");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_has_notifications() !== 33024) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_has_notifications");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_highlight_count() !== 35997) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_highlight_count");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_notification_count() !== 35655) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_notification_count");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_useridentity_has_verification_violation() !== 2948) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_useridentity_has_verification_violation");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_useridentity_is_verified() !== 61954) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_useridentity_is_verified");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_useridentity_master_key() !== 4041) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_useridentity_master_key");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_useridentity_pin() !== 62925) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_useridentity_pin");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_useridentity_was_previously_verified() !== 41686) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_useridentity_was_previously_verified");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_useridentity_withdraw_verification() !== 3578) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_useridentity_withdraw_verification");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_widgetdriver_run() !== 7519) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_widgetdriver_run");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_recv() !== 2662) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_recv");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_send() !== 18689) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_send");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_clientbuilder_new() !== 27991) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_constructor_clientbuilder_new");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_indexeddbstorebuilder_new() !== 18628) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_constructor_indexeddbstorebuilder_new");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_json() !== 10564) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_json");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_url() !== 11983) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_url");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_qrcodedata_from_bytes() !== 32675) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_constructor_qrcodedata_from_bytes");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_span_current() !== 53698) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_constructor_span_current");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_span_new() !== 8957) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_constructor_span_new");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_span_new_bridge_span() !== 63835) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_constructor_span_new_bridge_span");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_exclude() !== 53805) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_exclude");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_include() !== 25498) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_include");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_accountdatalistener_on_change() !== 16189) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_accountdatalistener_on_change");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_backupstatelistener_on_update() !== 12849) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_backupstatelistener_on_update");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_backupsteadystatelistener_on_update() !== 41052) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_backupsteadystatelistener_on_update");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_calldeclinelistener_call() !== 13016) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_calldeclinelistener_call");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientdelegate_did_receive_auth_error() !== 26350) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientdelegate_did_receive_auth_error");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_retrieve_session_from_keychain() !== 43954) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_retrieve_session_from_keychain");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_save_session_in_keychain() !== 53223) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_save_session_in_keychain");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_enablerecoveryprogresslistener_on_update() !== 13538) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_enablerecoveryprogresslistener_on_update");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_generatedqrloginprogresslistener_on_update() !== 28731) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_generatedqrloginprogresslistener_on_update");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_grantgeneratedqrloginprogresslistener_on_update() !== 2320) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_grantgeneratedqrloginprogresslistener_on_update");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_grantqrloginprogresslistener_on_update() !== 35830) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_grantqrloginprogresslistener_on_update");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_identitystatuschangelistener_call() !== 57311) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_identitystatuschangelistener_call");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_ignoreduserslistener_call() !== 47519) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_ignoreduserslistener_call");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_knockrequestslistener_call() !== 10077) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_knockrequestslistener_call");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_livelocationsharelistener_call() !== 34519) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_livelocationsharelistener_call");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_mediapreviewconfiglistener_on_change() !== 14770) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_mediapreviewconfiglistener_on_change");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_notificationsettingsdelegate_settings_did_change() !== 51708) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_notificationsettingsdelegate_settings_did_change");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_paginationstatuslistener_on_update() !== 65318) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_paginationstatuslistener_on_update");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_progresswatcher_transmission_progress() !== 41133) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_progresswatcher_transmission_progress");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_qrloginprogresslistener_on_update() !== 9758) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_qrloginprogresslistener_on_update");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_recoverystatelistener_on_update() !== 64575) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_recoverystatelistener_on_update");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomaccountdatalistener_on_change() !== 58105) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roomaccountdatalistener_on_change");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearchentrieslistener_on_update() !== 41968) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearchentrieslistener_on_update");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roominfolistener_call() !== 44934) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roominfolistener_call");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieslistener_on_update() !== 12576) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieslistener_on_update");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistloadingstatelistener_on_update() !== 23169) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roomlistloadingstatelistener_on_update");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistservicestatelistener_on_update() !== 24823) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roomlistservicestatelistener_on_update");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_roomlistservicesyncindicatorlistener_on_update() !== 36937) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_roomlistservicesyncindicatorlistener_on_update");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sendqueuelistener_on_update() !== 24843) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_sendqueuelistener_on_update");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sendqueueroomerrorlistener_on_error() !== 38224) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_sendqueueroomerrorlistener_on_error");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sendqueueroomupdatelistener_on_update() !== 11544) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_sendqueueroomupdatelistener_on_update");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_request() !== 3417) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_request");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_accept_verification_request() !== 3733) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_accept_verification_request");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_start_sas_verification() !== 56833) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_start_sas_verification");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_data() !== 30840) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_data");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_fail() !== 32164) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_fail");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_cancel() !== 3367) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_cancel");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_finish() !== 37905) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_finish");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_spaceroomlistentrieslistener_on_update() !== 31502) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_spaceroomlistentrieslistener_on_update");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_spaceroomlistpaginationstatelistener_on_update() !== 11960) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_spaceroomlistpaginationstatelistener_on_update");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_spaceroomlistspacelistener_on_update() !== 39714) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_spaceroomlistspacelistener_on_update");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_spaceservicejoinedspaceslistener_on_update() !== 19262) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_spaceservicejoinedspaceslistener_on_update");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncnotificationlistener_on_notification() !== 38017) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_syncnotificationlistener_on_notification");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_syncservicestateobserver_on_update() !== 62231) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_syncservicestateobserver_on_update");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_timelinelistener_on_update() !== 53990) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_timelinelistener_on_update");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_typingnotificationslistener_call() !== 64299) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_typingnotificationslistener_call");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_unabletodecryptdelegate_on_utd() !== 61791) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_unabletodecryptdelegate_on_utd");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_verificationstatelistener_on_update() !== 38998) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_verificationstatelistener_on_update");
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_ffi_checksum_method_widgetcapabilitiesprovider_acquire_capabilities() !== 12846) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_ffi_checksum_method_widgetcapabilitiesprovider_acquire_capabilities");
    }
    uniffiCallbackInterfaceAccountDataListener.register();
    uniffiCallbackInterfaceBackupStateListener.register();
    uniffiCallbackInterfaceBackupSteadyStateListener.register();
    uniffiCallbackInterfaceCallDeclineListener.register();
    uniffiCallbackInterfaceClientDelegate.register();
    uniffiCallbackInterfaceClientSessionDelegate.register();
    uniffiCallbackInterfaceEnableRecoveryProgressListener.register();
    uniffiCallbackInterfaceGeneratedQrLoginProgressListener.register();
    uniffiCallbackInterfaceGrantGeneratedQrLoginProgressListener.register();
    uniffiCallbackInterfaceGrantQrLoginProgressListener.register();
    uniffiCallbackInterfaceIdentityStatusChangeListener.register();
    uniffiCallbackInterfaceIgnoredUsersListener.register();
    uniffiCallbackInterfaceKnockRequestsListener.register();
    uniffiCallbackInterfaceLiveLocationShareListener.register();
    uniffiCallbackInterfaceMediaPreviewConfigListener.register();
    uniffiCallbackInterfaceNotificationSettingsDelegate.register();
    uniffiCallbackInterfacePaginationStatusListener.register();
    uniffiCallbackInterfaceProgressWatcher.register();
    uniffiCallbackInterfaceQrLoginProgressListener.register();
    uniffiCallbackInterfaceRecoveryStateListener.register();
    uniffiCallbackInterfaceRoomAccountDataListener.register();
    uniffiCallbackInterfaceRoomDirectorySearchEntriesListener.register();
    uniffiCallbackInterfaceRoomInfoListener.register();
    uniffiCallbackInterfaceRoomListEntriesListener.register();
    uniffiCallbackInterfaceRoomListLoadingStateListener.register();
    uniffiCallbackInterfaceRoomListServiceStateListener.register();
    uniffiCallbackInterfaceRoomListServiceSyncIndicatorListener.register();
    uniffiCallbackInterfaceSendQueueListener.register();
    uniffiCallbackInterfaceSendQueueRoomErrorListener.register();
    uniffiCallbackInterfaceSendQueueRoomUpdateListener.register();
    uniffiCallbackInterfaceSessionVerificationControllerDelegate.register();
    uniffiCallbackInterfaceSpaceRoomListEntriesListener.register();
    uniffiCallbackInterfaceSpaceRoomListPaginationStateListener.register();
    uniffiCallbackInterfaceSpaceRoomListSpaceListener.register();
    uniffiCallbackInterfaceSpaceServiceJoinedSpacesListener.register();
    uniffiCallbackInterfaceSyncNotificationListener.register();
    uniffiCallbackInterfaceSyncServiceStateObserver.register();
    uniffiCallbackInterfaceTimelineListener.register();
    uniffiCallbackInterfaceTypingNotificationsListener.register();
    uniffiCallbackInterfaceUnableToDecryptDelegate.register();
    uniffiCallbackInterfaceVerificationStateListener.register();
    uniffiCallbackInterfaceWidgetCapabilitiesProvider.register();
}
export default Object.freeze({
    initialize: uniffiEnsureInitialized,
    converters: {
        FfiConverterTypeAbstractProgress,
        FfiConverterTypeAccountDataEvent,
        FfiConverterTypeAccountDataEventType,
        FfiConverterTypeAccountManagementAction,
        FfiConverterTypeAction,
        FfiConverterTypeAllowRule,
        FfiConverterTypeAssetType,
        FfiConverterTypeAudioInfo,
        FfiConverterTypeAudioMessageContent,
        FfiConverterTypeAuthData,
        FfiConverterTypeAuthDataPasswordDetails,
        FfiConverterTypeBackupState,
        FfiConverterTypeBackupUploadState,
        FfiConverterTypeBatchNotificationResult,
        FfiConverterTypeCheckCodeSender,
        FfiConverterTypeClient,
        FfiConverterTypeClientBuildError,
        FfiConverterTypeClientBuilder,
        FfiConverterTypeClientError,
        FfiConverterTypeClientProperties,
        FfiConverterTypeComparisonOperator,
        FfiConverterTypeComposerDraft,
        FfiConverterTypeComposerDraftType,
        FfiConverterTypeConditionalPushRule,
        FfiConverterTypeCreateRoomParameters,
        FfiConverterTypeCrossSigningResetAuthType,
        FfiConverterTypeDateDividerMode,
        FfiConverterTypeDraftAttachment,
        FfiConverterTypeEditedContent,
        FfiConverterTypeEmbeddedEventDetails,
        FfiConverterTypeEmoteMessageContent,
        FfiConverterTypeEnableRecoveryProgress,
        FfiConverterTypeEncryptedMessage,
        FfiConverterTypeEncryption,
        FfiConverterTypeErrorKind,
        FfiConverterTypeEventOrTransactionId,
        FfiConverterTypeEventSendState,
        FfiConverterTypeEventTimelineItem,
        FfiConverterTypeEventTimelineItemDebugInfo,
        FfiConverterTypeFileInfo,
        FfiConverterTypeFileMessageContent,
        FfiConverterTypeFilterTimelineEventType,
        FfiConverterTypeFocusEventError,
        FfiConverterTypeFormattedBody,
        FfiConverterTypeGeneratedQrLoginProgress,
        FfiConverterTypeGrantGeneratedQrLoginProgress,
        FfiConverterTypeGrantLoginWithQrCodeHandler,
        FfiConverterTypeGrantQrLoginProgress,
        FfiConverterTypeHistoryVisibility,
        FfiConverterTypeHomeserverLoginDetails,
        FfiConverterTypeHttpPusherData,
        FfiConverterTypeHumanQrGrantLoginError,
        FfiConverterTypeHumanQrLoginError,
        FfiConverterTypeIdentityResetHandle,
        FfiConverterTypeIdentityStatusChange,
        FfiConverterTypeIgnoredUser,
        FfiConverterTypeImageInfo,
        FfiConverterTypeImageMessageContent,
        FfiConverterTypeInReplyToDetails,
        FfiConverterTypeIndexedDbStoreBuilder,
        FfiConverterTypeInviteAvatars,
        FfiConverterTypeJoinRule,
        FfiConverterTypeJsonValue,
        FfiConverterTypeKeyDerivationAlgorithm,
        FfiConverterTypeKnockRequest,
        FfiConverterTypeKnockRequestActions,
        FfiConverterTypeLastLocation,
        FfiConverterTypeLatestEventValue,
        FfiConverterTypeLazyTimelineItemProvider,
        FfiConverterTypeLeaveSpaceHandle,
        FfiConverterTypeLeaveSpaceRoom,
        FfiConverterTypeLiveLocationShare,
        FfiConverterTypeLocationContent,
        FfiConverterTypeLogLevel,
        FfiConverterTypeLoginWithQrCodeHandler,
        FfiConverterTypeMatrixEntity,
        FfiConverterTypeMatrixId,
        FfiConverterTypeMediaFileHandle,
        FfiConverterTypeMediaInfoError,
        FfiConverterTypeMediaPreviewConfig,
        FfiConverterTypeMediaPreviews,
        FfiConverterTypeMediaSource,
        FfiConverterTypeMediaUploadProgress,
        FfiConverterTypeMembership,
        FfiConverterTypeMembershipChange,
        FfiConverterTypeMembershipState,
        FfiConverterTypeMentions,
        FfiConverterTypeMessageContent,
        FfiConverterTypeMessageFormat,
        FfiConverterTypeMessageLikeEventContent,
        FfiConverterTypeMessageLikeEventType,
        FfiConverterTypeMessageType,
        FfiConverterTypeMsgLikeContent,
        FfiConverterTypeMsgLikeKind,
        FfiConverterTypeNoticeMessageContent,
        FfiConverterTypeNotificationClient,
        FfiConverterTypeNotificationEvent,
        FfiConverterTypeNotificationItem,
        FfiConverterTypeNotificationItemsRequest,
        FfiConverterTypeNotificationPowerLevels,
        FfiConverterTypeNotificationProcessSetup,
        FfiConverterTypeNotificationRoomInfo,
        FfiConverterTypeNotificationSenderInfo,
        FfiConverterTypeNotificationSettings,
        FfiConverterTypeNotificationSettingsError,
        FfiConverterTypeNotificationStatus,
        FfiConverterTypeOidcConfiguration,
        FfiConverterTypeOidcCrossSigningResetInfo,
        FfiConverterTypeOidcError,
        FfiConverterTypeOidcPrompt,
        FfiConverterTypeOtherState,
        FfiConverterTypeParseError,
        FfiConverterTypePassPhrase,
        FfiConverterTypePatternedPushRule,
        FfiConverterTypePollAnswer,
        FfiConverterTypePollData,
        FfiConverterTypePollKind,
        FfiConverterTypePowerLevel,
        FfiConverterTypePowerLevels,
        FfiConverterTypePredecessorRoom,
        FfiConverterTypeProfileDetails,
        FfiConverterTypePublicRoomJoinRule,
        FfiConverterTypePushCondition,
        FfiConverterTypePushFormat,
        FfiConverterTypePusherIdentifiers,
        FfiConverterTypePusherKind,
        FfiConverterTypeQrCodeData,
        FfiConverterTypeQrCodeDecodeError,
        FfiConverterTypeQrLoginProgress,
        FfiConverterTypeQueueWedgeError,
        FfiConverterTypeReaction,
        FfiConverterTypeReactionSenderData,
        FfiConverterTypeReceipt,
        FfiConverterTypeReceiptType,
        FfiConverterTypeRecoveryError,
        FfiConverterTypeRecoveryState,
        FfiConverterTypeRequestConfig,
        FfiConverterTypeResolvedRoomAlias,
        FfiConverterTypeRoom,
        FfiConverterTypeRoomAccountDataEvent,
        FfiConverterTypeRoomAccountDataEventType,
        FfiConverterTypeRoomDescription,
        FfiConverterTypeRoomDirectorySearch,
        FfiConverterTypeRoomDirectorySearchEntryUpdate,
        FfiConverterTypeRoomError,
        FfiConverterTypeRoomHero,
        FfiConverterTypeRoomHistoryVisibility,
        FfiConverterTypeRoomInfo,
        FfiConverterTypeRoomList,
        FfiConverterTypeRoomListDynamicEntriesController,
        FfiConverterTypeRoomListEntriesDynamicFilterKind,
        FfiConverterTypeRoomListEntriesUpdate,
        FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult,
        FfiConverterTypeRoomListError,
        FfiConverterTypeRoomListFilterCategory,
        FfiConverterTypeRoomListLoadingState,
        FfiConverterTypeRoomListLoadingStateResult,
        FfiConverterTypeRoomListService,
        FfiConverterTypeRoomListServiceState,
        FfiConverterTypeRoomListServiceSyncIndicator,
        FfiConverterTypeRoomLoadSettings,
        FfiConverterTypeRoomMember,
        FfiConverterTypeRoomMemberWithSenderInfo,
        FfiConverterTypeRoomMembersIterator,
        FfiConverterTypeRoomMessageEventContentWithoutRelation,
        FfiConverterTypeRoomMessageEventMessageType,
        FfiConverterTypeRoomNotificationMode,
        FfiConverterTypeRoomNotificationSettings,
        FfiConverterTypeRoomPowerLevels,
        FfiConverterTypeRoomPowerLevelsValues,
        FfiConverterTypeRoomPreset,
        FfiConverterTypeRoomPreview,
        FfiConverterTypeRoomPreviewInfo,
        FfiConverterTypeRoomSendQueueUpdate,
        FfiConverterTypeRoomType,
        FfiConverterTypeRoomVisibility,
        FfiConverterTypeRtcNotificationType,
        FfiConverterTypeRuleKind,
        FfiConverterTypeRuleset,
        FfiConverterTypeSearchUsersResults,
        FfiConverterTypeSecretStorageEncryptionAlgorithm,
        FfiConverterTypeSecretStorageV1AesHmacSha2Properties,
        FfiConverterTypeSendAttachmentJoinHandle,
        FfiConverterTypeSendHandle,
        FfiConverterTypeSession,
        FfiConverterTypeSessionVerificationController,
        FfiConverterTypeSessionVerificationData,
        FfiConverterTypeSessionVerificationEmoji,
        FfiConverterTypeSessionVerificationRequestDetails,
        FfiConverterTypeShieldState,
        FfiConverterTypeSimplePushRule,
        FfiConverterTypeSlidingSyncVersion,
        FfiConverterTypeSlidingSyncVersionBuilder,
        FfiConverterTypeSpaceListUpdate,
        FfiConverterTypeSpaceRoom,
        FfiConverterTypeSpaceRoomList,
        FfiConverterTypeSpaceService,
        FfiConverterTypeSpan,
        FfiConverterTypeSsoError,
        FfiConverterTypeSsoHandler,
        FfiConverterTypeStateEventContent,
        FfiConverterTypeStateEventType,
        FfiConverterTypeSteadyStateError,
        FfiConverterTypeSuccessorRoom,
        FfiConverterTypeSyncService,
        FfiConverterTypeSyncServiceBuilder,
        FfiConverterTypeSyncServiceState,
        FfiConverterTypeTagInfo,
        FfiConverterTypeTagName,
        FfiConverterTypeTaskHandle,
        FfiConverterTypeTextMessageContent,
        FfiConverterTypeThreadSubscription,
        FfiConverterTypeThreadSummary,
        FfiConverterTypeThumbnailInfo,
        FfiConverterTypeTimeline,
        FfiConverterTypeTimelineConfiguration,
        FfiConverterTypeTimelineDiff,
        FfiConverterTypeTimelineEvent,
        FfiConverterTypeTimelineEventType,
        FfiConverterTypeTimelineEventTypeFilter,
        FfiConverterTypeTimelineFilter,
        FfiConverterTypeTimelineFocus,
        FfiConverterTypeTimelineItem,
        FfiConverterTypeTimelineItemContent,
        FfiConverterTypeTimelineUniqueId,
        FfiConverterTypeTimestamp,
        FfiConverterTypeTraceLogPacks,
        FfiConverterTypeTracingConfiguration,
        FfiConverterTypeTracingFileConfiguration,
        FfiConverterTypeTransmissionProgress,
        FfiConverterTypeTweak,
        FfiConverterTypeUnableToDecryptInfo,
        FfiConverterTypeUnreadNotificationsCount,
        FfiConverterTypeUnstableAudioDetailsContent,
        FfiConverterTypeUnstableVoiceContent,
        FfiConverterTypeUploadParameters,
        FfiConverterTypeUploadSource,
        FfiConverterTypeUserIdentity,
        FfiConverterTypeUserPowerLevelUpdate,
        FfiConverterTypeUserProfile,
        FfiConverterTypeUserTagName,
        FfiConverterTypeVerificationState,
        FfiConverterTypeVideoInfo,
        FfiConverterTypeVideoMessageContent,
        FfiConverterTypeVirtualTimelineItem,
        FfiConverterTypeWidgetCapabilities,
        FfiConverterTypeWidgetDriver,
        FfiConverterTypeWidgetDriverAndHandle,
        FfiConverterTypeWidgetDriverHandle,
        FfiConverterTypeWidgetEventFilter,
        FfiConverterTypeWidgetSettings,
    }
});
