// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
import * as wasmBundle from "./wasm-bindgen/index.js";
import { AbstractFfiConverterByteArray, FfiConverterInt32, UniffiError, UniffiInternalError, UniffiRustCaller, uniffiCreateFfiConverterString, uniffiCreateRecord, uniffiTypeNameSymbol, variantOrdinalSymbol } from "uniffi-bindgen-react-native";
// Get converters from the other files, if any.
const nativeModule = () => wasmBundle;
const uniffiCaller = new UniffiRustCaller(() => new wasmBundle.RustCallStatus());
const uniffiIsDebug = 
// @ts-ignore -- The process global might not be defined
typeof process !== "object" ||
    // @ts-ignore -- The process global might not be defined
    process?.env?.NODE_ENV !== "production" ||
    false;
/**
 * Generated factory for {@link DecryptionSettings} record objects.
 */
export const DecryptionSettings = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link DecryptionSettings}, with defaults specified
         * in Rust, in the {@link matrix_sdk_crypto} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link DecryptionSettings}, with defaults specified
         * in Rust, in the {@link matrix_sdk_crypto} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_crypto} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeDecryptionSettings = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                senderDeviceTrustRequirement: FfiConverterTypeTrustRequirement.read(from)
            };
        }
        write(value, into) {
            FfiConverterTypeTrustRequirement.write(value.senderDeviceTrustRequirement, into);
        }
        allocationSize(value) {
            return FfiConverterTypeTrustRequirement.allocationSize(value.senderDeviceTrustRequirement);
        }
    }
    ;
    return new FFIConverter();
})();
const stringConverter = (() => {
    const encoder = new TextEncoder();
    const decoder = new TextDecoder();
    return {
        stringToBytes: (s) => encoder.encode(s),
        bytesToString: (ab) => decoder.decode(ab),
        stringByteLength: (s) => encoder.encode(s).byteLength,
    };
})();
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);
/**
 * Strategy to collect the devices that should receive room keys for the
 * current discussion.
 */
export var CollectStrategy;
(function (CollectStrategy) {
    /**
     * Share with all (unblacklisted) devices.
     */
    CollectStrategy[CollectStrategy["AllDevices"] = 0] = "AllDevices";
    /**
     * Share with all devices, except errors for *verified* users cause sharing
     * to fail with an error.
     *
     * In this strategy, if a verified user has an unsigned device,
     * key sharing will fail with a
     * [`SessionRecipientCollectionError::VerifiedUserHasUnsignedDevice`].
     * If a verified user has replaced their identity, key
     * sharing will fail with a
     * [`SessionRecipientCollectionError::VerifiedUserChangedIdentity`].
     *
     * Otherwise, keys are shared with unsigned devices as normal.
     *
     * Once the problematic devices are blacklisted or whitelisted the
     * caller can retry to share a second time.
     */
    CollectStrategy[CollectStrategy["ErrorOnVerifiedUserProblem"] = 1] = "ErrorOnVerifiedUserProblem";
    /**
     * Share based on identity. Only distribute to devices signed by their
     * owner. If a user has no published identity he will not receive
     * any room keys.
     */
    CollectStrategy[CollectStrategy["IdentityBasedStrategy"] = 2] = "IdentityBasedStrategy";
    /**
     * Only share keys with devices that we "trust". A device is trusted if any
     * of the following is true:
     * - It was manually marked as trusted.
     * - It was marked as verified via interactive verification.
     * - It is signed by its owner identity, and this identity has been
     * trusted via interactive verification.
     * - It is the current own device of the user.
     */
    CollectStrategy[CollectStrategy["OnlyTrustedDevices"] = 3] = "OnlyTrustedDevices";
})(CollectStrategy || (CollectStrategy = {}));
const FfiConverterTypeCollectStrategy = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return CollectStrategy.AllDevices;
                case 2: return CollectStrategy.ErrorOnVerifiedUserProblem;
                case 3: return CollectStrategy.IdentityBasedStrategy;
                case 4: return CollectStrategy.OnlyTrustedDevices;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case CollectStrategy.AllDevices: return ordinalConverter.write(1, into);
                case CollectStrategy.ErrorOnVerifiedUserProblem: return ordinalConverter.write(2, into);
                case CollectStrategy.IdentityBasedStrategy: return ordinalConverter.write(3, into);
                case CollectStrategy.OnlyTrustedDevices: return ordinalConverter.write(4, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
/**
 * The state of an identity - verified, pinned etc.
 */
export var IdentityState;
(function (IdentityState) {
    /**
     * The user is verified with us
     */
    IdentityState[IdentityState["Verified"] = 0] = "Verified";
    /**
     * Either this is the first identity we have seen for this user, or the
     * user has acknowledged a change of identity explicitly e.g. by
     * clicking OK on a notification.
     */
    IdentityState[IdentityState["Pinned"] = 1] = "Pinned";
    /**
     * The user's identity has changed since it was pinned. The user should be
     * notified about this and given the opportunity to acknowledge the
     * change, which will make the new identity pinned.
     * When the user acknowledges the change, the app should call
     * [`crate::OtherUserIdentity::pin_current_master_key`].
     */
    IdentityState[IdentityState["PinViolation"] = 2] = "PinViolation";
    /**
     * The user's identity has changed, and before that it was verified. This
     * is a serious problem. The user can either verify again to make this
     * identity verified, or withdraw verification
     * [`UserIdentity::withdraw_verification`] to make it pinned.
     */
    IdentityState[IdentityState["VerificationViolation"] = 3] = "VerificationViolation";
})(IdentityState || (IdentityState = {}));
const FfiConverterTypeIdentityState = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return IdentityState.Verified;
                case 2: return IdentityState.Pinned;
                case 3: return IdentityState.PinViolation;
                case 4: return IdentityState.VerificationViolation;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case IdentityState.Verified: return ordinalConverter.write(1, into);
                case IdentityState.Pinned: return ordinalConverter.write(2, into);
                case IdentityState.PinViolation: return ordinalConverter.write(3, into);
                case IdentityState.VerificationViolation: return ordinalConverter.write(4, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
/**
 * The local trust state of a device.
 */
export var LocalTrust;
(function (LocalTrust) {
    /**
     * The device has been verified and is trusted.
     */
    LocalTrust[LocalTrust["Verified"] = 0] = "Verified";
    /**
     * The device been blacklisted from communicating.
     */
    LocalTrust[LocalTrust["BlackListed"] = 1] = "BlackListed";
    /**
     * The trust state of the device is being ignored.
     */
    LocalTrust[LocalTrust["Ignored"] = 2] = "Ignored";
    /**
     * The trust state is unset.
     */
    LocalTrust[LocalTrust["Unset"] = 3] = "Unset";
})(LocalTrust || (LocalTrust = {}));
const FfiConverterTypeLocalTrust = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return LocalTrust.Verified;
                case 2: return LocalTrust.BlackListed;
                case 3: return LocalTrust.Ignored;
                case 4: return LocalTrust.Unset;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case LocalTrust.Verified: return ordinalConverter.write(1, into);
                case LocalTrust.BlackListed: return ordinalConverter.write(2, into);
                case LocalTrust.Ignored: return ordinalConverter.write(3, into);
                case LocalTrust.Unset: return ordinalConverter.write(4, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Flat error type: LoginQrCodeDecodeError
export var LoginQrCodeDecodeError_Tags;
(function (LoginQrCodeDecodeError_Tags) {
    LoginQrCodeDecodeError_Tags["NotEnoughData"] = "NotEnoughData";
    LoginQrCodeDecodeError_Tags["NotUtf8"] = "NotUtf8";
    LoginQrCodeDecodeError_Tags["UrlParse"] = "UrlParse";
    LoginQrCodeDecodeError_Tags["InvalidMode"] = "InvalidMode";
    LoginQrCodeDecodeError_Tags["InvalidVersion"] = "InvalidVersion";
    LoginQrCodeDecodeError_Tags["Base64"] = "Base64";
    LoginQrCodeDecodeError_Tags["InvalidPrefix"] = "InvalidPrefix";
})(LoginQrCodeDecodeError_Tags || (LoginQrCodeDecodeError_Tags = {}));
/**
 * Error type for the decoding of the [`QrCodeData`].
 */
export const LoginQrCodeDecodeError = (() => {
    /**
     * The QR code data is no long enough, it's missing some fields.
     */
    class NotEnoughData extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "LoginQrCodeDecodeError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 1;
        tag = LoginQrCodeDecodeError_Tags.NotEnoughData;
        constructor(message) {
            super("LoginQrCodeDecodeError", "NotEnoughData", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 1);
        }
    }
    /**
     * One of the URLs in the QR code data is not a valid UTF-8 encoded string.
     */
    class NotUtf8 extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "LoginQrCodeDecodeError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 2;
        tag = LoginQrCodeDecodeError_Tags.NotUtf8;
        constructor(message) {
            super("LoginQrCodeDecodeError", "NotUtf8", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 2);
        }
    }
    /**
     * One of the URLs in the QR code data could not be parsed.
     */
    class UrlParse extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "LoginQrCodeDecodeError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 3;
        tag = LoginQrCodeDecodeError_Tags.UrlParse;
        constructor(message) {
            super("LoginQrCodeDecodeError", "UrlParse", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 3);
        }
    }
    /**
     * The QR code data contains an invalid mode, we expect the login (0x03)
     * mode or the reciprocate mode (0x04).
     */
    class InvalidMode extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "LoginQrCodeDecodeError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 4;
        tag = LoginQrCodeDecodeError_Tags.InvalidMode;
        constructor(message) {
            super("LoginQrCodeDecodeError", "InvalidMode", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 4);
        }
    }
    /**
     * The QR code data contains an unsupported version.
     */
    class InvalidVersion extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "LoginQrCodeDecodeError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 5;
        tag = LoginQrCodeDecodeError_Tags.InvalidVersion;
        constructor(message) {
            super("LoginQrCodeDecodeError", "InvalidVersion", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 5);
        }
    }
    /**
     * The base64 encoded variant of the QR code data is not a valid base64
     * string.
     */
    class Base64 extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "LoginQrCodeDecodeError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 6;
        tag = LoginQrCodeDecodeError_Tags.Base64;
        constructor(message) {
            super("LoginQrCodeDecodeError", "Base64", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 6);
        }
    }
    /**
     * The QR code data doesn't contain the expected `MATRIX` prefix.
     */
    class InvalidPrefix extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "LoginQrCodeDecodeError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 7;
        tag = LoginQrCodeDecodeError_Tags.InvalidPrefix;
        constructor(message) {
            super("LoginQrCodeDecodeError", "InvalidPrefix", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 7);
        }
    }
    // Utility function which does not rely on instanceof.
    function instanceOf(e) {
        return e[uniffiTypeNameSymbol] === "LoginQrCodeDecodeError";
    }
    return {
        NotEnoughData,
        NotUtf8,
        UrlParse,
        InvalidMode,
        InvalidVersion,
        Base64,
        InvalidPrefix,
        instanceOf,
    };
})();
const FfiConverterTypeLoginQrCodeDecodeError = (() => {
    const intConverter = FfiConverterInt32;
    class FfiConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (intConverter.read(from)) {
                case 1: return new LoginQrCodeDecodeError.NotEnoughData(FfiConverterString.read(from));
                case 2: return new LoginQrCodeDecodeError.NotUtf8(FfiConverterString.read(from));
                case 3: return new LoginQrCodeDecodeError.UrlParse(FfiConverterString.read(from));
                case 4: return new LoginQrCodeDecodeError.InvalidMode(FfiConverterString.read(from));
                case 5: return new LoginQrCodeDecodeError.InvalidVersion(FfiConverterString.read(from));
                case 6: return new LoginQrCodeDecodeError.Base64(FfiConverterString.read(from));
                case 7: return new LoginQrCodeDecodeError.InvalidPrefix(FfiConverterString.read(from));
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            const obj = value;
            const index = obj[variantOrdinalSymbol];
            intConverter.write(index, into);
        }
        allocationSize(value) {
            return intConverter.allocationSize(0);
        }
    }
    return new FfiConverter();
})();
/**
 * The result of a signature check.
 */
export var SignatureState;
(function (SignatureState) {
    /**
     * The signature is missing.
     */
    SignatureState[SignatureState["Missing"] = 0] = "Missing";
    /**
     * The signature is invalid.
     */
    SignatureState[SignatureState["Invalid"] = 1] = "Invalid";
    /**
     * The signature is valid but the device or user identity that created the
     * signature is not trusted.
     */
    SignatureState[SignatureState["ValidButNotTrusted"] = 2] = "ValidButNotTrusted";
    /**
     * The signature is valid and the device or user identity that created the
     * signature is trusted.
     */
    SignatureState[SignatureState["ValidAndTrusted"] = 3] = "ValidAndTrusted";
})(SignatureState || (SignatureState = {}));
const FfiConverterTypeSignatureState = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return SignatureState.Missing;
                case 2: return SignatureState.Invalid;
                case 3: return SignatureState.ValidButNotTrusted;
                case 4: return SignatureState.ValidAndTrusted;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case SignatureState.Missing: return ordinalConverter.write(1, into);
                case SignatureState.Invalid: return ordinalConverter.write(2, into);
                case SignatureState.ValidButNotTrusted: return ordinalConverter.write(3, into);
                case SignatureState.ValidAndTrusted: return ordinalConverter.write(4, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
/**
 * The trust level in the sender's device that is required to decrypt an
 * event.
 */
export var TrustRequirement;
(function (TrustRequirement) {
    /**
     * Decrypt events from everyone regardless of trust.
     */
    TrustRequirement[TrustRequirement["Untrusted"] = 0] = "Untrusted";
    /**
     * Only decrypt events from cross-signed devices or legacy sessions (Megolm
     * sessions created before we started collecting trust information).
     */
    TrustRequirement[TrustRequirement["CrossSignedOrLegacy"] = 1] = "CrossSignedOrLegacy";
    /**
     * Only decrypt events from cross-signed devices.
     */
    TrustRequirement[TrustRequirement["CrossSigned"] = 2] = "CrossSigned";
})(TrustRequirement || (TrustRequirement = {}));
const FfiConverterTypeTrustRequirement = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return TrustRequirement.Untrusted;
                case 2: return TrustRequirement.CrossSignedOrLegacy;
                case 3: return TrustRequirement.CrossSigned;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case TrustRequirement.Untrusted: return ordinalConverter.write(1, into);
                case TrustRequirement.CrossSignedOrLegacy: return ordinalConverter.write(2, into);
                case TrustRequirement.CrossSigned: return ordinalConverter.write(3, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
/**
 * Our best guess at the reason why an event can't be decrypted.
 */
export var UtdCause;
(function (UtdCause) {
    /**
     * We don't have an explanation for why this UTD happened - it is probably
     * a bug, or a network split between the two homeservers.
     *
     * For example:
     *
     * - the keys for this event are missing, but a key storage backup exists
     * and is working, so we should be able to find the keys in the backup.
     *
     * - the keys for this event are missing, and a key storage backup exists
     * on the server, but that backup is not working on this client even
     * though this device is verified.
     */
    UtdCause[UtdCause["Unknown"] = 0] = "Unknown";
    /**
     * We are missing the keys for this event, and the event was sent when we
     * were not a member of the room (or invited).
     */
    UtdCause[UtdCause["SentBeforeWeJoined"] = 1] = "SentBeforeWeJoined";
    /**
     * The message was sent by a user identity we have not verified, but the
     * user was previously verified.
     */
    UtdCause[UtdCause["VerificationViolation"] = 2] = "VerificationViolation";
    /**
     * The [`crate::TrustRequirement`] requires that the sending device be
     * signed by its owner, and it was not.
     */
    UtdCause[UtdCause["UnsignedDevice"] = 3] = "UnsignedDevice";
    /**
     * The [`crate::TrustRequirement`] requires that the sending device be
     * signed by its owner, and we were unable to securely find the device.
     *
     * This could be because the device has since been deleted, because we
     * haven't yet downloaded it from the server, or because the session
     * data was obtained from an insecure source (imported from a file,
     * obtained from a legacy (asymmetric) backup, unsafe key forward, etc.)
     */
    UtdCause[UtdCause["UnknownDevice"] = 4] = "UnknownDevice";
    /**
     * We are missing the keys for this event, but it is a "device-historical"
     * message and there is no key storage backup on the server, presumably
     * because the user has turned it off.
     *
     * Device-historical means that the message was sent before the current
     * device existed (but the current user was probably a member of the room
     * at the time the message was sent). Not to
     * be confused with pre-join or pre-invite messages (see
     * [`UtdCause::SentBeforeWeJoined`] for that).
     *
     * Expected message to user: "History is not available on this device".
     */
    UtdCause[UtdCause["HistoricalMessageAndBackupIsDisabled"] = 5] = "HistoricalMessageAndBackupIsDisabled";
    /**
     * The keys for this event are intentionally withheld.
     *
     * The sender has refused to share the key because our device does not meet
     * the sender's security requirements.
     */
    UtdCause[UtdCause["WithheldForUnverifiedOrInsecureDevice"] = 6] = "WithheldForUnverifiedOrInsecureDevice";
    /**
     * The keys for this event are missing, likely because the sender was
     * unable to share them (e.g., failure to establish an Olm 1:1
     * channel). Alternatively, the sender may have deliberately excluded
     * this device by cherry-picking and blocking it, in which case, no action
     * can be taken on our side.
     */
    UtdCause[UtdCause["WithheldBySender"] = 7] = "WithheldBySender";
    /**
     * We are missing the keys for this event, but it is a "device-historical"
     * message, and even though a key storage backup does exist, we can't use
     * it because our device is unverified.
     *
     * Device-historical means that the message was sent before the current
     * device existed (but the current user was probably a member of the room
     * at the time the message was sent). Not to
     * be confused with pre-join or pre-invite messages (see
     * [`UtdCause::SentBeforeWeJoined`] for that).
     *
     * Expected message to user: "You need to verify this device".
     */
    UtdCause[UtdCause["HistoricalMessageAndDeviceIsUnverified"] = 8] = "HistoricalMessageAndDeviceIsUnverified";
})(UtdCause || (UtdCause = {}));
const FfiConverterTypeUtdCause = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return UtdCause.Unknown;
                case 2: return UtdCause.SentBeforeWeJoined;
                case 3: return UtdCause.VerificationViolation;
                case 4: return UtdCause.UnsignedDevice;
                case 5: return UtdCause.UnknownDevice;
                case 6: return UtdCause.HistoricalMessageAndBackupIsDisabled;
                case 7: return UtdCause.WithheldForUnverifiedOrInsecureDevice;
                case 8: return UtdCause.WithheldBySender;
                case 9: return UtdCause.HistoricalMessageAndDeviceIsUnverified;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case UtdCause.Unknown: return ordinalConverter.write(1, into);
                case UtdCause.SentBeforeWeJoined: return ordinalConverter.write(2, into);
                case UtdCause.VerificationViolation: return ordinalConverter.write(3, into);
                case UtdCause.UnsignedDevice: return ordinalConverter.write(4, into);
                case UtdCause.UnknownDevice: return ordinalConverter.write(5, into);
                case UtdCause.HistoricalMessageAndBackupIsDisabled: return ordinalConverter.write(6, into);
                case UtdCause.WithheldForUnverifiedOrInsecureDevice: return ordinalConverter.write(7, into);
                case UtdCause.WithheldBySender: return ordinalConverter.write(8, into);
                case UtdCause.HistoricalMessageAndDeviceIsUnverified: return ordinalConverter.write(9, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
    // Get the bindings contract version from our ComponentInterface
    const bindingsContractVersion = 29;
    // Get the scaffolding contract version by calling the into the dylib
    const scaffoldingContractVersion = nativeModule().ubrn_ffi_matrix_sdk_crypto_uniffi_contract_version();
    if (bindingsContractVersion !== scaffoldingContractVersion) {
        throw new UniffiInternalError.ContractVersionMismatch(scaffoldingContractVersion, bindingsContractVersion);
    }
}
export default Object.freeze({
    initialize: uniffiEnsureInitialized,
    converters: {
        FfiConverterTypeCollectStrategy,
        FfiConverterTypeDecryptionSettings,
        FfiConverterTypeIdentityState,
        FfiConverterTypeLocalTrust,
        FfiConverterTypeLoginQrCodeDecodeError,
        FfiConverterTypeSignatureState,
        FfiConverterTypeTrustRequirement,
        FfiConverterTypeUtdCause,
    }
});
