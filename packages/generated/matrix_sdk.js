// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
import * as wasmBundle from "./wasm-bindgen/index.js";
import { AbstractFfiConverterByteArray, FfiConverterBool, FfiConverterFloat64, FfiConverterInt32, FfiConverterInt64, FfiConverterObject, FfiConverterOptional, UniffiAbstractObject, UniffiEnum, UniffiError, UniffiInternalError, UniffiRustCaller, destructorGuardSymbol, pointerLiteralSymbol, uniffiCreateFfiConverterString, uniffiCreateRecord, uniffiTypeNameSymbol, variantOrdinalSymbol } from "uniffi-bindgen-react-native";
// Get converters from the other files, if any.
const nativeModule = () => wasmBundle;
const uniffiCaller = new UniffiRustCaller(() => new wasmBundle.RustCallStatus());
const uniffiIsDebug = 
// @ts-ignore -- The process global might not be defined
typeof process !== "object" ||
    // @ts-ignore -- The process global might not be defined
    process?.env?.NODE_ENV !== "production" ||
    false;
/**
 * Generated factory for {@link RoomPowerLevelChanges} record objects.
 */
export const RoomPowerLevelChanges = (() => {
    const defaults = () => ({ ban: undefined, invite: undefined, kick: undefined, redact: undefined, eventsDefault: undefined, stateDefault: undefined, usersDefault: undefined, roomName: undefined, roomAvatar: undefined, roomTopic: undefined, spaceChild: undefined
    });
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link RoomPowerLevelChanges}, with defaults specified
         * in Rust, in the {@link matrix_sdk} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link RoomPowerLevelChanges}, with defaults specified
         * in Rust, in the {@link matrix_sdk} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeRoomPowerLevelChanges = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                ban: FfiConverterOptionalInt64.read(from),
                invite: FfiConverterOptionalInt64.read(from),
                kick: FfiConverterOptionalInt64.read(from),
                redact: FfiConverterOptionalInt64.read(from),
                eventsDefault: FfiConverterOptionalInt64.read(from),
                stateDefault: FfiConverterOptionalInt64.read(from),
                usersDefault: FfiConverterOptionalInt64.read(from),
                roomName: FfiConverterOptionalInt64.read(from),
                roomAvatar: FfiConverterOptionalInt64.read(from),
                roomTopic: FfiConverterOptionalInt64.read(from),
                spaceChild: FfiConverterOptionalInt64.read(from)
            };
        }
        write(value, into) {
            FfiConverterOptionalInt64.write(value.ban, into);
            FfiConverterOptionalInt64.write(value.invite, into);
            FfiConverterOptionalInt64.write(value.kick, into);
            FfiConverterOptionalInt64.write(value.redact, into);
            FfiConverterOptionalInt64.write(value.eventsDefault, into);
            FfiConverterOptionalInt64.write(value.stateDefault, into);
            FfiConverterOptionalInt64.write(value.usersDefault, into);
            FfiConverterOptionalInt64.write(value.roomName, into);
            FfiConverterOptionalInt64.write(value.roomAvatar, into);
            FfiConverterOptionalInt64.write(value.roomTopic, into);
            FfiConverterOptionalInt64.write(value.spaceChild, into);
        }
        allocationSize(value) {
            return FfiConverterOptionalInt64.allocationSize(value.ban) +
                FfiConverterOptionalInt64.allocationSize(value.invite) +
                FfiConverterOptionalInt64.allocationSize(value.kick) +
                FfiConverterOptionalInt64.allocationSize(value.redact) +
                FfiConverterOptionalInt64.allocationSize(value.eventsDefault) +
                FfiConverterOptionalInt64.allocationSize(value.stateDefault) +
                FfiConverterOptionalInt64.allocationSize(value.usersDefault) +
                FfiConverterOptionalInt64.allocationSize(value.roomName) +
                FfiConverterOptionalInt64.allocationSize(value.roomAvatar) +
                FfiConverterOptionalInt64.allocationSize(value.roomTopic) +
                FfiConverterOptionalInt64.allocationSize(value.spaceChild);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link ServerVendorInfo} record objects.
 */
export const ServerVendorInfo = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link ServerVendorInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link ServerVendorInfo}, with defaults specified
         * in Rust, in the {@link matrix_sdk} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeServerVendorInfo = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                serverName: FfiConverterString.read(from),
                version: FfiConverterString.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.serverName, into);
            FfiConverterString.write(value.version, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.serverName) +
                FfiConverterString.allocationSize(value.version);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link VirtualElementCallWidgetConfig} record objects.
 */
export const VirtualElementCallWidgetConfig = (() => {
    const defaults = () => ({ skipLobby: undefined, header: undefined, hideHeader: undefined, preload: undefined, appPrompt: undefined, confineToRoom: undefined, hideScreensharing: undefined, controlledAudioDevices: undefined, sendNotificationType: undefined
    });
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link VirtualElementCallWidgetConfig}, with defaults specified
         * in Rust, in the {@link matrix_sdk} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link VirtualElementCallWidgetConfig}, with defaults specified
         * in Rust, in the {@link matrix_sdk} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeVirtualElementCallWidgetConfig = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                intent: FfiConverterOptionalTypeIntent.read(from),
                skipLobby: FfiConverterOptionalBool.read(from),
                header: FfiConverterOptionalTypeHeaderStyle.read(from),
                hideHeader: FfiConverterOptionalBool.read(from),
                preload: FfiConverterOptionalBool.read(from),
                appPrompt: FfiConverterOptionalBool.read(from),
                confineToRoom: FfiConverterOptionalBool.read(from),
                hideScreensharing: FfiConverterOptionalBool.read(from),
                controlledAudioDevices: FfiConverterOptionalBool.read(from),
                sendNotificationType: FfiConverterOptionalTypeNotificationType.read(from)
            };
        }
        write(value, into) {
            FfiConverterOptionalTypeIntent.write(value.intent, into);
            FfiConverterOptionalBool.write(value.skipLobby, into);
            FfiConverterOptionalTypeHeaderStyle.write(value.header, into);
            FfiConverterOptionalBool.write(value.hideHeader, into);
            FfiConverterOptionalBool.write(value.preload, into);
            FfiConverterOptionalBool.write(value.appPrompt, into);
            FfiConverterOptionalBool.write(value.confineToRoom, into);
            FfiConverterOptionalBool.write(value.hideScreensharing, into);
            FfiConverterOptionalBool.write(value.controlledAudioDevices, into);
            FfiConverterOptionalTypeNotificationType.write(value.sendNotificationType, into);
        }
        allocationSize(value) {
            return FfiConverterOptionalTypeIntent.allocationSize(value.intent) +
                FfiConverterOptionalBool.allocationSize(value.skipLobby) +
                FfiConverterOptionalTypeHeaderStyle.allocationSize(value.header) +
                FfiConverterOptionalBool.allocationSize(value.hideHeader) +
                FfiConverterOptionalBool.allocationSize(value.preload) +
                FfiConverterOptionalBool.allocationSize(value.appPrompt) +
                FfiConverterOptionalBool.allocationSize(value.confineToRoom) +
                FfiConverterOptionalBool.allocationSize(value.hideScreensharing) +
                FfiConverterOptionalBool.allocationSize(value.controlledAudioDevices) +
                FfiConverterOptionalTypeNotificationType.allocationSize(value.sendNotificationType);
        }
    }
    ;
    return new FFIConverter();
})();
/**
 * Generated factory for {@link VirtualElementCallWidgetProperties} record objects.
 */
export const VirtualElementCallWidgetProperties = (() => {
    const defaults = () => ({ parentUrl: undefined, fontScale: undefined, font: undefined, posthogUserId: undefined, posthogApiHost: undefined, posthogApiKey: undefined, rageshakeSubmitUrl: undefined, sentryDsn: undefined, sentryEnvironment: undefined
    });
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link VirtualElementCallWidgetProperties}, with defaults specified
         * in Rust, in the {@link matrix_sdk} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link VirtualElementCallWidgetProperties}, with defaults specified
         * in Rust, in the {@link matrix_sdk} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeVirtualElementCallWidgetProperties = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                elementCallUrl: FfiConverterString.read(from),
                widgetId: FfiConverterString.read(from),
                parentUrl: FfiConverterOptionalString.read(from),
                fontScale: FfiConverterOptionalFloat64.read(from),
                font: FfiConverterOptionalString.read(from),
                encryption: FfiConverterTypeEncryptionSystem.read(from),
                posthogUserId: FfiConverterOptionalString.read(from),
                posthogApiHost: FfiConverterOptionalString.read(from),
                posthogApiKey: FfiConverterOptionalString.read(from),
                rageshakeSubmitUrl: FfiConverterOptionalString.read(from),
                sentryDsn: FfiConverterOptionalString.read(from),
                sentryEnvironment: FfiConverterOptionalString.read(from)
            };
        }
        write(value, into) {
            FfiConverterString.write(value.elementCallUrl, into);
            FfiConverterString.write(value.widgetId, into);
            FfiConverterOptionalString.write(value.parentUrl, into);
            FfiConverterOptionalFloat64.write(value.fontScale, into);
            FfiConverterOptionalString.write(value.font, into);
            FfiConverterTypeEncryptionSystem.write(value.encryption, into);
            FfiConverterOptionalString.write(value.posthogUserId, into);
            FfiConverterOptionalString.write(value.posthogApiHost, into);
            FfiConverterOptionalString.write(value.posthogApiKey, into);
            FfiConverterOptionalString.write(value.rageshakeSubmitUrl, into);
            FfiConverterOptionalString.write(value.sentryDsn, into);
            FfiConverterOptionalString.write(value.sentryEnvironment, into);
        }
        allocationSize(value) {
            return FfiConverterString.allocationSize(value.elementCallUrl) +
                FfiConverterString.allocationSize(value.widgetId) +
                FfiConverterOptionalString.allocationSize(value.parentUrl) +
                FfiConverterOptionalFloat64.allocationSize(value.fontScale) +
                FfiConverterOptionalString.allocationSize(value.font) +
                FfiConverterTypeEncryptionSystem.allocationSize(value.encryption) +
                FfiConverterOptionalString.allocationSize(value.posthogUserId) +
                FfiConverterOptionalString.allocationSize(value.posthogApiHost) +
                FfiConverterOptionalString.allocationSize(value.posthogApiKey) +
                FfiConverterOptionalString.allocationSize(value.rageshakeSubmitUrl) +
                FfiConverterOptionalString.allocationSize(value.sentryDsn) +
                FfiConverterOptionalString.allocationSize(value.sentryEnvironment);
        }
    }
    ;
    return new FFIConverter();
})();
const stringConverter = (() => {
    const encoder = new TextEncoder();
    const decoder = new TextDecoder();
    return {
        stringToBytes: (s) => encoder.encode(s),
        bytesToString: (ab) => decoder.decode(ab),
        stringByteLength: (s) => encoder.encode(s).byteLength,
    };
})();
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);
/**
 * Settings for end-to-end encryption features.
 */
export var BackupDownloadStrategy;
(function (BackupDownloadStrategy) {
    /**
     * Automatically download all room keys from the backup when the backup
     * recovery key has been received. The backup recovery key can be received
     * in two ways:
     *
     * 1. Received as a `m.secret.send` to-device event, after a successful
     * interactive verification.
     * 2. Imported from secret storage (4S) using the
     * [`SecretStore::import_secrets()`] method.
     *
     * [`SecretStore::import_secrets()`]: crate::encryption::secret_storage::SecretStore::import_secrets
     */
    BackupDownloadStrategy[BackupDownloadStrategy["OneShot"] = 0] = "OneShot";
    /**
     * Attempt to download a single room key if an event fails to be decrypted.
     */
    BackupDownloadStrategy[BackupDownloadStrategy["AfterDecryptionFailure"] = 1] = "AfterDecryptionFailure";
    /**
     * Don't download any room keys automatically. The user can manually
     * download room keys using the [`Backups::download_room_key()`] methods.
     *
     * This is the default option.
     */
    BackupDownloadStrategy[BackupDownloadStrategy["Manual"] = 2] = "Manual";
})(BackupDownloadStrategy || (BackupDownloadStrategy = {}));
const FfiConverterTypeBackupDownloadStrategy = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return BackupDownloadStrategy.OneShot;
                case 2: return BackupDownloadStrategy.AfterDecryptionFailure;
                case 3: return BackupDownloadStrategy.Manual;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case BackupDownloadStrategy.OneShot: return ordinalConverter.write(1, into);
                case BackupDownloadStrategy.AfterDecryptionFailure: return ordinalConverter.write(2, into);
                case BackupDownloadStrategy.Manual: return ordinalConverter.write(3, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Enum: EncryptionSystem
export var EncryptionSystem_Tags;
(function (EncryptionSystem_Tags) {
    EncryptionSystem_Tags["Unencrypted"] = "Unencrypted";
    EncryptionSystem_Tags["PerParticipantKeys"] = "PerParticipantKeys";
    EncryptionSystem_Tags["SharedSecret"] = "SharedSecret";
})(EncryptionSystem_Tags || (EncryptionSystem_Tags = {}));
/**
 * Defines if a call is encrypted and which encryption system should be used.
 *
 * This controls the url parameters: `perParticipantE2EE`, `password`.
 */
export const EncryptionSystem = (() => {
    /**
     * Equivalent to the element call url parameter: `perParticipantE2EE=false`
     * and no password.
     */
    class Unencrypted_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "EncryptionSystem";
        tag = EncryptionSystem_Tags.Unencrypted;
        constructor() {
            super("EncryptionSystem", "Unencrypted");
        }
        static new() {
            return new Unencrypted_();
        }
        static instanceOf(obj) {
            return obj.tag === EncryptionSystem_Tags.Unencrypted;
        }
    }
    /**
     * Equivalent to the element call url parameters:
     * `perParticipantE2EE=true`
     */
    class PerParticipantKeys_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "EncryptionSystem";
        tag = EncryptionSystem_Tags.PerParticipantKeys;
        constructor() {
            super("EncryptionSystem", "PerParticipantKeys");
        }
        static new() {
            return new PerParticipantKeys_();
        }
        static instanceOf(obj) {
            return obj.tag === EncryptionSystem_Tags.PerParticipantKeys;
        }
    }
    /**
     * Equivalent to the element call url parameters:
     * `password={secret}`
     */
    class SharedSecret_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "EncryptionSystem";
        tag = EncryptionSystem_Tags.SharedSecret;
        inner;
        constructor(inner) {
            super("EncryptionSystem", "SharedSecret");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new SharedSecret_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === EncryptionSystem_Tags.SharedSecret;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "EncryptionSystem";
    }
    return Object.freeze({
        instanceOf,
        Unencrypted: Unencrypted_,
        PerParticipantKeys: PerParticipantKeys_,
        SharedSecret: SharedSecret_
    });
})();
// FfiConverter for enum EncryptionSystem
const FfiConverterTypeEncryptionSystem = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new EncryptionSystem.Unencrypted();
                case 2: return new EncryptionSystem.PerParticipantKeys();
                case 3: return new EncryptionSystem.SharedSecret({ secret: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case EncryptionSystem_Tags.Unencrypted: {
                    ordinalConverter.write(1, into);
                    return;
                }
                case EncryptionSystem_Tags.PerParticipantKeys: {
                    ordinalConverter.write(2, into);
                    return;
                }
                case EncryptionSystem_Tags.SharedSecret: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.secret, into);
                    return;
                }
                default:
                    // Throwing from here means that EncryptionSystem_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case EncryptionSystem_Tags.Unencrypted: {
                    return ordinalConverter.allocationSize(1);
                }
                case EncryptionSystem_Tags.PerParticipantKeys: {
                    return ordinalConverter.allocationSize(2);
                }
                case EncryptionSystem_Tags.SharedSecret: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterString.allocationSize(inner.secret);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
/**
 * Defines how (if) element-call renders a header.
 */
export var HeaderStyle;
(function (HeaderStyle) {
    /**
     * The normal header with branding.
     */
    HeaderStyle[HeaderStyle["Standard"] = 0] = "Standard";
    /**
     * Render a header with a back button (useful on mobile platforms).
     */
    HeaderStyle[HeaderStyle["AppBar"] = 1] = "AppBar";
    /**
     * No Header (useful for webapps).
     */
    HeaderStyle[HeaderStyle["None"] = 2] = "None";
})(HeaderStyle || (HeaderStyle = {}));
const FfiConverterTypeHeaderStyle = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return HeaderStyle.Standard;
                case 2: return HeaderStyle.AppBar;
                case 3: return HeaderStyle.None;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case HeaderStyle.Standard: return ordinalConverter.write(1, into);
                case HeaderStyle.AppBar: return ordinalConverter.write(2, into);
                case HeaderStyle.None: return ordinalConverter.write(3, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
/**
 * Defines the intent of showing the call.
 *
 * This controls whether to show or skip the lobby.
 */
export var Intent;
(function (Intent) {
    /**
     * The user wants to start a call.
     */
    Intent[Intent["StartCall"] = 0] = "StartCall";
    /**
     * The user wants to join an existing call.
     */
    Intent[Intent["JoinExisting"] = 1] = "JoinExisting";
    /**
     * The user wants to join an existing call that is a "Direct Message" (DM)
     * room.
     */
    Intent[Intent["JoinExistingDm"] = 2] = "JoinExistingDm";
    /**
     * The user wants to start a call in a "Direct Message" (DM) room.
     */
    Intent[Intent["StartCallDm"] = 3] = "StartCallDm";
})(Intent || (Intent = {}));
const FfiConverterTypeIntent = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return Intent.StartCall;
                case 2: return Intent.JoinExisting;
                case 3: return Intent.JoinExistingDm;
                case 4: return Intent.StartCallDm;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case Intent.StartCall: return ordinalConverter.write(1, into);
                case Intent.JoinExisting: return ordinalConverter.write(2, into);
                case Intent.JoinExistingDm: return ordinalConverter.write(3, into);
                case Intent.StartCallDm: return ordinalConverter.write(4, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
/**
 * Types of call notifications.
 */
export var NotificationType;
(function (NotificationType) {
    /**
     * The receiving client should display a visual notification.
     */
    NotificationType[NotificationType["Notification"] = 0] = "Notification";
    /**
     * The receiving client should ring with an audible sound.
     */
    NotificationType[NotificationType["Ring"] = 1] = "Ring";
})(NotificationType || (NotificationType = {}));
const FfiConverterTypeNotificationType = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return NotificationType.Notification;
                case 2: return NotificationType.Ring;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case NotificationType.Notification: return ordinalConverter.write(1, into);
                case NotificationType.Ring: return ordinalConverter.write(2, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
/**
 * Current state of a [`Paginator`].
 */
export var PaginatorState;
(function (PaginatorState) {
    /**
     * The initial state of the paginator.
     */
    PaginatorState[PaginatorState["Initial"] = 0] = "Initial";
    /**
     * The paginator is fetching the target initial event.
     */
    PaginatorState[PaginatorState["FetchingTargetEvent"] = 1] = "FetchingTargetEvent";
    /**
     * The target initial event could be found, zero or more paginations have
     * happened since then, and the paginator is at rest now.
     */
    PaginatorState[PaginatorState["Idle"] = 2] = "Idle";
    /**
     * The paginator isâ€¦ paginating one direction or another.
     */
    PaginatorState[PaginatorState["Paginating"] = 3] = "Paginating";
})(PaginatorState || (PaginatorState = {}));
const FfiConverterTypePaginatorState = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return PaginatorState.Initial;
                case 2: return PaginatorState.FetchingTargetEvent;
                case 3: return PaginatorState.Idle;
                case 4: return PaginatorState.Paginating;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case PaginatorState.Initial: return ordinalConverter.write(1, into);
                case PaginatorState.FetchingTargetEvent: return ordinalConverter.write(2, into);
                case PaginatorState.Idle: return ordinalConverter.write(3, into);
                case PaginatorState.Paginating: return ordinalConverter.write(4, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Flat error type: QrCodeLoginError
export var QrCodeLoginError_Tags;
(function (QrCodeLoginError_Tags) {
    QrCodeLoginError_Tags["OAuth"] = "OAuth";
    QrCodeLoginError_Tags["LoginFailure"] = "LoginFailure";
    QrCodeLoginError_Tags["UnexpectedMessage"] = "UnexpectedMessage";
    QrCodeLoginError_Tags["SecureChannel"] = "SecureChannel";
    QrCodeLoginError_Tags["NotFound"] = "NotFound";
    QrCodeLoginError_Tags["CrossProcessRefreshLock"] = "CrossProcessRefreshLock";
    QrCodeLoginError_Tags["UserIdDiscovery"] = "UserIdDiscovery";
    QrCodeLoginError_Tags["SessionTokens"] = "SessionTokens";
    QrCodeLoginError_Tags["DeviceKeyUpload"] = "DeviceKeyUpload";
    QrCodeLoginError_Tags["SecretImport"] = "SecretImport";
    QrCodeLoginError_Tags["ServerReset"] = "ServerReset";
})(QrCodeLoginError_Tags || (QrCodeLoginError_Tags = {}));
/**
 * The error type for failures while trying to log in a new device using a QR
 * code.
 */
export const QrCodeLoginError = (() => {
    /**
     * An error happened while we were communicating with the OAuth 2.0
     * authorization server.
     */
    class OAuth extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "QrCodeLoginError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 1;
        tag = QrCodeLoginError_Tags.OAuth;
        constructor(message) {
            super("QrCodeLoginError", "OAuth", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 1);
        }
    }
    /**
     * The other device has signaled to us that the login has failed.
     */
    class LoginFailure extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "QrCodeLoginError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 2;
        tag = QrCodeLoginError_Tags.LoginFailure;
        constructor(message) {
            super("QrCodeLoginError", "LoginFailure", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 2);
        }
    }
    /**
     * An unexpected message was received from the other device.
     */
    class UnexpectedMessage extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "QrCodeLoginError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 3;
        tag = QrCodeLoginError_Tags.UnexpectedMessage;
        constructor(message) {
            super("QrCodeLoginError", "UnexpectedMessage", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 3);
        }
    }
    /**
     * An error happened while exchanging messages with the other device.
     */
    class SecureChannel extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "QrCodeLoginError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 4;
        tag = QrCodeLoginError_Tags.SecureChannel;
        constructor(message) {
            super("QrCodeLoginError", "SecureChannel", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 4);
        }
    }
    /**
     * The rendezvous session was not found and might have expired.
     */
    class NotFound extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "QrCodeLoginError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 5;
        tag = QrCodeLoginError_Tags.NotFound;
        constructor(message) {
            super("QrCodeLoginError", "NotFound", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 5);
        }
    }
    /**
     * The cross-process refresh lock failed to be initialized.
     */
    class CrossProcessRefreshLock extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "QrCodeLoginError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 6;
        tag = QrCodeLoginError_Tags.CrossProcessRefreshLock;
        constructor(message) {
            super("QrCodeLoginError", "CrossProcessRefreshLock", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 6);
        }
    }
    /**
     * An error happened while we were trying to discover our user and device
     * ID, after we have acquired an access token from the OAuth 2.0
     * authorization server.
     */
    class UserIdDiscovery extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "QrCodeLoginError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 7;
        tag = QrCodeLoginError_Tags.UserIdDiscovery;
        constructor(message) {
            super("QrCodeLoginError", "UserIdDiscovery", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 7);
        }
    }
    /**
     * We failed to set the session tokens after we figured out our device and
     * user IDs.
     */
    class SessionTokens extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "QrCodeLoginError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 8;
        tag = QrCodeLoginError_Tags.SessionTokens;
        constructor(message) {
            super("QrCodeLoginError", "SessionTokens", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 8);
        }
    }
    /**
     * The device keys failed to be uploaded after we successfully logged in.
     */
    class DeviceKeyUpload extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "QrCodeLoginError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 9;
        tag = QrCodeLoginError_Tags.DeviceKeyUpload;
        constructor(message) {
            super("QrCodeLoginError", "DeviceKeyUpload", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 9);
        }
    }
    /**
     * The secrets bundle we received from the existing device failed to be
     * imported.
     */
    class SecretImport extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "QrCodeLoginError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 10;
        tag = QrCodeLoginError_Tags.SecretImport;
        constructor(message) {
            super("QrCodeLoginError", "SecretImport", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 10);
        }
    }
    /**
     * The other party told us to use a different homeserver but we failed to
     * reset the server URL.
     */
    class ServerReset extends UniffiError {
        /**
         * @private
         * This field is private and should not be used.
         */
        [uniffiTypeNameSymbol] = "QrCodeLoginError";
        /**
         * @private
         * This field is private and should not be used.
         */
        [variantOrdinalSymbol] = 11;
        tag = QrCodeLoginError_Tags.ServerReset;
        constructor(message) {
            super("QrCodeLoginError", "ServerReset", message);
        }
        static instanceOf(e) {
            return (instanceOf(e) && e[variantOrdinalSymbol] === 11);
        }
    }
    // Utility function which does not rely on instanceof.
    function instanceOf(e) {
        return e[uniffiTypeNameSymbol] === "QrCodeLoginError";
    }
    return {
        OAuth,
        LoginFailure,
        UnexpectedMessage,
        SecureChannel,
        NotFound,
        CrossProcessRefreshLock,
        UserIdDiscovery,
        SessionTokens,
        DeviceKeyUpload,
        SecretImport,
        ServerReset,
        instanceOf,
    };
})();
const FfiConverterTypeQRCodeLoginError = (() => {
    const intConverter = FfiConverterInt32;
    class FfiConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (intConverter.read(from)) {
                case 1: return new QrCodeLoginError.OAuth(FfiConverterString.read(from));
                case 2: return new QrCodeLoginError.LoginFailure(FfiConverterString.read(from));
                case 3: return new QrCodeLoginError.UnexpectedMessage(FfiConverterString.read(from));
                case 4: return new QrCodeLoginError.SecureChannel(FfiConverterString.read(from));
                case 5: return new QrCodeLoginError.NotFound(FfiConverterString.read(from));
                case 6: return new QrCodeLoginError.CrossProcessRefreshLock(FfiConverterString.read(from));
                case 7: return new QrCodeLoginError.UserIdDiscovery(FfiConverterString.read(from));
                case 8: return new QrCodeLoginError.SessionTokens(FfiConverterString.read(from));
                case 9: return new QrCodeLoginError.DeviceKeyUpload(FfiConverterString.read(from));
                case 10: return new QrCodeLoginError.SecretImport(FfiConverterString.read(from));
                case 11: return new QrCodeLoginError.ServerReset(FfiConverterString.read(from));
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            const obj = value;
            const index = obj[variantOrdinalSymbol];
            intConverter.write(index, into);
        }
        allocationSize(value) {
            return intConverter.allocationSize(0);
        }
    }
    return new FfiConverter();
})();
/**
 * The role of a member in a room.
 */
export var RoomMemberRole;
(function (RoomMemberRole) {
    /**
     * The member is a creator.
     *
     * A creator has an infinite power level and cannot be demoted, so this
     * role is immutable. A room can have several creators.
     *
     * It is available in room versions where
     * `explicitly_privilege_room_creators` in [`AuthorizationRules`] is set to
     * `true`.
     *
     * [`AuthorizationRules`]: ruma::room_version_rules::AuthorizationRules
     */
    RoomMemberRole[RoomMemberRole["Creator"] = 0] = "Creator";
    /**
     * The member is an administrator.
     */
    RoomMemberRole[RoomMemberRole["Administrator"] = 1] = "Administrator";
    /**
     * The member is a moderator.
     */
    RoomMemberRole[RoomMemberRole["Moderator"] = 2] = "Moderator";
    /**
     * The member is a regular user.
     */
    RoomMemberRole[RoomMemberRole["User"] = 3] = "User";
})(RoomMemberRole || (RoomMemberRole = {}));
const FfiConverterTypeRoomMemberRole = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return RoomMemberRole.Creator;
                case 2: return RoomMemberRole.Administrator;
                case 3: return RoomMemberRole.Moderator;
                case 4: return RoomMemberRole.User;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case RoomMemberRole.Creator: return ordinalConverter.write(1, into);
                case RoomMemberRole.Administrator: return ordinalConverter.write(2, into);
                case RoomMemberRole.Moderator: return ordinalConverter.write(3, into);
                case RoomMemberRole.User: return ordinalConverter.write(4, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// Enum: RoomPaginationStatus
export var RoomPaginationStatus_Tags;
(function (RoomPaginationStatus_Tags) {
    RoomPaginationStatus_Tags["Idle"] = "Idle";
    RoomPaginationStatus_Tags["Paginating"] = "Paginating";
})(RoomPaginationStatus_Tags || (RoomPaginationStatus_Tags = {}));
/**
 * Status for the back-pagination on a room event cache.
 */
export const RoomPaginationStatus = (() => {
    /**
     * No back-pagination is happening right now.
     */
    class Idle_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomPaginationStatus";
        tag = RoomPaginationStatus_Tags.Idle;
        inner;
        constructor(inner) {
            super("RoomPaginationStatus", "Idle");
            this.inner = Object.freeze(inner);
        }
        static new(inner) {
            return new Idle_(inner);
        }
        static instanceOf(obj) {
            return obj.tag === RoomPaginationStatus_Tags.Idle;
        }
    }
    /**
     * Back-pagination is already running in the background.
     */
    class Paginating_ extends UniffiEnum {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        [uniffiTypeNameSymbol] = "RoomPaginationStatus";
        tag = RoomPaginationStatus_Tags.Paginating;
        constructor() {
            super("RoomPaginationStatus", "Paginating");
        }
        static new() {
            return new Paginating_();
        }
        static instanceOf(obj) {
            return obj.tag === RoomPaginationStatus_Tags.Paginating;
        }
    }
    function instanceOf(obj) {
        return obj[uniffiTypeNameSymbol] === "RoomPaginationStatus";
    }
    return Object.freeze({
        instanceOf,
        Idle: Idle_,
        Paginating: Paginating_
    });
})();
// FfiConverter for enum RoomPaginationStatus
const FfiConverterTypeRoomPaginationStatus = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return new RoomPaginationStatus.Idle({ hitTimelineStart: FfiConverterBool.read(from) });
                case 2: return new RoomPaginationStatus.Paginating();
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value.tag) {
                case RoomPaginationStatus_Tags.Idle: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterBool.write(inner.hitTimelineStart, into);
                    return;
                }
                case RoomPaginationStatus_Tags.Paginating: {
                    ordinalConverter.write(2, into);
                    return;
                }
                default:
                    // Throwing from here means that RoomPaginationStatus_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value) {
            switch (value.tag) {
                case RoomPaginationStatus_Tags.Idle: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterBool.allocationSize(inner.hitTimelineStart);
                    return size;
                }
                case RoomPaginationStatus_Tags.Paginating: {
                    return ordinalConverter.allocationSize(2);
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();
/**
 * The data needed to perform authorization using OAuth 2.0.
 */
export class OAuthAuthorizationData extends UniffiAbstractObject {
    [uniffiTypeNameSymbol] = "OAuthAuthorizationData";
    [destructorGuardSymbol];
    [pointerLiteralSymbol];
    // No primary constructor declared for this class.
    constructor(pointer) {
        super();
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeOAuthAuthorizationDataObjectFactory.bless(pointer);
    }
    /**
     * The login URL to use for authorization.
     */
    loginUrl() {
        return FfiConverterString.lift(uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
            return nativeModule().ubrn_uniffi_matrix_sdk_fn_method_oauthauthorizationdata_login_url(uniffiTypeOAuthAuthorizationDataObjectFactory.clonePointer(this), callStatus);
        }, 
        /*liftString:*/ FfiConverterString.lift));
    }
    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy() {
        const ptr = this[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeOAuthAuthorizationDataObjectFactory.pointer(this);
            uniffiTypeOAuthAuthorizationDataObjectFactory.freePointer(pointer);
            uniffiTypeOAuthAuthorizationDataObjectFactory.unbless(ptr);
            delete this[destructorGuardSymbol];
        }
    }
    static instanceOf(obj) {
        return uniffiTypeOAuthAuthorizationDataObjectFactory.isConcreteType(obj);
    }
}
const uniffiTypeOAuthAuthorizationDataObjectFactory = (() => {
    /// <reference lib="es2021" />
    const registry = typeof FinalizationRegistry !== 'undefined' ? new FinalizationRegistry((heldValue) => {
        uniffiTypeOAuthAuthorizationDataObjectFactory.freePointer(heldValue);
    }) : null;
    return {
        create(pointer) {
            const instance = Object.create(OAuthAuthorizationData.prototype);
            instance[pointerLiteralSymbol] = pointer;
            instance[destructorGuardSymbol] = this.bless(pointer);
            instance[uniffiTypeNameSymbol] = "OAuthAuthorizationData";
            return instance;
        },
        bless(p) {
            const ptr = {
                p, // make sure this object doesn't get optimized away.
                markDestroyed: () => undefined,
            };
            if (registry) {
                registry.register(ptr, p, ptr);
            }
            return ptr;
        },
        unbless(ptr) {
            if (registry) {
                registry.unregister(ptr);
            }
        },
        pointer(obj) {
            if (obj[destructorGuardSymbol] === undefined) {
                throw new UniffiInternalError.UnexpectedNullPointer();
            }
            return obj[pointerLiteralSymbol];
        },
        clonePointer(obj) {
            const pointer = this.pointer(obj);
            return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_fn_clone_oauthauthorizationdata(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        freePointer(pointer) {
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_matrix_sdk_fn_free_oauthauthorizationdata(pointer, callStatus), 
            /*liftString:*/ FfiConverterString.lift);
        },
        isConcreteType(obj) {
            return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "OAuthAuthorizationData";
        },
    };
})();
// FfiConverter for OAuthAuthorizationDataInterface
const FfiConverterTypeOAuthAuthorizationData = new FfiConverterObject(uniffiTypeOAuthAuthorizationDataObjectFactory);
// FfiConverter for boolean | undefined
const FfiConverterOptionalBool = new FfiConverterOptional(FfiConverterBool);
// FfiConverter for /*f64*/number | undefined
const FfiConverterOptionalFloat64 = new FfiConverterOptional(FfiConverterFloat64);
// FfiConverter for /*i64*/bigint | undefined
const FfiConverterOptionalInt64 = new FfiConverterOptional(FfiConverterInt64);
// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);
// FfiConverter for HeaderStyle | undefined
const FfiConverterOptionalTypeHeaderStyle = new FfiConverterOptional(FfiConverterTypeHeaderStyle);
// FfiConverter for Intent | undefined
const FfiConverterOptionalTypeIntent = new FfiConverterOptional(FfiConverterTypeIntent);
// FfiConverter for NotificationType | undefined
const FfiConverterOptionalTypeNotificationType = new FfiConverterOptional(FfiConverterTypeNotificationType);
/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
    // Get the bindings contract version from our ComponentInterface
    const bindingsContractVersion = 29;
    // Get the scaffolding contract version by calling the into the dylib
    const scaffoldingContractVersion = nativeModule().ubrn_ffi_matrix_sdk_uniffi_contract_version();
    if (bindingsContractVersion !== scaffoldingContractVersion) {
        throw new UniffiInternalError.ContractVersionMismatch(scaffoldingContractVersion, bindingsContractVersion);
    }
    if (nativeModule().ubrn_uniffi_matrix_sdk_checksum_method_oauthauthorizationdata_login_url() !== 25566) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_matrix_sdk_checksum_method_oauthauthorizationdata_login_url");
    }
}
export default Object.freeze({
    initialize: uniffiEnsureInitialized,
    converters: {
        FfiConverterTypeBackupDownloadStrategy,
        FfiConverterTypeEncryptionSystem,
        FfiConverterTypeHeaderStyle,
        FfiConverterTypeIntent,
        FfiConverterTypeNotificationType,
        FfiConverterTypeOAuthAuthorizationData,
        FfiConverterTypePaginatorState,
        FfiConverterTypeQRCodeLoginError,
        FfiConverterTypeRoomMemberRole,
        FfiConverterTypeRoomPaginationStatus,
        FfiConverterTypeRoomPowerLevelChanges,
        FfiConverterTypeServerVendorInfo,
        FfiConverterTypeVirtualElementCallWidgetConfig,
        FfiConverterTypeVirtualElementCallWidgetProperties,
    }
});
