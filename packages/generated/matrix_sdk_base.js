// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
import * as wasmBundle from "./wasm-bindgen/index.js";
import { AbstractFfiConverterByteArray, FfiConverterDuration, FfiConverterInt32, FfiConverterOptional, FfiConverterUInt64, UniffiInternalError, UniffiRustCaller, uniffiCreateFfiConverterString, uniffiCreateRecord } from "uniffi-bindgen-react-native";
// Get converters from the other files, if any.
const nativeModule = () => wasmBundle;
const uniffiCaller = new UniffiRustCaller(() => new wasmBundle.RustCallStatus());
const uniffiIsDebug = 
// @ts-ignore -- The process global might not be defined
typeof process !== "object" ||
    // @ts-ignore -- The process global might not be defined
    process?.env?.NODE_ENV !== "production" ||
    false;
/**
 * Generated factory for {@link MediaRetentionPolicy} record objects.
 */
export const MediaRetentionPolicy = (() => {
    const defaults = () => ({});
    const create = (() => {
        return uniffiCreateRecord(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link MediaRetentionPolicy}, with defaults specified
         * in Rust, in the {@link matrix_sdk_base} crate.
         */
        create,
        /**
         * Create a frozen instance of {@link MediaRetentionPolicy}, with defaults specified
         * in Rust, in the {@link matrix_sdk_base} crate.
         */
        new: create,
        /**
         * Defaults specified in the {@link matrix_sdk_base} crate.
         */
        defaults: () => Object.freeze(defaults()),
    });
})();
const FfiConverterTypeMediaRetentionPolicy = (() => {
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            return {
                maxCacheSize: FfiConverterOptionalUInt64.read(from),
                maxFileSize: FfiConverterOptionalUInt64.read(from),
                lastAccessExpiry: FfiConverterOptionalDuration.read(from),
                cleanupFrequency: FfiConverterOptionalDuration.read(from)
            };
        }
        write(value, into) {
            FfiConverterOptionalUInt64.write(value.maxCacheSize, into);
            FfiConverterOptionalUInt64.write(value.maxFileSize, into);
            FfiConverterOptionalDuration.write(value.lastAccessExpiry, into);
            FfiConverterOptionalDuration.write(value.cleanupFrequency, into);
        }
        allocationSize(value) {
            return FfiConverterOptionalUInt64.allocationSize(value.maxCacheSize) +
                FfiConverterOptionalUInt64.allocationSize(value.maxFileSize) +
                FfiConverterOptionalDuration.allocationSize(value.lastAccessExpiry) +
                FfiConverterOptionalDuration.allocationSize(value.cleanupFrequency);
        }
    }
    ;
    return new FFIConverter();
})();
const stringConverter = (() => {
    const encoder = new TextEncoder();
    const decoder = new TextDecoder();
    return {
        stringToBytes: (s) => encoder.encode(s),
        bytesToString: (ab) => decoder.decode(ab),
        stringByteLength: (s) => encoder.encode(s).byteLength,
    };
})();
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);
/**
 * Represents the state of a room encryption.
 */
export var EncryptionState;
(function (EncryptionState) {
    /**
     * The room is encrypted.
     */
    EncryptionState[EncryptionState["Encrypted"] = 0] = "Encrypted";
    /**
     * The room is not encrypted.
     */
    EncryptionState[EncryptionState["NotEncrypted"] = 1] = "NotEncrypted";
    /**
     * The state of the room encryption is unknown, probably because the
     * `/sync` did not provide all data needed to decide.
     */
    EncryptionState[EncryptionState["Unknown"] = 2] = "Unknown";
})(EncryptionState || (EncryptionState = {}));
const FfiConverterTypeEncryptionState = (() => {
    const ordinalConverter = FfiConverterInt32;
    class FFIConverter extends AbstractFfiConverterByteArray {
        read(from) {
            switch (ordinalConverter.read(from)) {
                case 1: return EncryptionState.Encrypted;
                case 2: return EncryptionState.NotEncrypted;
                case 3: return EncryptionState.Unknown;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value, into) {
            switch (value) {
                case EncryptionState.Encrypted: return ordinalConverter.write(1, into);
                case EncryptionState.NotEncrypted: return ordinalConverter.write(2, into);
                case EncryptionState.Unknown: return ordinalConverter.write(3, into);
            }
        }
        allocationSize(value) {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();
// FfiConverter for UniffiDuration | undefined
const FfiConverterOptionalDuration = new FfiConverterOptional(FfiConverterDuration);
// FfiConverter for /*u64*/bigint | undefined
const FfiConverterOptionalUInt64 = new FfiConverterOptional(FfiConverterUInt64);
/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
    // Get the bindings contract version from our ComponentInterface
    const bindingsContractVersion = 29;
    // Get the scaffolding contract version by calling the into the dylib
    const scaffoldingContractVersion = nativeModule().ubrn_ffi_matrix_sdk_base_uniffi_contract_version();
    if (bindingsContractVersion !== scaffoldingContractVersion) {
        throw new UniffiInternalError.ContractVersionMismatch(scaffoldingContractVersion, bindingsContractVersion);
    }
}
export default Object.freeze({
    initialize: uniffiEnsureInitialized,
    converters: {
        FfiConverterTypeEncryptionState,
        FfiConverterTypeMediaRetentionPolicy,
    }
});
